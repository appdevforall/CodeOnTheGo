Directory structure:
└── src/
    └── main/
        ├── AndroidManifest.xml
        └── java/
            ├── com/
            │   └── itsaky/
            │       └── androidide/
            │           └── treesitter/
            │               ├── nodeExt.kt
            │               └── pointExt.kt
            └── io/
                └── github/
                    └── rosemoe/
                        └── sora/
                            └── editor/
                                └── ts/
                                    ├── LineSpansGenerator.kt
                                    ├── LocalsCaptureSpec.kt
                                    ├── TsAnalyzeManager.kt
                                    ├── TsAnalyzeWorker.kt
                                    ├── TsBracketPairs.kt
                                    ├── TsLanguage.kt
                                    ├── TsLanguageSpec.kt
                                    ├── TsScopedVariables.kt
                                    ├── TsTextDocument.kt
                                    ├── TsTheme.kt
                                    ├── Utils.kt
                                    ├── linestyle/
                                    │   └── BreakpointDrawable.kt
                                    ├── multilang/
                                    │   ├── LanguagePriorityCheck.kt
                                    │   ├── TsIndentHelper.kt
                                    │   └── TsInjectableLanguageSpec.kt
                                    ├── predicate/
                                    │   ├── PredicateResult.kt
                                    │   ├── Predicator.kt
                                    │   ├── TsClientPredicateStep.kt
                                    │   ├── TsPredicate.kt
                                    │   ├── TsSyntheticCapture.kt
                                    │   ├── TsSyntheticCaptureContainer.kt
                                    │   └── builtin/
                                    │       ├── MatchPredicate.kt
                                    │       ├── SetCapturePredicate.kt
                                    │       └── Utils.kt
                                    └── spans/
                                        ├── DefaultSpanFactory.kt
                                        └── TsSpanFactory.kt

================================================
File: main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~    sora-editor - the awesome code editor for Android
  ~    https://github.com/Rosemoe/sora-editor
  ~    Copyright (C) 2020-2023  Rosemoe
  ~
  ~     This library is free software; you can redistribute it and/or
  ~     modify it under the terms of the GNU Lesser General Public
  ~     License as published by the Free Software Foundation; either
  ~     version 2.1 of the License, or (at your option) any later version.
  ~
  ~     This library is distributed in the hope that it will be useful,
  ~     but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  ~     Lesser General Public License for more details.
  ~
  ~     You should have received a copy of the GNU Lesser General Public
  ~     License along with this library; if not, write to the Free Software
  ~     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  ~     USA
  ~
  ~     Please contact Rosemoe by email 2073412493@qq.com if you need
  ~     additional information or have any questions
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

<manifest xmlns:android="http://schemas.android.com/apk/res/android">

</manifest>


================================================
File: main/java/com/itsaky/androidide/treesitter/nodeExt.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.treesitter

/**
 * Get the first node at the line and column.
 *
 * @param line The 0-based line number.
 * @param colBytes The 0-based column number in bytes.
 */
fun TSNode.getNodeAt(line: Int, colBytes: Int): TSNode? {
  return getDescendantForPointRange(TSPoint.create(line, colBytes),
    TSPoint.create(line, colBytes + 1))
}


================================================
File: main/java/com/itsaky/androidide/treesitter/pointExt.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.treesitter

/**
 * The 0-based start line number.
 */
val TSRange.startLine: Int
  get() = getStartPoint().getRow()

/**
 * The 0-based end line number.
 */
val TSRange.endLine: Int
  get() = getEndPoint().getRow()



================================================
File: main/java/io/github/rosemoe/sora/editor/ts/LineSpansGenerator.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

import com.itsaky.androidide.treesitter.TSInputEdit
import com.itsaky.androidide.treesitter.TSQueryCapture
import com.itsaky.androidide.treesitter.TSQueryCursor
import com.itsaky.androidide.treesitter.TSTree
import com.itsaky.androidide.treesitter.api.TreeSitterQueryCapture
import com.itsaky.androidide.treesitter.api.safeExecQueryCursor
import io.github.rosemoe.sora.editor.ts.spans.TsSpanFactory
import io.github.rosemoe.sora.lang.styling.Span
import io.github.rosemoe.sora.lang.styling.SpanFactory
import io.github.rosemoe.sora.lang.styling.Spans
import io.github.rosemoe.sora.lang.styling.TextStyle
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.widget.schemes.EditorColorScheme

/**
 * Spans generator for tree-sitter. Results are cached.
 *
 * Note that this implementation does not support external modifications.
 *
 * @author Rosemoe
 */
class LineSpansGenerator(internal var tree: TSTree, internal var lineCount: Int,
  private val content: Content, internal var theme: TsTheme,
  private val languageSpec: TsLanguageSpec, var scopedVariables: TsScopedVariables,
  private val spanFactory: TsSpanFactory) : Spans {

  companion object {

    const val CACHE_THRESHOLD = 60
  }

  private val caches = mutableListOf<SpanCache>()

  fun edit(edit: TSInputEdit) {
    tree.edit(edit)
  }

  fun queryCache(line: Int): MutableList<Span>? {
    for (i in 0 until caches.size) {
      val cache = caches[i]
      if (cache.line == line) {
        caches.removeAt(i)
        caches.add(0, cache)
        return cache.spans
      }
    }
    return null
  }

  fun pushCache(line: Int, spans: MutableList<Span>) {
    while (caches.size >= CACHE_THRESHOLD) {
      caches.removeAt(caches.size - 1)
    }
    caches.add(0, SpanCache(spans, line))
  }

  fun captureRegion(startIndex: Int, endIndex: Int): MutableList<Span> {
    val list = mutableListOf<Span>()

    if (!tree.canAccess()) {
      list.add(emptySpan(0))
      return list
    }

    val captures = mutableListOf<TSQueryCapture>()

    TSQueryCursor.create().use { cursor ->
      cursor.setByteRange(startIndex * 2, endIndex * 2)

      cursor.safeExecQueryCursor(query = languageSpec.tsQuery, tree = tree,
        recycleNodeAfterUse = true, debugLogging = false,
        debugName = "LineSpansGenerator.captureRegion()") { match ->
        if (languageSpec.queryPredicator.doPredicate(languageSpec.predicates, content, match)) {
          captures.addAll(match.captures)
        }
      }

      captures.sortBy { it.node.startByte }
      var lastIndex = 0

      for (capture in captures) {
        val startByte = capture.node.startByte
        val endByte = capture.node.endByte
        val start = (startByte / 2 - startIndex).coerceAtLeast(0)
        val pattern = capture.index
        // Do not add span for overlapping regions and out-of-bounds regions
        if (start >= lastIndex && endByte / 2 >= startIndex && startByte / 2 < endIndex && (pattern !in languageSpec.localsScopeIndices && pattern !in languageSpec.localsDefinitionIndices && pattern !in languageSpec.localsDefinitionValueIndices && pattern !in languageSpec.localsMembersScopeIndices)) {
          if (start != lastIndex) {
            list.addAll(createSpans(capture, lastIndex, start - 1, theme.normalTextStyle))
          }
          var style = 0L
          if (capture.index in languageSpec.localsReferenceIndices) {
            val def = scopedVariables.findDefinition(startByte / 2, endByte / 2,
              content.substring(startByte / 2, endByte / 2))
            if (def != null && def.matchedHighlightPattern != -1) {
              style = theme.resolveStyleForPattern(def.matchedHighlightPattern)
            }
            // This reference can not be resolved to its definition
            // but it can have its own fallback color by other captures
            // so continue to next capture
            if (style == 0L) {
              continue
            }
          }
          if (style == 0L) {
            style = theme.resolveStyleForPattern(capture.index)
          }
          if (style == 0L) {
            style = theme.normalTextStyle
          }
          val end = (endByte / 2 - startIndex).coerceAtMost(endIndex)
          list.addAll(createSpans(capture, start, end, style))
          lastIndex = end
        }

        (capture as? TreeSitterQueryCapture?)?.recycle()
      }

      if (lastIndex != endIndex) {
        list.add(emptySpan(lastIndex))
      }
    }
    if (list.isEmpty()) {
      list.add(emptySpan(0))
    }
    return list
  }

  private fun createSpans(capture: TSQueryCapture, startColumn: Int, endColumn: Int,
    style: Long): List<Span> {
    val spans = spanFactory.createSpans(capture, startColumn, style)
    if (spans.size > 1) {
      var prevCol = spans[0].column
      if (prevCol > endColumn) {
        throw IndexOutOfBoundsException(
          "Span's column is out of bounds! column=$prevCol, endColumn=$endColumn")
      }
      for (i in 1..spans.lastIndex) {
        val col = spans[i].column
        if (col <= prevCol) {
          throw IllegalStateException("Spans must not overlap! prevCol=$prevCol, col=$col")
        }
        if (col > endColumn) {
          throw IndexOutOfBoundsException(
            "Span's column is out of bounds! column=$col, endColumn=$endColumn")
        }
        prevCol = col
      }
    }
    return spans
  }

  private fun emptySpan(column: Int): Span {
    return SpanFactory.obtain(column, TextStyle.makeStyle(EditorColorScheme.TEXT_NORMAL))
  }

  override fun adjustOnInsert(start: CharPosition, end: CharPosition) {

  }

  override fun adjustOnDelete(start: CharPosition, end: CharPosition) {

  }

  override fun read() = object : Spans.Reader {

    private var spans = mutableListOf<Span>()

    override fun moveToLine(line: Int) {
      try {
        if (line < 0 || line >= lineCount) {
          spans = mutableListOf()
          return
        }
        val cached = queryCache(line)
        if (cached != null) {
          spans = cached
          return
        }
        val start = content.indexer.getCharPosition(line, 0).index
        val end = start + content.getColumnCount(line)
        spans = captureRegion(start, end)
        pushCache(line, spans)
      } catch (err: Throwable) {
        err.printStackTrace()
      }
    }

    override fun getSpanCount() = spans.size

    override fun getSpanAt(index: Int) = spans[index]

    override fun getSpansOnLine(line: Int): MutableList<Span> {
      try {
        val cached = queryCache(line)
        if (cached != null) {
          return ArrayList(cached)
        }
        val start = content.indexer.getCharPosition(line, 0).index
        val end = start + content.getColumnCount(line)
        return captureRegion(start, end)
      } catch (err: Throwable) {
        err.printStackTrace()
        throw err
      }
    }

  }

  override fun supportsModify() = false

  override fun modify(): Spans.Modifier {
    throw UnsupportedOperationException()
  }

  override fun getLineCount() = lineCount
}

data class SpanCache(val spans: MutableList<Span>, val line: Int)



================================================
File: main/java/io/github/rosemoe/sora/editor/ts/LocalsCaptureSpec.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

/**
 * Defines what type of locals pattern of a capture
 *
 * @author Rosemoe
 */
open class LocalsCaptureSpec {

  companion object {

    val DEFAULT = LocalsCaptureSpec()
  }

  open fun isDefinitionValueCapture(captureName: String) = captureName == "local.definition-value"

  open fun isDefinitionCapture(captureName: String) = captureName == "local.definition"

  open fun isReferenceCapture(captureName: String) = captureName == "local.reference"

  open fun isScopeCapture(captureName: String) = captureName == "local.scope"

  /**
   * Usually, variables in a scope take effect after their declarations. This special scope
   * indicates that, all variables in this scope (but not in its sub-scope), take effect in this
   * scope, no matter where they are.
   * For example, class member fields.
   */
  open fun isMembersScopeCapture(captureName: String) = captureName == "local.scope.members"

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsAnalyzeManager.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package io.github.rosemoe.sora.editor.ts

import android.os.Bundle
import com.itsaky.androidide.treesitter.TSInputEdit
import io.github.rosemoe.sora.editor.ts.spans.DefaultSpanFactory
import io.github.rosemoe.sora.editor.ts.spans.TsSpanFactory
import io.github.rosemoe.sora.lang.analysis.AnalyzeManager
import io.github.rosemoe.sora.lang.analysis.StyleReceiver
import io.github.rosemoe.sora.lang.styling.Styles
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.ContentReference

/**
 * @author Akash Yadav
 */
open class TsAnalyzeManager(val languageSpec: TsLanguageSpec, var theme: TsTheme) : AnalyzeManager {

  var stylesReceiver: StyleReceiver? = null
  var reference: ContentReference? = null
  var spanFactory: TsSpanFactory = DefaultSpanFactory()

  open var styles = Styles()

  private var _analyzeWorker: TsAnalyzeWorker? = null
  val analyzeWorker: TsAnalyzeWorker?
    get() = _analyzeWorker

  open fun updateTheme(theme: TsTheme) {
    this.theme = theme
    (styles.spans as LineSpansGenerator?)?.also {
      it.theme = theme
    }
  }

  fun addBreakpoint(line: Int) {
    analyzeWorker?.addBreakpoint(line)
  }

  fun removeBreakpoint(line: Int) {
    analyzeWorker?.removeBreakpoint(line)
  }

  fun removeAllBreakpoints() {
    analyzeWorker?.removeAllBreakpoints()
  }

  fun toggleBreakpoint(line: Int) {
    analyzeWorker?.toggleBreakpoint(line)
  }

  fun highlightLine(line: Int) {
    this.analyzeWorker?.highlightLine(line)
  }

  fun unhighlightLines() {
    this.analyzeWorker?.unhighlightLines()
  }

  override fun setReceiver(receiver: StyleReceiver?) {
    stylesReceiver = receiver
    _analyzeWorker?.stylesReceiver = receiver
  }

  override fun reset(content: ContentReference, extraArguments: Bundle) {
    reference = content
    rerun()
  }

  override fun insert(start: CharPosition, end: CharPosition, insertedContent: CharSequence) {
    val edit = TSInputEdit.create(
      start.index shl 1,
      start.index shl 1,
      end.index shl 1,
      start.toTSPoint(),
      start.toTSPoint(),
      end.toTSPoint()
    )!!
    (styles.spans as LineSpansGenerator?)?.apply {
      lineCount = reference!!.lineCount
      edit(edit)
    }
    _analyzeWorker?.onMod(Mod(TextMod(
      start.index,
      end.index,
      edit,
      insertedContent.toString(),
      reference?.documentVersion ?: 0
    )))
  }

  override fun delete(start: CharPosition, end: CharPosition, deletedContent: CharSequence) {
    val edit = TSInputEdit.create(
      start.index shl 1,
      end.index shl 1,
      start.index shl 1,
      start.toTSPoint(),
      end.toTSPoint(),
      start.toTSPoint()
    )!!
    (styles.spans as LineSpansGenerator?)?.apply {
      lineCount = reference!!.lineCount
      edit(edit)
    }
    _analyzeWorker?.onMod(Mod(TextMod(
      start.index,
      end.index,
      edit,
      null,
      reference?.documentVersion ?: 0
    )))
  }

  override fun rerun() {
    _analyzeWorker?.stop()
    _analyzeWorker = null

    (styles.spans as LineSpansGenerator?)?.tree?.close()
    styles.spans = null
    styles = Styles()

    val initText = reference?.reference?.toString() ?: ""

    _analyzeWorker = TsAnalyzeWorker(this, languageSpec, theme, styles, reference!!, spanFactory)
    _analyzeWorker!!.apply {
      this.stylesReceiver = this@TsAnalyzeManager.stylesReceiver
      init(Init(TextInit(initText, reference?.documentVersion ?: 0)))
      start()
    }
  }

  override fun destroy() {
    _analyzeWorker?.stop()
    _analyzeWorker = null

    (styles.spans as LineSpansGenerator?)?.tree?.close()
    styles.spans = null

    spanFactory.close()
  }
}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsAnalyzeWorker.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package io.github.rosemoe.sora.editor.ts

import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import com.itsaky.androidide.treesitter.TSInputEdit
import com.itsaky.androidide.treesitter.TSQueryCursor
import com.itsaky.androidide.treesitter.TSTree
import com.itsaky.androidide.treesitter.api.TreeSitterInputEdit
import com.itsaky.androidide.treesitter.api.TreeSitterQueryCapture
import com.itsaky.androidide.treesitter.api.safeExecQueryCursor
import com.itsaky.androidide.treesitter.string.UTF16String
import io.github.rosemoe.sora.data.ObjectAllocator
import io.github.rosemoe.sora.editor.ts.spans.TsSpanFactory
import io.github.rosemoe.sora.lang.analysis.StyleReceiver
import io.github.rosemoe.sora.lang.styling.CodeBlock
import io.github.rosemoe.sora.lang.styling.Styles
import io.github.rosemoe.sora.lang.styling.line.LineBackground
import io.github.rosemoe.sora.lang.styling.line.LineGutterBackground
import io.github.rosemoe.sora.text.ContentReference
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.newSingleThreadContext
import org.slf4j.LoggerFactory
import java.util.concurrent.CancellationException
import java.util.concurrent.LinkedBlockingQueue

/**
 * @author Akash Yadav
 */
class TsAnalyzeWorker(
  private val analyzer: TsAnalyzeManager,
  private val languageSpec: TsLanguageSpec,
  private val theme: TsTheme,
  private val styles: Styles,
  private val reference: ContentReference,
  private val spanFactory: TsSpanFactory
) {

  companion object {

    private val log = LoggerFactory.getLogger(TsAnalyzeWorker::class.java)
  }

  var stylesReceiver: StyleReceiver? = null

  @OptIn(DelicateCoroutinesApi::class, ExperimentalCoroutinesApi::class)
  private val analyzerContext = newSingleThreadContext("TsAnalyzeWorkerContext")

  private val analyzerScope = CoroutineScope(analyzerContext)
  private val messageChannel = LinkedBlockingQueue<Message<*>>()
  private var analyzerJob: Job? = null

  private var isInitialized = false
  private var isDestroyed = false

  val document = TsTextDocument(languageSpec.language)

  internal val tree: TSTree?
    get() = document.tree

  internal val text: UTF16String
    get() = document.text

  internal fun init(init: Init) {
    if (isDestroyed) {
      log.warn("Received Init after TsAnalyzeWorker has been destroyed. Ignoring...")
      return
    }

    messageChannel.offer(init)
  }

  internal fun onMod(mod: Mod) {
    if (isDestroyed) {
      log.warn("Received Mod after TsAnalyzeWorker has been destroyed. Ignoring...")
      return
    }

    messageChannel.offer(mod)
  }

  fun stop() {
    log.debug("Stopping TsAnalyzeWorker...")
    isDestroyed = true

    document.requestCancellationAndWaitIfParsing()

    analyzerContext.close()
    messageChannel.clear()
    analyzerJob?.cancel(CancellationException("Requested to be stopped"))
    analyzerScope.cancel(CancellationException("Requested to be stopped"))
    document.close()
  }

  fun start() {
    check(!isDestroyed) { "TsAnalyeWorker has already been destroyed" }

    analyzerJob = analyzerScope.launch {
      while (!isDestroyed && isActive) {
        processNextMessage()
      }
    }.also { job ->
      job.invokeOnCompletion { error ->
        if (error != null && error !is CancellationException) {
          log.error("Analyzer job failed", error)
        } else {
          log.info("Analyzer job completed")
        }
      }
    }
  }

  fun addBreakpoint(line: Int) = toggleBreakpoint(line = line, addOnly = true)
  fun removeBreakpoint(line: Int) = toggleBreakpoint(line = line, removeOnly = true)
  fun removeAllBreakpoints() {
      styles.lineStyles?.forEach { style ->
          style.eraseStyle(LineGutterBackground::class.java)
      }
      refreshLineStyles()
  }

  fun toggleBreakpoint(line: Int, addOnly: Boolean = false, removeOnly: Boolean = false) {
    require(!(addOnly && removeOnly)) {
        "set either addOnly or removeOnly, not both"
    }

    val lineStyle = styles.lineStyles?.firstOrNull { it.line == line }
    val gutterBg = lineStyle?.findOne(LineGutterBackground::class.java)
    var notify = true

    if (gutterBg == null && !removeOnly) {
      styles.addLineStyle(LineGutterBackground(line) { scheme ->
        scheme.getColor(SchemeAndroidIDE.BREAKPOINT_LINE_INDICATOR)
      })
    } else if (!addOnly) {
      styles.eraseLineStyle(line, LineGutterBackground::class.java)
    } else {
        notify = false
    }

    if (notify) {
      refreshLineStyles()
    }
  }

  fun highlightLine(line: Int) {
    val lineStyle = styles.lineStyles?.firstOrNull { it.line == line }
    val lineBg = lineStyle?.findOne(LineBackground::class.java)
    if (lineBg == null) {
      styles.addLineStyle(LineBackground(line) { scheme ->
        scheme.getColor(SchemeAndroidIDE.BREAKPOINT_LINE_BG)
      })
      refreshLineStyles()
    }
  }

  fun unhighlightLines() {
    styles.lineStyles?.forEach { style ->
      style.eraseStyle(LineBackground::class.java)
    }
    refreshLineStyles()
  }

  private fun refreshLineStyles() {
    // We can call styles.finishBuilding() instead of sorting lineStyles manually
    // but finishBuilding() performs some unnecessary tasks like iterating over and sorting
    // blockLines as well, which we don't need to do here
    // As a result, we manually sort the line styles to avoid that unnecessary processing
    styles.lineStyles?.sort()
    stylesReceiver?.setStyles(analyzer, styles)
  }

  private fun processNextMessage() {
    val message = messageChannel.take()
    if (isDestroyed) {
      return
    }

    try {
      when (message) {
        is Init -> doInit(message)
        is Mod -> doMod(message)
      }
    } catch (err: Throwable) {
      val langName = languageSpec.language.name
      val msgType = message.javaClass.simpleName
      val msgTypeSuffix = if (message is Mod) {
        "[start=${message.data.start}, end=${message.data.end}, type=${if (message.data.changedText == null) "delete" else "insert"}]"
      } else ""
      val pendingMsgs = messageChannel.size
      log.error(
        "AnalyzeWorker[lang={}, message={}{}], pendingMsgs={}] crashed",
        langName,
        msgType,
        msgTypeSuffix,
        pendingMsgs,
        err)
    }
  }

  private fun doInit(init: Init) {
    document.requestCancellationAndWaitIfParsing()

    check(!isInitialized) {
      "'Init' must be the first message to TsAnalyzeWorker"
    }

    document.doInit(init.data)
    document.reparse()
    updateStyles()

    isInitialized = true
  }

  private fun doMod(mod: Mod) {

    check(isInitialized) {
      "'Init' must be the first message to TsAnalyzeWorker"
    }

    val textMod = mod.data
    val edit = textMod.edit

    val oldTree = tree!!
    oldTree.edit(edit)

    document.doMod(textMod)

    (edit as? TreeSitterInputEdit?)?.recycle()

    document.requestCancellationAndWaitIfParsing()

    if (isDestroyed) {
      return
    }

    document.reparse(oldTree)

    oldTree.close()
    updateStyles()
  }

  private fun updateStyles() {
    if (isDestroyed || messageChannel.isNotEmpty() || tree?.canAccess() != true) {
      // analyzer stopped or
      // more message need to be processed
      return
    }

    val tree = tree!!
    val scopedVariables = TsScopedVariables(tree, text, languageSpec)
    val oldTree = (styles.spans as? LineSpansGenerator?)?.tree
    val copied = tree.copy()

    styles.spans = LineSpansGenerator(
      copied,
      reference.lineCount,
      reference.reference,
      theme,
      languageSpec,
      scopedVariables,
      spanFactory
    )

    val oldBlocks = styles.blocks
    updateCodeBlocks()
    oldBlocks?.also { ObjectAllocator.recycleBlockLines(it) }

    stylesReceiver?.setStyles(analyzer, styles) {
      oldTree?.close()
    }

    stylesReceiver?.updateBracketProvider(analyzer, TsBracketPairs(copied, languageSpec))
  }

  private fun updateCodeBlocks() {
    if (languageSpec.blocksQuery.patternCount == 0
      || !languageSpec.blocksQuery.canAccess()
      || tree?.canAccess() != true
    ) {
      return
    }

    val blocks = mutableListOf<CodeBlock>()
    TSQueryCursor.create().use { cursor ->

      cursor.safeExecQueryCursor(
        query = languageSpec.blocksQuery,
        tree = tree,
        recycleNodeAfterUse = true,
        matchCondition = { !isDestroyed },
        onClosedOrEdited = { blocks.clear() },
        debugName = "TsAnalyzeManager.updateCodeBlocks()"
      ) { match ->
        if (!languageSpec.blocksPredicator.doPredicate(
            languageSpec.predicates,
            text,
            match
          )
        ) {
          return@safeExecQueryCursor
        }

        match.captures.forEach { capture ->
          val block = ObjectAllocator.obtainBlockLine()
          var node = capture.node
          val start = node.startPoint

          block.startLine = start.row
          block.startColumn = start.column / 2

          val end = if (languageSpec.blocksQuery.getCaptureNameForId(capture.index)
              .endsWith(".marked")
          ) {
            // Goto last terminal element
            while (node.childCount > 0) {
              node = node.getChild(node.childCount - 1)
            }
            node.startPoint
          } else {
            node.endPoint
          }
          block.endLine = end.row
          block.endColumn = end.column / 2
          if (block.endLine - block.startLine > 1) {
            blocks.add(block)
          }

          (capture as? TreeSitterQueryCapture?)?.recycle()
        }
      }
    }

    val distinct = blocks.asSequence().distinct().toMutableList()
    styles.blocks = distinct
    styles.finishBuilding()
  }
}

internal interface Message<T> {

  val data: T
}

internal data class Init(override val data: TextInit) : Message<TextInit>

internal data class Mod(override val data: TextMod) : Message<TextMod>

internal data class TextInit(
  val text: String,
  val contentVersion: Long
)

internal data class TextMod(
  val start: Int,
  val end: Int,
  val edit: TSInputEdit,
  val changedText: String?,
  val contentVersion: Long
)


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsBracketPairs.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

import com.itsaky.androidide.treesitter.TSQueryCursor
import com.itsaky.androidide.treesitter.TSTree
import com.itsaky.androidide.treesitter.api.TreeSitterQueryCapture
import com.itsaky.androidide.treesitter.api.safeExecQueryCursor
import io.github.rosemoe.sora.lang.brackets.BracketsProvider
import io.github.rosemoe.sora.lang.brackets.PairedBracket
import io.github.rosemoe.sora.text.Content
import kotlin.math.max

class TsBracketPairs(private val tree: TSTree, private val languageSpec: TsLanguageSpec) :
  BracketsProvider {

  companion object {

    val OPEN_NAME = "editor.brackets.open"
    val CLOSE_NAME = "editor.brackets.close"

  }

  override fun getPairedBracketAt(text: Content, index: Int): PairedBracket? {
    if (!languageSpec.bracketsQuery.canAccess() || languageSpec.bracketsQuery.patternCount <= 0 || !tree.canAccess()) {
      return null
    }

    return TSQueryCursor.create().use { cursor ->
      cursor.setByteRange(max(0, index - 1) * 2, index * 2 + 1)

      var matched = false

      return@use cursor.safeExecQueryCursor(query = languageSpec.bracketsQuery, tree = tree,
        recycleNodeAfterUse = true, whileTrue = { !matched },
        debugName = "TsBracketPairs.getPairedBracketAt()") { match ->
        if (!languageSpec.bracketsPredicator.doPredicate(languageSpec.predicates, text, match)) {
          return@safeExecQueryCursor null
        }

        // do not store TSNode instances from the capture
        // this is because the nodes are also recycled with the TSQueryCapture instances
        val positions = IntArray(4) { -1 }

        for (capture in match.captures) {
          val captureName = languageSpec.bracketsQuery.getCaptureNameForId(capture.index)
          if (captureName == OPEN_NAME || captureName == CLOSE_NAME) {
            val node = capture.node
            if (index >= node.startByte / 2 && index <= node.endByte / 2) {
              matched = true
            }
            if (captureName == OPEN_NAME) {
              positions[0] = node.startByte
              positions[1] = node.endByte
            } else {
              positions[2] = node.startByte
              positions[3] = node.endByte
            }
          }

          (capture as? TreeSitterQueryCapture?)?.recycle()
        }

        val startStartByte = positions[0]
        val startEndByte = positions[1]
        val endStartByte = positions[2]
        val endEndByte = positions[3]

        if (matched && positions.find { it == -1 } == null) {
          return@safeExecQueryCursor PairedBracket(startStartByte / 2,
            (startEndByte - startStartByte) / 2, endStartByte / 2, (endEndByte - endStartByte) / 2)
        }

        return@safeExecQueryCursor null
      }
    }
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsLanguage.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

import android.os.Bundle
import io.github.rosemoe.sora.lang.EmptyLanguage
import io.github.rosemoe.sora.lang.Language
import io.github.rosemoe.sora.lang.completion.CompletionPublisher
import io.github.rosemoe.sora.lang.format.Formatter
import io.github.rosemoe.sora.lang.smartEnter.NewlineHandler
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.ContentReference
import io.github.rosemoe.sora.widget.SymbolPairMatch

/**
 * Tree-sitter based language.
 *
 * @param languageSpec The language specification for parsing and highlighting
 * @param themeDescription Theme for colorizing nodes
 * @param tab whether tab should be used
 *
 * @see TsTheme
 * @see TsLanguageSpec
 *
 * @author Rosemoe
 */
open class TsLanguage(
  val languageSpec: TsLanguageSpec,
  val tab: Boolean = false,
  themeDescription: TsThemeBuilder.() -> Unit
) : Language {

  init {
    if (languageSpec.closed) {
      throw IllegalStateException("spec is closed")
    }
  }

  protected var tsTheme = TsThemeBuilder(languageSpec.tsQuery).apply { themeDescription() }.theme

  open val analyzer by lazy {
    TsAnalyzeManager(languageSpec, tsTheme)
  }

  /**
   * Update tree-sitter colorizing theme with the given description
   */
  fun updateTheme(themeDescription: TsThemeBuilder.() -> Unit) = languageSpec.let {
    if (it.closed) {
      throw IllegalStateException("spec is closed")
    }
    updateTheme(TsThemeBuilder(languageSpec.tsQuery).apply { themeDescription() }.theme)
  }

  /**
   * Update tree-sitter colorizing theme
   */
  fun updateTheme(theme: TsTheme) {
    this.tsTheme = theme
    analyzer.updateTheme(theme)
  }

  override fun getAnalyzeManager() = analyzer

  override fun getInterruptionLevel() = Language.INTERRUPTION_LEVEL_STRONG

  override fun requireAutoComplete(
    content: ContentReference,
    position: CharPosition,
    publisher: CompletionPublisher,
    extraArguments: Bundle
  ) {
    // Nothing
  }

  override fun getIndentAdvance(content: ContentReference, line: Int, column: Int) = 0

  override fun useTab() = tab

  override fun getFormatter(): Formatter = EmptyLanguage.EmptyFormatter.INSTANCE

  override fun getSymbolPairs(): SymbolPairMatch = EmptyLanguage.EMPTY_SYMBOL_PAIRS

  override fun getNewlineHandlers() = emptyArray<NewlineHandler>()

  override fun destroy() {
    languageSpec.close()
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsLanguageSpec.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

import com.itsaky.androidide.treesitter.TSLanguage
import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryError
import io.github.rosemoe.sora.editor.ts.predicate.Predicator
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.builtin.MatchPredicate
import java.io.Closeable

/**
 * Language specification for tree-sitter highlighter. This specification covers language code
 * parsing, highlighting captures and local variable tracking descriptions.
 *
 * Note that you must use ASCII characters in your scm sources. Otherwise, an [IllegalArgumentException] is
 * thrown.
 * Be careful that this should be closed to avoid native memory leaks.
 *
 * @author Rosemoe
 * @param language The tree-sitter language instance to be used for parsing
 * @param highlightScmSource The scm source code for highlighting tree nodes
 * @param codeBlocksScmSource The scm source for capturing code blocks.
 *                          All captured nodes are considered to be a code block.
 *                          Capture named with '.marked' suffix will have its last terminal node's start position as its scope end
 * @param bracketsScmSource The scm source for capturing brackets. Capture named 'editor.brackets.open' and 'editor.brackets.close' are used to compute bracket pairs
 * @param localsScmSource The scm source code for tracking local variables
 * @param localsCaptureSpec Custom specification for locals scm file
 * @param predicates Client custom predicate implementations
 */
open class TsLanguageSpec(
  val language: TSLanguage,
  highlightScmSource: String,
  codeBlocksScmSource: String = "",
  bracketsScmSource: String = "",
  localsScmSource: String = "",
  localsCaptureSpec: LocalsCaptureSpec = LocalsCaptureSpec.DEFAULT,
  val predicates: List<TsPredicate> = listOf(MatchPredicate)
) : Closeable {

  /**
   * The generated scm source code for querying
   */
  val querySource = localsScmSource + "\n" + highlightScmSource

  /**
   * Offset of highlighting scm source code in [querySource]
   */
  val highlightScmOffset = localsScmSource.encodeToByteArray().size + 1

  /**
   * The actual [TSQuery] object
   */
  val tsQuery = TSQuery.create(language, querySource)

  /**
   * The first index of highlighting pattern
   */
  val highlightPatternOffset: Int

  /**
   * Indices of variable definition patterns
   */
  val localsDefinitionIndices = mutableListOf<Int>()

  /**
   * Indices of variable reference patterns
   */
  val localsReferenceIndices = mutableListOf<Int>()

  /**
   * Indices of variable scope patterns
   */
  val localsScopeIndices = mutableListOf<Int>()

  /**
   * Indices of weak variable scope patterns
   * @see [LocalsCaptureSpec.isMembersScopeCapture] for more information
   */
  val localsMembersScopeIndices = mutableListOf<Int>()

  /**
   * Indices of variable definition-value patterns. Currently unused in analysis.
   */
  val localsDefinitionValueIndices = mutableListOf<Int>()

  val blocksQuery = if (codeBlocksScmSource.isBlank()) {
    TSQuery.EMPTY
  } else TSQuery.create(language, codeBlocksScmSource)

  val bracketsQuery = if (bracketsScmSource.isBlank()) {
    TSQuery.EMPTY
  } else TSQuery.create(language, bracketsScmSource)

  init {
    // Check the queries before access
    try {
      blocksQuery.validateOrThrow("code-blocks")
      bracketsQuery.validateOrThrow("brackets")
      querySource.forEach {
        if (it > 0xFF.toChar()) {
          throw IllegalArgumentException("use non-ASCII characters in scm source is unexpected")
        }
      }
      if (!tsQuery.canAccess()) {
        throw IllegalArgumentException("Syntax highlights query is invalid, errOffset=" + tsQuery.errorOffset + ", errType=" + tsQuery.errorType)
      }
      if (tsQuery.errorType != TSQueryError.None) {
        val region = if (tsQuery.errorOffset < highlightScmOffset) "locals" else "highlight"
        val offset =
          if (tsQuery.errorOffset < highlightScmOffset) tsQuery.errorOffset else tsQuery.errorOffset - highlightScmOffset
        throw IllegalArgumentException(
          "bad scm sources: error ${tsQuery.errorType.name} occurs in $region range at offset $offset")
      }
    } catch (e: IllegalArgumentException) {
      tsQuery.close()
      blocksQuery.close()
      bracketsQuery.close()
      throw e
    }
  }

  val queryPredicator = Predicator(tsQuery)

  val blocksPredicator = Predicator(blocksQuery)

  val bracketsPredicator = Predicator(bracketsQuery)

  /**
   * Close flag
   */
  var closed = false
    private set

  init {
    var highlightOffset = 0
    for (i in 0 until tsQuery.captureCount) {
      // Only locals in localsScm are taken down
      val name = tsQuery.getCaptureNameForId(i)
      if (localsCaptureSpec.isDefinitionCapture(name)) {
        localsDefinitionIndices.add(i)
      } else if (localsCaptureSpec.isReferenceCapture(name)) {
        localsReferenceIndices.add(i)
      } else if (localsCaptureSpec.isScopeCapture(name)) {
        localsScopeIndices.add(i)
      } else if (localsCaptureSpec.isDefinitionValueCapture(name)) {
        localsDefinitionValueIndices.add(i)
      } else if (localsCaptureSpec.isMembersScopeCapture(name)) {
        localsMembersScopeIndices.add(i)
      }
    }
    for (i in 0 until tsQuery.patternCount) {
      if (tsQuery.getStartByteForPattern(i) < highlightScmOffset) {
        highlightOffset++
      }
    }
    highlightPatternOffset = highlightOffset
  }

  override fun close() {
    tsQuery.close()
    blocksQuery.close()
    bracketsQuery.close()
    closed = true
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsScopedVariables.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

import com.itsaky.androidide.treesitter.TSNode
import com.itsaky.androidide.treesitter.TSQueryCapture
import com.itsaky.androidide.treesitter.TSQueryCursor
import com.itsaky.androidide.treesitter.TSTree
import com.itsaky.androidide.treesitter.api.TreeSitterNode
import com.itsaky.androidide.treesitter.api.TreeSitterQueryCapture
import com.itsaky.androidide.treesitter.api.safeExecQueryCursor
import com.itsaky.androidide.treesitter.string.UTF16String
import java.util.Stack

private typealias TSNodeIndices = Pair<Int, Int>

private fun TSNode.indices(): TSNodeIndices {
  return startByte to endByte
}

/**
 * Class for storing tree-sitter variables. This class tracks the positions and scopes
 * of variables and find definitions.
 *
 * @author Rosemoe
 * @param tree The parsed tree
 * @param text The current text for tree
 * @param spec Language specification, which should the same as highlighter's
 */
class TsScopedVariables(tree: TSTree, text: UTF16String, val spec: TsLanguageSpec) {

  private val rootScope: Scope

  init {
    val rootNode = tree.rootNode
    var needsWalk = true
    rootScope = if (rootNode.canAccess()) {
      Scope(0, rootNode.endByte / 2)
    } else {
      needsWalk = false
      Scope(0, 0)
    }

    if (needsWalk && spec.localsDefinitionIndices.isNotEmpty()) {
      TSQueryCursor.create().use { cursor ->

        val captures = mutableListOf<TSQueryCapture>()
        cursor.safeExecQueryCursor(
          query = spec.tsQuery,
          tree = tree,
          recycleNodeAfterUse = true,
          onClosedOrEdited = { captures.clear() },
          debugName = "TsScopedVariables.init()"
        ) { match ->

          if (spec.queryPredicator.doPredicate(spec.predicates, text, match)) {
            captures.addAll(match.captures)
          }
        }

        captures.sortBy { it.node.startByte }
        val scopeStack = Stack<Scope>()

        // TSNode instance will be recycled after every iteration
        // so we store the start and end bytes only
        var lastAddedVariableNodeIndices: TSNodeIndices? = null

        scopeStack.push(rootScope)
        for (capture in captures) {
          val startIndex = capture.node.startByte / 2
          val endIndex = capture.node.endByte / 2
          while (startIndex >= scopeStack.peek().endIndex) {
            scopeStack.pop()
          }
          val pattern = capture.index
          if (pattern in spec.localsScopeIndices) {
            val newScope = Scope(startIndex, endIndex)
            scopeStack.peek().childScopes.add(newScope)
            scopeStack.push(newScope)
          } else if (pattern in spec.localsMembersScopeIndices) {
            val newScope = Scope(startIndex, endIndex, true)
            scopeStack.peek().childScopes.add(newScope)
            scopeStack.push(newScope)
          } else if (pattern in spec.localsDefinitionIndices) {
            val scope = scopeStack.peek()
            val name = text.substringChars(startIndex, endIndex)
            val scopedVar = ScopedVariable(
              name,
              if (scope.forMembers) scope.startIndex else startIndex,
              scope.endIndex
            )
            scope.variables.add(scopedVar)
            lastAddedVariableNodeIndices = capture.node.indices()
          } else if (pattern !in spec.localsDefinitionValueIndices && pattern !in spec.localsReferenceIndices && lastAddedVariableNodeIndices != null) {
            val topVariables = scopeStack.peek().variables
            if (topVariables.isNotEmpty()) {
              val topVariable = topVariables.last()
              if (lastAddedVariableNodeIndices.first / 2 == startIndex && lastAddedVariableNodeIndices.second / 2 == endIndex && topVariable.matchedHighlightPattern == -1) {
                topVariable.matchedHighlightPattern = pattern
              }
            }
          }

          (capture as? TreeSitterQueryCapture?)?.apply {
            if (!isRecycled) {
              recycle()
            }
          }
        }
      }
    }

    (rootNode as? TreeSitterNode?)?.recycle()
  }

  data class Scope(
    val startIndex: Int,
    val endIndex: Int,
    val forMembers: Boolean = false,
    val variables: MutableList<ScopedVariable> = mutableListOf(),
    val childScopes: MutableList<Scope> = mutableListOf()
  )

  data class ScopedVariable(
    var name: String,
    var scopeStartIndex: Int,
    var scopeEndIndex: Int,
    var matchedHighlightPattern: Int = -1
  )

  fun findDefinition(startIndex: Int, endIndex: Int, name: String): ScopedVariable? {
    var definition: ScopedVariable? = null
    var currentScope: Scope? = rootScope
    while (currentScope != null) {
      for (variable in currentScope.variables) {
        if (variable.scopeStartIndex > startIndex) {
          break
        }
        if (variable.scopeStartIndex <= startIndex && variable.scopeEndIndex >= endIndex && variable.name == name) {
          definition = variable
          // Do not break here: name can be shadowed in some languages
        }
      }
      currentScope =
        currentScope.childScopes.firstOrNull { scope -> scope.startIndex <= startIndex && scope.endIndex >= endIndex }
    }
    return definition
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsTextDocument.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package io.github.rosemoe.sora.editor.ts

import com.itsaky.androidide.treesitter.TSLanguage
import com.itsaky.androidide.treesitter.TSParser
import com.itsaky.androidide.treesitter.TSTree
import com.itsaky.androidide.treesitter.string.UTF16String
import com.itsaky.androidide.treesitter.string.UTF16StringFactory

/**
 * A text document which maintains a [TSTree] and the associated [UTF16String].
 *
 * @author Akash Yadav
 */
class TsTextDocument(
  language: TSLanguage
) : AutoCloseable {

  @Volatile
  private var documentVersion = 1L

  /**
   * The version of this text document.
   */
  val version: Long
    get() = documentVersion

  /**
   * The source text.
   */
  val text = UTF16StringFactory.newString()

  /**
   * The parser used to parse the source text into a syntax tree.
   */
  val parser = TSParser.create().also {
    it.language = language
  }

  /**
   * The syntax tree.
   */
  var tree: TSTree? = null
    internal set

  /**
   * Request the parser to cancel parsing if a parsing is in progress.
   */
  fun requestCancellationAndWaitIfParsing() {
    if (parser.isParsing) {
      parser.requestCancellationAndWait()
    }
  }

  /**
   * Initialize the source text with the given initialization message. The caller is responsible
   * for handling the source text state i.e. this method does not check whether the text is already
   * initialized or not.
   */
  internal fun doInit(init: TextInit) {
    text.append(init.text)
    documentVersion = init.contentVersion
  }

  /**
   * Apply the given [text modification][TextMod] to the source text.
   *
   * @param mod The text modification.
   */
  internal fun doMod(mod: TextMod) {
    val edit = mod.edit
    val newText = mod.changedText

    if (newText == null) {
      text.deleteBytes(edit.startByte, edit.oldEndByte)
    } else {
      if (mod.start == text.length) {
        text.append(newText)
      } else {
        text.insert(mod.start, newText)
      }
    }

    documentVersion = mod.contentVersion
  }

  /**
   * Parse the source text into a syntax tree, using the given [oldTree] for incremental parsing.
   */
  internal fun reparse(oldTree: TSTree? = null): TSTree? {
    tree = parser.parseString(oldTree, text)
    return tree
  }

  override fun close() {
    text?.close()
    tree?.close()
    parser.close()
  }
}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/TsTheme.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

import androidx.collection.MutableIntLongMap
import com.itsaky.androidide.treesitter.TSQuery
import io.github.rosemoe.sora.lang.styling.TextStyle
import io.github.rosemoe.sora.widget.schemes.EditorColorScheme

/**
 * Theme for tree-sitter. This is different from [io.github.rosemoe.sora.widget.schemes.EditorColorScheme].
 * It is only used for colorizing spans in tree-sitter module. The real colors are still stored in editor
 * color schemes.
 * As what tree-sitter do, we try to match the longest scope.
 * For example, if 'variable' and 'variable.builtin' rule are both defined, Query 'variable.builtin'
 * and 'variable.builtin.this' will get 'variable.builtin' rule.
 * The theme also provide a fallback. You may call [TsTheme.putStyleRule] with a rule of length 0 to
 *  set fallback color scheme.
 * Note that colors of 'locals.definition', 'locals.reference', etc. can not be set by this theme object.
 *
 * @author Rosemoe
 */
class TsTheme(private val tsQuery: TSQuery) {

  private val styles = mutableMapOf<String, Long>()
  private val mapping = MutableIntLongMap()

  /**
   * The text style for normal texts
   */
  var normalTextStyle = TextStyle.makeStyle(EditorColorScheme.TEXT_NORMAL)

  /**
   * Set text style for the given rule string.
   *
   * @param rule The rule for locating nodes
   * @param style The style value for those nodes
   * @see io.github.rosemoe.sora.lang.styling.TextStyle
   */
  fun putStyleRule(rule: String, style: Long) {
    styles[rule] = style
    mapping.clear()
  }

  /**
   * Remove rule
   * @param rule The rule for locating nodes
   */
  fun eraseStyleRule(rule: String) = putStyleRule(rule, 0L)

  fun resolveStyleForPattern(pattern: Int): Long {
    return mapping.getOrElse(pattern) {
      var mappedName = tsQuery.getCaptureNameForId(pattern)
      var style = styles[mappedName] ?: 0L
      while (style == 0L && mappedName.isNotEmpty()) {
        mappedName = mappedName.substringBeforeLast('.', "")
        style = styles[mappedName] ?: 0L
      }
      mapping.put(pattern, style)
      style
    }
  }

}

/**
 * Builder class for tree-sitter themes
 */
class TsThemeBuilder(tsQuery: TSQuery) {

  internal val theme = TsTheme(tsQuery)

  infix fun Long.applyTo(targetRule: String) {
    theme.putStyleRule(targetRule, this)
  }

  infix fun Long.applyTo(targetRules: Array<String>) {
    targetRules.forEach {
      applyTo(it)
    }
  }

}

/**
 * Build tree-sitter theme
 */
fun tsTheme(tsQuery: TSQuery, description: TsThemeBuilder.() -> Unit) =
  TsThemeBuilder(tsQuery).also { it.description() }.theme


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/Utils.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts

import com.itsaky.androidide.treesitter.TSPoint
import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryError
import io.github.rosemoe.sora.text.CharPosition

/**
 * Convert a [CharPosition] object to a [TSPoint] object
 */
fun CharPosition.toTSPoint(): TSPoint = TSPoint.create(line, column shl 1)!!

fun TSQuery.validateOrThrow(name: String = "unknown") {
  if (errorType != TSQueryError.None) {
    throw IllegalArgumentException(
      "query(name:$name) parsing failed: ${errorType.name} at text offset $errorOffset")
  }
}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/linestyle/BreakpointDrawable.kt
================================================
package io.github.rosemoe.sora.editor.ts.linestyle

import android.graphics.Color
import android.graphics.drawable.GradientDrawable

/**
 * @author Akash Yadav
 */
class BreakpointDrawable @JvmOverloads constructor(
    orientation: Orientation = Orientation.TOP_BOTTOM,
    colors: IntArray? = null,
) : GradientDrawable(
    orientation, colors
) {
    init {
        shape = OVAL
        setColor(Color.RED)
    }
}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/multilang/LanguagePriorityCheck.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.multilang

interface LanguagePriorityCheck {

  companion object {

    val PRIORITY_NEVER = 0
    val PRIORITY_AS_FALLBACK = 1
    val PRIORITY_ALWAYS = 1000
  }

  fun getPriorityByName(name: String): Int

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/multilang/TsIndentHelper.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.multilang

interface TsIndentHelper {
}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/multilang/TsInjectableLanguageSpec.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.multilang

import com.itsaky.androidide.treesitter.TSLanguage
import io.github.rosemoe.sora.editor.ts.LocalsCaptureSpec
import io.github.rosemoe.sora.editor.ts.TsLanguageSpec
import io.github.rosemoe.sora.editor.ts.TsThemeBuilder
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.builtin.MatchPredicate

class TsInjectableLanguageSpec(
  language: TSLanguage,
  highlightScmSource: String,
  themeDescription: TsThemeBuilder.() -> Unit,
  val languageName: LanguagePriorityCheck,
  val indentHelper: TsIndentHelper? = null,
  codeBlocksScmSource: String = "",
  bracketsScmSource: String = "",
  localsScmSource: String = "",
  localsCaptureSpec: LocalsCaptureSpec = LocalsCaptureSpec.DEFAULT,
  predicates: List<TsPredicate> = listOf(MatchPredicate)
) : TsLanguageSpec(language, highlightScmSource, codeBlocksScmSource, bracketsScmSource,
  localsScmSource, localsCaptureSpec, predicates) {

  var theme = TsThemeBuilder(tsQuery).apply { themeDescription() }.theme

  fun updateTheme(themeDescription: TsThemeBuilder.() -> Unit) = run {
    if (closed) {
      throw IllegalStateException("spec is closed")
    }
    theme = TsThemeBuilder(tsQuery).apply { themeDescription() }.theme
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/PredicateResult.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate

/**
 * Predicate result for [TsPredicate]
 */
enum class PredicateResult {

  /**
   * The given predicate is not handled by this [TsPredicate].
   * The [com.itsaky.androidide.treesitter.TSQueryMatch] object will be passed to other [TsPredicate].
   */
  UNHANDLED,

  /**
   * The given predicate is accepted by the [TsPredicate]
   */
  ACCEPT,

  /**
   * The given predicate is not accepted by the [TsPredicate]
   */
  REJECT
}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/Predicator.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSQueryPredicateStep

/**
 * Predicate runner for tree-sitter
 *
 * @author Rosemoe
 */
class Predicator(private val query: TSQuery) {

  /**
   * Predicates for patterns
   */
  private val patternPredicates = mutableListOf<List<TsClientPredicateStep>>()

  init {
    for (i in 0 until query.patternCount) {
      patternPredicates.add(query.getPredicatesForPattern(i).map {
        when (it.type) {
          TSQueryPredicateStep.Type.String -> TsClientPredicateStep(
            it.type,
            query.getStringValueForId(it.valueId)
          )

          TSQueryPredicateStep.Type.Capture -> TsClientPredicateStep(
            it.type,
            query.getCaptureNameForId(it.valueId)
          )

          else -> TsClientPredicateStep(it.type, "")
        }
      })
    }
  }

  fun doPredicate(
    predicates: List<TsPredicate>,
    text: CharSequence,
    match: TSQueryMatch,
    syntheticCaptureContainer: TsSyntheticCaptureContainer = TsSyntheticCaptureContainer.EMPTY_IMMUTABLE_CONTAINER
  ): Boolean {
    val description = patternPredicates[match.patternIndex]
    var tail = 0
    for (i in description.indices) {
      if (description[i].predicateType == TSQueryPredicateStep.Type.Done) {
        // Avoid allocating sublist if possible
        val subPredicateStep =
          if (tail == 0 && i + 1 == description.size) description else description.subList(
            tail,
            i + 1
          )
        for (j in predicates.indices) {
          val predicate = predicates[j]
          when (predicate.doPredicate(query, text, match, subPredicateStep,
            syntheticCaptureContainer)) {
            PredicateResult.ACCEPT -> break
            PredicateResult.REJECT -> return false
            else -> {}
          }
        }
        tail = i + 1
      }
    }

    return true
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/TsClientPredicateStep.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate

import com.itsaky.androidide.treesitter.TSQueryPredicateStep

data class TsClientPredicateStep(
  val predicateType: TSQueryPredicateStep.Type,
  val content: String
)



================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/TsPredicate.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch

/**
 * Predicate client-side implementation
 */
interface TsPredicate {

  /**
   * Run the predicate on the given [TSQueryMatch]
   * @see TSQueryMatch
   * @see PredicateResult
   */
  fun doPredicate(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/TsSyntheticCapture.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate

import com.itsaky.androidide.treesitter.TSNode

data class TsSyntheticCapture(
  val captureName: String,
  val captureText: String? = null,
  val captureNode: TSNode? = null
)


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/TsSyntheticCaptureContainer.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate

class TsSyntheticCaptureContainer(private val noAddOperation: Boolean = false) {

  companion object {

    val EMPTY_IMMUTABLE_CONTAINER = TsSyntheticCaptureContainer(true)
  }

  private val syntheticCaptures = mutableListOf<TsSyntheticCapture>()

  val indices
    get() = syntheticCaptures.indices

  val size
    get() = syntheticCaptures.size

  operator fun get(index: Int) = syntheticCaptures[index]

  fun addSyntheticCapture(syntheticCapture: TsSyntheticCapture) {
    if (syntheticCapture.captureNode == null && syntheticCapture.captureText == null) {
      throw IllegalArgumentException(
        "at least one field between 'captureText' and 'captureNode' should be non-null")
    }
    if (noAddOperation) {
      return
    }
    syntheticCaptures.add(syntheticCapture)
  }

  fun clear() {
    syntheticCaptures.clear()
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/builtin/MatchPredicate.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate.builtin

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSQueryPredicateStep.Type
import io.github.rosemoe.sora.editor.ts.predicate.PredicateResult
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCaptureContainer
import java.util.concurrent.ConcurrentHashMap
import java.util.regex.PatternSyntaxException

object MatchPredicate : TsPredicate {

  private val PARAMETERS = arrayOf(Type.String, Type.Capture, Type.String, Type.Done)

  private val cache = ConcurrentHashMap<String, Regex>()

  override fun doPredicate(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult {
    if (!parametersMatch(predicateSteps, PARAMETERS) || predicateSteps[0].content != "match?") {
      return PredicateResult.UNHANDLED
    }
    val captured = getCaptureContent(tsQuery, match, predicateSteps[1].content, text)
    try {
      var regex = cache[predicateSteps[2].content]
      if (regex == null) {
        regex = Regex(predicateSteps[2].content)
        cache[predicateSteps[2].content] = regex
      }
      for (str in captured) {
        if (regex.find(str) == null) {
          return PredicateResult.REJECT
        }
      }
      return PredicateResult.ACCEPT
    } catch (e: PatternSyntaxException) {
      e.printStackTrace()
      return PredicateResult.UNHANDLED
    }
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/builtin/SetCapturePredicate.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate.builtin

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSQueryPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.PredicateResult
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCapture
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCaptureContainer

object SetCapturePredicate : TsPredicate {

  private val PARAMETERS_1 = arrayOf(
    TSQueryPredicateStep.Type.String,
    TSQueryPredicateStep.Type.Capture,
    TSQueryPredicateStep.Type.String,
    TSQueryPredicateStep.Type.Done
  )
  private val PARAMETERS_2 = arrayOf(
    TSQueryPredicateStep.Type.String,
    TSQueryPredicateStep.Type.Capture,
    TSQueryPredicateStep.Type.Capture,
    TSQueryPredicateStep.Type.Done
  )

  override fun doPredicate(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult {
    if (predicateSteps[0].content == "set!") {
      if (parametersMatch(predicateSteps, PARAMETERS_1)) {
        syntheticCaptures.addSyntheticCapture(
          TsSyntheticCapture(
            predicateSteps[1].content,
            predicateSteps[2].content
          )
        )
      } else if (parametersMatch(predicateSteps, PARAMETERS_2)) {
        val captureTexts = getCaptureContent(tsQuery, match, predicateSteps[2].content, text)
        if (captureTexts.size == 1) {
          syntheticCaptures.addSyntheticCapture(
            TsSyntheticCapture(
              predicateSteps[1].content,
              captureTexts[0]
            )
          )
        }
      }
    }
    // As this does not affect whether the match is actually valid, we always return UNHANDLED
    return PredicateResult.UNHANDLED
  }

}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/predicate/builtin/Utils.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.predicate.builtin

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSQueryPredicateStep.Type
import com.itsaky.androidide.treesitter.string.UTF16String
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.text.Content

fun parametersMatch(
  predicate: List<TsClientPredicateStep>,
  types: Array<Type>
): Boolean {
  if (predicate.size == types.size) {
    for (i in types.indices) {
      if (predicate[i].predicateType != types[i]) {
        return false
      }
    }
    return true
  }
  return false
}

fun getCaptureContent(
  tsQuery: TSQuery,
  match: TSQueryMatch,
  captureName: String,
  text: CharSequence
) = match.captures.filter { tsQuery.getCaptureNameForId(it.index) == captureName }
  .map { capture ->
    when (text) {
      is UTF16String -> text.substringBytes(capture.node.startByte, capture.node.endByte)
      is Content -> text.substring(capture.node.startByte shr 1, capture.node.endByte shr 1)
      else -> text.substring(capture.node.startByte shr 1, capture.node.endByte shr 1)
    }
  }


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/spans/DefaultSpanFactory.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.spans

import com.itsaky.androidide.treesitter.TSQueryCapture
import io.github.rosemoe.sora.lang.styling.Span
import io.github.rosemoe.sora.lang.styling.SpanFactory

/**
 * Default implementation of the [TsSpanFactory].
 *
 * @author Akash Yadav
 */
open class DefaultSpanFactory : TsSpanFactory {

  override fun createSpans(capture: TSQueryCapture, column: Int, spanStyle: Long): List<Span> {
    return listOf(SpanFactory.obtain(column, spanStyle))
  }

  override fun close() {
  }
}


================================================
File: main/java/io/github/rosemoe/sora/editor/ts/spans/TsSpanFactory.kt
================================================
/*******************************************************************************
 *    sora-editor - the awesome code editor for Android
 *    https://github.com/Rosemoe/sora-editor
 *    Copyright (C) 2020-2023  Rosemoe
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 *     USA
 *
 *     Please contact Rosemoe by email 2073412493@qq.com if you need
 *     additional information or have any questions
 ******************************************************************************/

package io.github.rosemoe.sora.editor.ts.spans

import com.itsaky.androidide.treesitter.TSQueryCapture
import io.github.rosemoe.sora.lang.styling.Span

/**
 * Factory for creating spans for the tree sitter analyze manager.
 *
 * @author Akash Yadav
 */
interface TsSpanFactory : AutoCloseable {

  /**
   * Creates the spans using the provided data.
   *
   * @param capture The query capture. More information about the node can be found using the [TSQueryCapture.node] object.
   * @param column The start column index for the span.
   * @param spanStyle The style for the spans.
   * @return The [Span] objects.
   */
  fun createSpans(capture: TSQueryCapture, column: Int, spanStyle: Long): List<Span>
}

