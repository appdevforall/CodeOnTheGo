## Engineering Design Document: Simple Local Web Server

### 1. Introduction
This document details the engineering design for the Simple Local Web Server, addressing the requirements outlined in the Product Requirements Document (PRD). It specifies the architectural choices, component design, data structures, and implementation details for a web server built with Kotlin and OpenJDK17, capable of serving content from both the file system and a SQLite3 database, using a pre-defined schema.

### 2. Technology Stack
* **Programming Language:** Kotlin
* **JVM:** OpenJDK17
* **Networking Library:** Standard Java/Kotlin `java.nio` for fundamental control and minimal dependencies.
* **SQLite Driver:** Xerial SQLite-JDBC (`org.xerial:sqlite-jdbc`)
* **Configuration Library:** `toml4j` (`com.moandjiezana.toml:toml4j`) for parsing TOML files.

### 3. Architecture Overview

The server will follow a classic multi-threaded, blocking I/O model for simplicity, with a thread pool to handle concurrent client connections.

```
+---------------------+
|                     |
|  Main Server Loop   |
| (Accepts Connections)|
|                     |
+----------+----------+
           |
           | New Connection
           v
+----------+----------+
|                     |
|  Connection Pool    |
|  (Executes Handlers)|
|                     |
+----------+----------+
           |
           | Request Processing
           v
+-----------------------+-----------------------+
|                       |                       |
|  Request Parser       |  Response Builder     |
|  (Parses HTTP Request)|  (Constructs HTTP Resp)|
|                       |                       |
+-----------+-----------+-----------+-----------+
            |                       |
            |                       |
            v                       v
+-----------+-----------+-----------+-----------+
|                       |                       |
|  Static File Handler  |  SQLite Database Hndlr|
|  (Serves from FS)     |  (Serves from DB)     |
|                       |                       |
+-----------------------+-----------------------+
            ^
            | (Internal Utility)
+-----------+-----------+
|                       |
|  MIME Type Resolver   |
|                       |
+-----------------------+

```

### 4. Component Design

#### 4.1. `WebServer` (Main Application Entry Point)
* **Purpose:** Initializes the server, parses configuration, binds to the specified port, and manages incoming connections.
* **Responsibilities:**
    * **Load configuration from TOML file.**
    * Parse command-line arguments (which may override TOML settings for specific parameters like config file path).
    * Create and configure a `ServerSocket`.
    * Start a loop to accept incoming client connections.
    * Submit each new connection to a `ConnectionHandler` for processing.
    * Graceful shutdown on `SIGINT`/`SIGTERM`.
* **Key Data:** `port: Int`, `documentRoot: Path`, `sqliteDbPath: Path`.
* **Dependencies:** `ServerSocket`, `ExecutorService`, `Toml` (from `toml4j`).

#### 4.2. `ConnectionHandler`
* **Purpose:** Handles a single client connection, reading the request, processing it, and writing the response.
* **Responsibilities:**
    * Read bytes from the client's `Socket` input stream.
    * Pass raw request bytes to `HttpRequestParser`.
    * Delegate request handling to `RequestHandler` based on the parsed request.
    * Write `HttpResponse` bytes back to the client's `Socket` output stream.
    * Manage KeepAlive: if `Connection: keep-alive` is present, keep the socket open for subsequent requests until a timeout or `Connection: close` is received.
    * Close the socket when done or on error.
* **Dependencies:** `Socket`, `HttpRequestParser`, `RequestHandler`.

#### 4.3. `HttpRequestParser`
* **Purpose:** Parses raw HTTP request bytes into a structured `HttpRequest` object.
* **Responsibilities:**
    * Read request line (Method, URI, HTTP Version).
    * Read HTTP headers.
    * Handle potential malformed requests.
    * No body parsing needed as only GET/HEAD are supported.
* **Output:** `HttpRequest` data class (or similar).
* **Dependencies:** None.

#### 4.4. `RequestHandler` (Service Layer)
* **Purpose:** Orchestrates the processing of a valid `HttpRequest` and generates an `HttpResponse`. This acts as the main routing and logic hub.
* **Responsibilities:**
    * Determine if the request is for a static file or database content.
    * Delegate to `StaticFileHandler` or `DatabaseContentHandler`.
    * Generate appropriate HTTP error responses (404, 500, 501, 503) based on the outcome of the handlers.
    * Set appropriate `Content-Type` headers using `MimeTypeResolver`.
    * Handle `HEAD` requests by returning headers only.
* **Dependencies:** `StaticFileHandler`, `DatabaseContentHandler`, `MimeTypeResolver`.

#### 4.5. `StaticFileHandler`
* **Purpose:** Retrieves file content from the configured `documentRoot`.
* **Responsibilities:**
    * Construct the absolute file path from the request URI and `documentRoot`.
    * Check if the file exists and is readable.
    * Prevent directory traversal attacks (e.g., `../`).
    * Read file bytes and provide them for the response.
* **Output:** `ByteArray` (file content) or `null` if not found/accessible.
* **Dependencies:** `java.nio.file.Files`.

#### 4.6. `DatabaseContentHandler`
* **Purpose:** Retrieves content from the SQLite3 database based on the provided schema.
* **Responsibilities:**
    * Establish and manage a connection to the SQLite database.
    * **Mapping Strategy:**
        * Requests to paths that do not map to static files will be interpreted as requests for content from the `Content` table.
        * The **`path` column in the `Content` table** will be used to match the request URI.
        * The **`contentTypeID` column will be used to look up the `value` in the `ContentTypes` table** to determine the `Content-Type` header.
        * The `content` column will provide the raw bytes for the response.
        * **No explicit language filtering** will be implemented for the initial release; if multiple entries share a `path` but differ by `languageID`, the server will retrieve the first one found (e.g., `ORDER BY id LIMIT 1`).
        * The `compression` column in `ContentTypes` is vital to honor. Brotli is the only algorithm used so far. All plain text file types and similar are compressed. SVG images are also compressed with Brotli.
    * Retrieve `content` (as `ByteArray`) and `contentType.value` (as `String` for MIME type) from the database.
* **Output:** `Pair<ByteArray, String>` (content and MIME type) or `null` if not found.
* **Dependencies:** `java.sql.Connection`, `org.xerial.sqlite-jdbc`.

#### 4.7. `HttpResponseBuilder`
* **Purpose:** Constructs raw HTTP response bytes from a structured `HttpResponse` object.
* **Responsibilities:**
    * Format Status Line (HTTP Version, Status Code, Reason Phrase).
    * Format HTTP headers (e.g., `Content-Length`, `Content-Type`, `Connection`).
    * Append response body.
* **Input:** `HttpResponse` data class.
* **Output:** `ByteArray`.
* **Dependencies:** None.

#### 4.8. `MimeTypeResolver`
* **Purpose:** Determines the MIME type of a file or content based on its extension or context.
* **Responsibilities:**
    * Provide a lookup table for common file extensions (e.g., `.html` -> `text/html`, `.css` -> `text/css`, `.jpg` -> `image/jpeg`).
    * Provide a default MIME type (`application/octet-stream`) if the type cannot be determined.
    * **This resolver will be primarily used for static files.** For database content, the `mime_type` will come directly from the `ContentTypes` table.
* **Dependencies:** None.

---

### 5. Data Structures

* **`HttpRequest` (data class):**
    ```kotlin
    data class HttpRequest(
        val method: String,
        val uri: String,
        val httpVersion: String,
        val headers: Map<String, String>,
        val body: ByteArray? = null // Will be null for GET/HEAD
    )
    ```
* **`HttpResponse` (data class):**
    ```kotlin
    data class HttpResponse(
        val statusCode: Int,
        val reasonPhrase: String,
        val headers: Map<String, String>,
        val body: ByteArray? = null
    )
    ```
* **`ServerConfig` (data class):**
    ```kotlin
    import java.nio.file.Path

    data class ServerConfig(
        val port: Int = 8080,
        val documentRoot: Path,
        val sqliteDbPath: Path
    )
    ```

---

### 6. Error Handling Strategy

* Custom exceptions will be used internally (e.g., `BadRequestException`, `ResourceNotFoundException`).
* The `RequestHandler` will catch these exceptions and translate them into appropriate `HttpResponse` objects with the correct status codes (400, 404, 500, 501, 503).
* Generic `Exception` will be caught at the `ConnectionHandler` or `RequestHandler` level and mapped to a `500 Internal Server Error`.
* Error pages will be simple HTML strings generated on the fly (e.g., `<h1>404 Not Found</h1>`).

---

### 7. Core Logic & Flow

1.  **Server Startup:**
    * Determine configuration file path: By default, look for `config.toml` in the current working directory. Allow an optional command-line argument (e.g., `--config <path>`) to specify an alternative path.
    * **Load Configuration:** Use `toml4j` to parse the TOML file into a `ServerConfig` object. If the file is missing or malformed, provide sensible defaults or terminate with an error.
    * Initialize a `ServerSocket` on `localhost` and the configured port.
    * Initialize an `ExecutorService` (e.g., `Executors.newFixedThreadPool`).
    * Initialize `SQLiteConnectionPool` (or single connection if usage is low).

2.  **Connection Acceptance Loop:**
    * `ServerSocket.accept()` blocks until a new client connects.
    * When a connection is accepted, create a `Socket`.
    * Submit a `ConnectionHandler` task to the `ExecutorService`, passing the `Socket`.

3.  **`ConnectionHandler` Flow:**
    * Read input stream for raw HTTP request.
    * Loop for KeepAlive:
        * Call `HttpRequestParser.parse()` to get `HttpRequest`.
        * Call `RequestHandler.handle()` to get `HttpResponse`.
        * Call `HttpResponseBuilder.build()` to get raw response bytes.
        * Write raw response bytes to output stream.
        * Check `Connection` header and client timeout for KeepAlive.
    * Close the `Socket`.

4.  **`RequestHandler` Flow:**
    * Validate HTTP Method (only GET/HEAD allowed). If not, return 501.
    * Cleanse/normalize URI (e.g., remove query parameters, leading/trailing slashes for consistent path matching).
    * **Precedence Check:**
        * **Try to find a static file:** `documentRoot` + normalized URI. If found, return `HttpResponse` with file content.
        * If not found, **try to find content in SQLite DB:**
            * Execute a query on the `Content` table using the normalized URI as the `path`.
            * Example query (simplified for illustration, will join `ContentTypes`):
                ```sql
                SELECT c.content, ct.value AS mime_type
                FROM Content c
                JOIN ContentTypes ct ON c.contentTypeID = ct.id
                WHERE c.path = ?
                LIMIT 1;
                ```
            * If content is found, return `HttpResponse` with DB content and its corresponding MIME type.
        * If neither found, return `404 Not Found`.
    * If any internal error occurs (e.g., `IOException` for file, `SQLException` for DB), return `500 Internal Server Error`.
    * For `HEAD` requests, set `Content-Length` but no body.

---

### 8. Directory Traversal Protection

The `StaticFileHandler` will implement robust directory traversal protection:
* Normalize the requested URI path (e.g., `Paths.normalize`).
* Resolve the absolute path: `documentRoot.resolve(normalizedUriPath)`.
* **Crucially:** Verify that the resolved absolute path **starts with** the `documentRoot` path. If it does not, it indicates an attempt to access files outside the allowed directory, and a `404 Not Found` (or `403 Forbidden` if desired) should be returned.

```kotlin
// Example snippet in StaticFileHandler
val requestedPath = Paths.get(uri).normalize() // e.g., /foo/../bar -> /bar
val absoluteFilePath = config.documentRoot.resolve(requestedPath).normalize()

if (!absoluteFilePath.startsWith(config.documentRoot) || !Files.exists(absoluteFilePath)) {
    // Return 404 or 403
    return null
}
```

---

### 9. Configuration Management (TOML Specifics)

* **Configuration File Name:** `config.toml` (default)
* **Example `config.toml`:**
    ```toml
    # Server settings
    [server]
    port = 8080
    document_root = "webroot"  # Relative path to the directory containing static files
    sqlite_db_path = "data/content.db" # Relative path to the SQLite database file
    ```
* **Loading Logic (`WebServer`):**
    ```kotlin
    import com.moandjiezana.toml.Toml
    import java.io.File
    import java.nio.file.Path
    import java.nio.file.Paths

    fun loadConfig(configFilePath: String?): ServerConfig {
        val configFile = configFilePath?.let { File(it) } ?: File("config.toml")

        if (!configFile.exists()) {
            println("Warning: config.toml not found at ${configFile.absolutePath}. Using default values where possible.")
            // Provide sensible defaults or throw an error if critical paths are missing
            // For simplicity, we'll try to use relative paths from current working dir
            return ServerConfig(
                port = 8080,
                documentRoot = Paths.get("webroot").toAbsolutePath(), // Default to ./webroot
                sqliteDbPath = Paths.get("data/content.db").toAbsolutePath() // Default to ./data/content.db
            )
        }

        val toml = Toml().read(configFile)

        val port = toml.getLong("server.port")?.toInt() ?: 8080
        val documentRootStr = toml.getString("server.document_root") ?: "webroot"
        val sqliteDbPathStr = toml.getString("server.sqlite_db_path") ?: "data/content.db"

        // Resolve paths relative to the config file's parent directory or current working directory
        val baseDir = configFile.parentFile?.toPath() ?: Paths.get("")
        val documentRoot = baseDir.resolve(documentRootStr).normalize().toAbsolutePath()
        val sqliteDbPath = baseDir.resolve(sqliteDbPathStr).normalize().toAbsolutePath()

        return ServerConfig(port, documentRoot, sqliteDbPath)
    }

    // In main function:
    // val configFilePath = args.find { it.startsWith("--config=") }?.substringAfter("=")
    // val config = loadConfig(configFilePath)
    ```
* **Command-line Overrides:** Command-line arguments will take precedence over TOML values. E.g., `--port 9000` will override `port` from `config.toml`. The `WebServer` class will need logic to parse these arguments after loading the TOML config.

---

### 10. Database Schema (SQLite3)

The following schema will be used for content storage. The `DatabaseContentHandler` will query the `Content` and `ContentTypes` tables. The `Languages` and `ide_tooltip_table` will be ignored for the scope of this web server's primary function of serving content.

```sql
CREATE TABLE IF NOT EXISTS Content (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT NOT NULL,
    languageID INTEGER NOT NULL,
    content BLOB NOT NULL,
    contentTypeID INTEGER NOT NULL,
    FOREIGN KEY (languageID) REFERENCES Languages(id),
    FOREIGN KEY (contentTypeID) REFERENCES ContentTypes(id)
);
CREATE TABLE IF NOT EXISTS Languages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    value TEXT NOT NULL UNIQUE
);
CREATE TABLE IF NOT EXISTS ContentTypes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    value TEXT NOT NULL UNIQUE,
    compression TEXT NOT NULL
);
CREATE TABLE IF NOT EXISTS ide_tooltip_table (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT NOT NULL,
    languageID INTEGER NOT NULL,
    content TEXT NOT NULL,
    FOREIGN KEY (languageID) REFERENCES Languages(id)
);
```
**Key points for interaction with this schema:**
* **Content Retrieval:** The primary query will target the `Content` table, joining with `ContentTypes` to get the MIME type.
* **Path Mapping:** The `path` column in the `Content` table will directly map to the incoming HTTP request URI (after normalization).
* **MIME Type:** The `value` column from the `ContentTypes` table (aliased as `mime_type` in the example query) will be used for the `Content-Type` HTTP header.
* **Language ID:** The `languageID` column will be present in the query result but will not be used to filter or select content in the initial implementation. If multiple entries have the same `path` but different `languageID`s, the server will pick the first one returned by the database (e.g., `LIMIT 1`).

---

### 11. Testing Considerations

* **Unit Tests:** For `HttpRequestParser`, `HttpResponseBuilder`, `MimeTypeResolver`, `StaticFileHandler` (especially path validation), `DatabaseContentHandler` (including its interaction with the new schema), and `ConfigLoader` (for TOML parsing and defaults).
* **Integration Tests:** Start the server, make HTTP requests (using `HttpClient`), and verify responses (status codes, headers, body content). Test with different `config.toml` files. Ensure both static files and database content are served correctly. Test database content with various `path` values and `contentTypeID` mappings.
* **Manual Testing:** Use a web browser or `curl` to test various scenarios (valid files, missing files, database content, error pages, KeepAlive).

---

### 12. Deployment Considerations

* The server will be packaged as a single executable JAR file (`.jar`) using the Kotlin JVM compiler.
* Requires OpenJDK17 or compatible JVM to be installed on the target machine.
* The `config.toml` file should be placed in the same directory as the JAR or specified via a command-line argument.
* Startup script (e.g., `start.sh`) for convenience:
    ```bash
    #!/bin/bash
    java -jar simple-web-server.jar --config ./config.toml
    ```

---

### 13. Open Questions / Further Refinements

* **Logging:** Basic logging (e.g., using `java.util.logging` or `slf4j` + `logback`) should be added to report requests, errors, and server status.
* **Concurrency Model:** While a simple `ExecutorService` is chosen for simplicity, consider if a more advanced non-blocking I/O (NIO) approach would be beneficial for future scalability, though it adds significant complexity for a "simple" server.
* **KeepAlive Timeout:** Implement a configurable timeout for KeepAlive connections to prevent idle connections from consuming resources indefinitely (add to `config.toml`).
* **MIME Type Resolution for Static Files:** Expand `MimeTypeResolver` to cover a wider range of common types.
* **Database Content Language Handling:** If language-specific content is ever needed, the `languageID` column would need to be incorporated into the URL mapping (e.g., `/en/my-path`) and query logic. This is out of scope for the initial release but a known extension point.
* **Database Content Compression:** The `compression` column in `ContentTypes` is important. When compressed content is stored, decompression logic is needed to be added to `DatabaseContentHandler`.

---

This detailed EDD now clearly outlines how the server will function with your existing SQLite schema. Do you have any specific concerns about the database interaction, or perhaps thoughts on initial setup for the database (e.g., populating test data)?

