Directory structure:
└── main/
    ├── AndroidManifest.xml
    ├── java/
    │   └── com/
    │       └── itsaky/
    │           └── androidide/
    │               ├── actions/
    │               │   ├── BaseBuildAction.kt
    │               │   ├── BaseEditorAction.kt
    │               │   ├── EditorActivityAction.kt
    │               │   ├── EditorRelatedAction.kt
    │               │   ├── internalActionUtils.kt
    │               │   ├── build/
    │               │   │   ├── AbstractCancellableRunAction.kt
    │               │   │   ├── AbstractModuleAssemblerAction.kt
    │               │   │   ├── AbstractRunAction.kt
    │               │   │   ├── DebugAction.kt
    │               │   │   ├── ProjectSyncAction.kt
    │               │   │   ├── QuickRunAction.kt
    │               │   │   └── RunTasksAction.kt
    │               │   ├── debug/
    │               │   │   ├── AbstractDebuggerAction.kt
    │               │   │   ├── AbstractStepAction.kt
    │               │   │   ├── KillVmAction.kt
    │               │   │   ├── RestartVmAction.kt
    │               │   │   ├── StepIntoAction.kt
    │               │   │   ├── StepOutAction.kt
    │               │   │   ├── StepOverAction.kt
    │               │   │   └── SuspendResumeVmAction.kt
    │               │   ├── editor/
    │               │   │   ├── CopyAction.kt
    │               │   │   ├── CutAction.kt
    │               │   │   ├── ExpandSelectionAction.kt
    │               │   │   ├── LongSelectAction.kt
    │               │   │   ├── PasteAction.kt
    │               │   │   └── SelectAllAction.kt
    │               │   ├── etc/
    │               │   │   ├── DisconnectLogSendersAction.kt
    │               │   │   ├── FindActionMenu.kt
    │               │   │   ├── FindInFileAction.kt
    │               │   │   ├── FindInProjectAction.kt
    │               │   │   ├── LaunchAppAction.kt
    │               │   │   └── PreviewLayoutAction.kt
    │               │   ├── file/
    │               │   │   ├── CloseAllFilesAction.kt
    │               │   │   ├── CloseFileAction.kt
    │               │   │   ├── CloseOtherFilesAction.kt
    │               │   │   ├── FileTabAction.kt
    │               │   │   ├── FormatCodeAction.kt
    │               │   │   ├── SaveFileAction.kt
    │               │   │   └── ShowTooltipAction.kt
    │               │   ├── filetree/
    │               │   │   ├── BaseDirNodeAction.kt
    │               │   │   ├── BaseFileTreeAction.kt
    │               │   │   ├── CopyPathAction.kt
    │               │   │   ├── DeleteAction.kt
    │               │   │   ├── HelpAction.kt
    │               │   │   ├── NewFileAction.kt
    │               │   │   ├── NewFolderAction.kt
    │               │   │   ├── OpenWithAction.kt
    │               │   │   └── RenameAction.kt
    │               │   ├── github/
    │               │   │   ├── GitHubCommitAction.kt
    │               │   │   ├── GitHubFetchAction.kt
    │               │   │   ├── GitHubPullAction.kt
    │               │   │   └── GitHubPushAction.kt
    │               │   ├── sidebar/
    │               │   │   ├── AbstractSidebarAction.kt
    │               │   │   ├── BuildVariantsSidebarAction.kt
    │               │   │   ├── CloseProjectSidebarAction.kt
    │               │   │   ├── EmailSideBarAction.kt
    │               │   │   ├── FileTreeSidebarAction.kt
    │               │   │   ├── GitSidebarAction.kt
    │               │   │   ├── HelpSideBarAction.kt
    │               │   │   ├── PreferencesSidebarAction.kt
    │               │   │   └── TerminalSidebarAction.kt
    │               │   └── text/
    │               │       ├── RedoAction.kt
    │               │       └── UndoAction.kt
    │               ├── activities/
    │               │   ├── AboutActivity.kt
    │               │   ├── ContributorsActivity.kt
    │               │   ├── CrashHandlerActivity.java
    │               │   ├── MainActivity.kt
    │               │   ├── OnboardingActivity.kt
    │               │   ├── PreferencesActivity.kt
    │               │   ├── SecondaryScreen.kt
    │               │   ├── SplashActivity.kt
    │               │   └── editor/
    │               │       ├── BaseEditorActivity.kt
    │               │       ├── EditorActivityKt.kt
    │               │       ├── EditorHandlerActivity.kt
    │               │       ├── FAQActivity.kt
    │               │       ├── IDELogcatReader.kt
    │               │       └── ProjectHandlerActivity.kt
    │               ├── adapters/
    │               │   ├── BuildVariantsAdapter.kt
    │               │   ├── ContributorsGridAdapter.kt
    │               │   ├── DeleteProjectListAdapter.kt
    │               │   ├── DiagnosticItemAdapter.java
    │               │   ├── DiagnosticsAdapter.java
    │               │   ├── EditorBottomSheetTabAdapter.java
    │               │   ├── FilterableRecyclerViewAdapter.kt
    │               │   ├── MainActionsListAdapter.kt
    │               │   ├── OptionsSheetAdapter.java
    │               │   ├── RecentProjectsAdapter.kt
    │               │   ├── RunTasksListAdapter.kt
    │               │   ├── SearchListAdapter.kt
    │               │   ├── SymbolInputAdapter.java
    │               │   ├── TemplateListAdapter.kt
    │               │   ├── TemplateWidgetsListAdapter.kt
    │               │   ├── onboarding/
    │               │   │   ├── DefaultOnboardingItemAdapter.kt
    │               │   │   └── OnboardingPermissionsAdapter.kt
    │               │   └── viewholders/
    │               │       └── FileTreeViewHolder.java
    │               ├── app/
    │               │   ├── EdgeToEdgeIDEActivity.kt
    │               │   ├── IDEActivity.kt
    │               │   ├── IDEActivityDelegate.kt
    │               │   ├── IDEApplication.kt
    │               │   ├── LlmInferenceEngine.kt
    │               │   └── configuration/
    │               │       ├── IDEBuildConfigProviderImpl.kt
    │               │       └── JdkDistributionProviderImpl.kt
    │               ├── contributors/
    │               │   ├── Contributor.kt
    │               │   ├── Contributors.kt
    │               │   ├── CrowdinTranslator.kt
    │               │   ├── GitHubContributors.kt
    │               │   └── common.kt
    │               ├── events/
    │               │   ├── FileTree.kt
    │               │   └── InstallationResultEvent.kt
    │               ├── fragments/
    │               │   ├── BasePreferenceFragment.kt
    │               │   ├── CrashReportFragment.kt
    │               │   ├── DeleteProjectFragment.kt
    │               │   ├── DiagnosticsListFragment.kt
    │               │   ├── EmptyStateFragment.kt
    │               │   ├── IDEPreferencesFragment.kt
    │               │   ├── IDETooltipWebViewFragment.kt
    │               │   ├── MainFragment.kt
    │               │   ├── RecentProjectsFragment.kt
    │               │   ├── RecyclerViewFragment.kt
    │               │   ├── RunTasksDialogFragment.kt
    │               │   ├── SearchResultFragment.kt
    │               │   ├── TemplateDetailsFragment.kt
    │               │   ├── TemplateListFragment.kt
    │               │   ├── .DS_Store
    │               │   ├── debug/
    │               │   │   ├── CallStackFragment.kt
    │               │   │   ├── DebuggerFragment.kt
    │               │   │   ├── DisplayableUtils.kt
    │               │   │   ├── Resolvable.kt
    │               │   │   ├── VariableIcon.kt
    │               │   │   ├── VariableListBinder.kt
    │               │   │   ├── VariableListFragment.kt
    │               │   │   └── VariableTreeNodeGenerator.kt
    │               │   ├── onboarding/
    │               │   │   ├── GreetingFragment.kt
    │               │   │   ├── IdeSetupConfigurationFragment.kt
    │               │   │   ├── OnboardingFragment.kt
    │               │   │   ├── OnboardingInfoFragment.kt
    │               │   │   ├── OnboardingMultiActionFragment.kt
    │               │   │   ├── PermissionsFragment.kt
    │               │   │   ├── StatisticsFragment.kt
    │               │   │   └── ideSetupConfig.kt
    │               │   ├── output/
    │               │   │   ├── AppLogFragment.kt
    │               │   │   ├── BuildOutputFragment.kt
    │               │   │   ├── IDELogFragment.kt
    │               │   │   ├── LogViewFragment.kt
    │               │   │   ├── NonEditableEditorFragment.java
    │               │   │   └── ShareableOutputFragment.kt
    │               │   ├── sheets/
    │               │   │   ├── BaseBottomSheetFragment.java
    │               │   │   ├── OptionsListFragment.java
    │               │   │   └── ProgressSheet.java
    │               │   └── sidebar/
    │               │       ├── BuildVariantsFragment.kt
    │               │       ├── EditorSidebarFragment.kt
    │               │       ├── FileTreeFragment.kt
    │               │       ├── GitCommitDetailFragment.kt
    │               │       ├── GitCommitFragment.kt
    │               │       ├── GitEditRemoteFragment.kt
    │               │       ├── GitFileStatus.kt
    │               │       ├── GitFragment.kt
    │               │       ├── GitFragmentContainer.kt
    │               │       ├── GitGraphItemDecoration.kt
    │               │       ├── GitHistoryAdapter.kt
    │               │       ├── GitHistoryFragment.kt
    │               │       ├── GitRemote.kt
    │               │       ├── GitRemotesListFragment.kt
    │               │       ├── GitStatusAdapter.kt
    │               │       └── RemotesAdapter.kt
    │               ├── git/
    │               │   ├── GitCommitTask.kt
    │               │   ├── GitFetchTask.kt
    │               │   ├── GitInitTask.kt
    │               │   ├── GitProgressMonitor.kt
    │               │   ├── GitPullTask.kt
    │               │   └── GitPushTask.kt
    │               ├── handlers/
    │               │   ├── BaseEventHandler.kt
    │               │   ├── EditorActivityLifecyclerObserver.kt
    │               │   ├── EditorBuildEventListener.kt
    │               │   ├── FileTreeActionHandler.kt
    │               │   └── LspHandler.kt
    │               ├── interfaces/
    │               │   ├── DiagnosticClickListener.java
    │               │   └── IEditorHandler.kt
    │               ├── localWebServer/
    │               │   └── WebServer.kt
    │               ├── logging/
    │               │   ├── IDELoggingConfigurator.kt
    │               │   └── LifecycleAwareAppender.kt
    │               ├── lsp/
    │               │   ├── BreakpointHandler.kt
    │               │   ├── IDEDebugClientImpl.kt
    │               │   └── IDELanguageClientImpl.java
    │               ├── models/
    │               │   ├── ApkMetadata.kt
    │               │   ├── ArtifactType.kt
    │               │   ├── Checkable.kt
    │               │   ├── DefaultOnboardingItem.kt
    │               │   ├── DiagnosticGroup.java
    │               │   ├── FileExtension.kt
    │               │   ├── HyperlinkedOnboardingItem.kt
    │               │   ├── IdeSetupArguments.kt
    │               │   ├── MainScreenAction.kt
    │               │   ├── MetadataElement.kt
    │               │   ├── NewProjectDetails.java
    │               │   ├── OnboardingItem.kt
    │               │   ├── OnboardingPermissionItem.kt
    │               │   ├── OpenedFile.kt
    │               │   ├── OpenedFilesCache.kt
    │               │   ├── ProjectTemplate.java
    │               │   ├── RunTasksCategory.kt
    │               │   ├── SearchResult.java
    │               │   └── Symbol.kt
    │               ├── preferences/
    │               │   ├── GitHubPreferences.kt
    │               │   ├── aboutPrefExts.kt
    │               │   ├── buildAndRunPrefExts.kt
    │               │   ├── commonPrefExts.kt
    │               │   ├── developerOptionsPrefExts.kt
    │               │   ├── editorPrefExts.kt
    │               │   ├── generalPrefExts.kt
    │               │   ├── javaPrefExts.kt
    │               │   ├── rootPrefExts.kt
    │               │   ├── statPrefExts.kt
    │               │   ├── termuxPrefsExt.kt
    │               │   └── xmlPrefExts.kt
    │               ├── provider/
    │               │   ├── IDEDocumentsProvider.java
    │               │   └── IDEFileProvider.kt
    │               ├── roomData/
    │               │   └── recentproject/
    │               │       ├── RecentProject.kt
    │               │       ├── RecentProjectDao.kt
    │               │       └── RecentProjectRoomDatabase.kt
    │               ├── services/
    │               │   ├── InstallationResultReceiver.kt
    │               │   ├── ToolingServerAlreadyStartedException.java
    │               │   ├── ToolingServerNotStartedException.java
    │               │   ├── builder/
    │               │   │   ├── BuildInProgressException.java
    │               │   │   ├── GradleBuildService.kt
    │               │   │   ├── GradleBuildServiceConnnection.kt
    │               │   │   ├── GradleServiceBinder.kt
    │               │   │   ├── ToolingServerRunner.kt
    │               │   │   └── util.kt
    │               │   ├── debug/
    │               │   │   ├── DebugOverlayManager.kt
    │               │   │   ├── DebuggerActionsOverlayAdapter.kt
    │               │   │   ├── DebuggerService.kt
    │               │   │   ├── DebuggerStatusProvider.kt
    │               │   │   └── ForegroundDetectorService.kt
    │               │   └── log/
    │               │       ├── CachingLogSender.kt
    │               │       ├── ConnectionObserverParams.kt
    │               │       ├── LogReceiverImpl.kt
    │               │       ├── LogReceiverService.kt
    │               │       ├── LogReceiverServiceConnection.kt
    │               │       ├── LogSenderHandler.kt
    │               │       ├── LogSendersRegistry.kt
    │               │       ├── MultiLogSenderHandler.kt
    │               │       └── utils.kt
    │               ├── tasks/
    │               │   └── callables/
    │               │       ├── FileTreeCallable.java
    │               │       ├── ListDirectoryCallable.java
    │               │       └── UnzipCallable.java
    │               ├── ui/
    │               │   ├── CodeEditorView.kt
    │               │   ├── ContributorsRecyclerView.kt
    │               │   ├── CustomDividerItemDecoration.kt
    │               │   ├── CustomSnackbar.kt
    │               │   ├── EditorBottomSheet.kt
    │               │   ├── EmptyView.java
    │               │   ├── ScalableTabLayout.kt
    │               │   ├── SwipeRevealLayout.kt
    │               │   ├── SymbolInputView.java
    │               │   ├── themes/
    │               │   │   └── ThemeManager.kt
    │               │   └── transition/
    │               │       ├── ArcMotionPlus.java
    │               │       ├── CubicBezierArc.java
    │               │       └── ProgressTransition.java
    │               ├── utils/
    │               │   ├── ActionMenuUtils.kt
    │               │   ├── ApkInstallationSessionCallback.kt
    │               │   ├── AssetsInstallationHelper.kt
    │               │   ├── BuildInfoUtils.kt
    │               │   ├── ClassBuilder.kt
    │               │   ├── EditorActivityActions.kt
    │               │   ├── EditorSidebarActions.kt
    │               │   ├── FlexboxUtils.kt
    │               │   ├── InstallationResultHandler.kt
    │               │   ├── IntentUtils.kt
    │               │   ├── JSONUtility.java
    │               │   ├── JdkUtils.kt
    │               │   ├── ListingFileRedirect.kt
    │               │   ├── MemoryUsageWatcher.kt
    │               │   ├── MutableShiftedLongArray.kt
    │               │   ├── NoOpServiceConnection.kt
    │               │   ├── ProjectWriter.java
    │               │   ├── RecursiveFileSearcher.java
    │               │   ├── ShiftedLongArray.kt
    │               │   ├── SingleBottomSheetCallback.kt
    │               │   ├── Symbols.kt
    │               │   ├── TemplateRecipeExecutor.kt
    │               │   ├── TerminalInstaller.kt
    │               │   ├── TextWatcherAdapter.java
    │               │   ├── TooltipUtils.kt
    │               │   └── ZipExts.kt
    │               └── viewmodel/
    │                   ├── BuildVariantsViewModel.kt
    │                   ├── ContributorsViewModel.kt
    │                   ├── DebuggerViewModel.kt
    │                   ├── EditorViewModel.kt
    │                   ├── EmptyStateFragmentViewModel.kt
    │                   ├── FileTreeViewModel.kt
    │                   ├── GitViewModel.kt
    │                   ├── MainViewModel.kt
    │                   ├── RecentProjectsViewModel.kt
    │                   └── RunTasksViewModel.kt
    ├── jniLibs/
    │   ├── arm64-v8a/
    │   └── armeabi-v7a/
    └── res/
        ├── resources.properties
        ├── drawable/
        │   ├── bg_outline.xml
        │   └── snackbar_custom_background.xml
        ├── menu/
        │   ├── ctx_menu.xml
        │   └── menu_recent_projects.xml
        ├── navigation/
        │   └── git_nav_graph.xml
        ├── raw/
        ├── values/
        │   ├── arrays.xml
        │   ├── bools.xml
        │   ├── colors.xml
        │   ├── dimens.xml
        │   ├── strings.xml
        │   └── styles.xml
        └── xml/
            ├── debugger_accessibility_service_config.xml
            ├── ide_file_provider_paths.xml
            ├── ide_prefs.xml
            └── network_security_config.xml

================================================
File: AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:installLocation="internalOnly"
    tools:ignore="Instantiatable">

    <permission
        android:name="com.itsaky.androidide.permission.BIND_LOG_SERVICE"
        android:description="@string/permdesc_bind_logger_service"
        android:label="@string/permlab_bind_logger_service"
        android:protectionLevel="normal"
        tools:ignore="ManifestOrder" />

    <permission
        android:name="org.adfa.cogo.permission.RECEIVE_FOREGROUND_WINDOW_UPDATES"
        android:protectionLevel="signature" />

    <permission
        android:name="org.adfa.cogo.debugger.DEBUGGER"
        android:protectionLevel="normal" />

    <uses-permission android:name="com.itsaky.androidide.permission.BIND_LOG_SERVICE" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission
        android:name="android.permission.MANAGE_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
    <uses-permission android:name="android.permission.REQUEST_DELETE_PACKAGES" />

    <uses-permission android:name="org.adfa.cogo.permission.RECEIVE_FOREGROUND_WINDOW_UPDATES" />
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />

    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <application
        android:name=".app.IDEApplication"
        android:allowBackup="false"
        android:allowNativeHeapPointerTagging="false"
        android:enableOnBackInvokedCallback="true"
        android:extractNativeLibs="true"
        android:hardwareAccelerated="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:largeHeap="true"
        android:networkSecurityConfig="@xml/network_security_config"
        android:preserveLegacyExternalStorage="true"
        android:requestLegacyExternalStorage="true"
        android:resizeableActivity="false"
        android:supportsRtl="true"
        android:theme="@style/Theme.AndroidIDE"
        android:usesCleartextTraffic="true"
        tools:ignore="DiscouragedApi,MediaCapabilities,UnusedAttribute"
        tools:replace="android:icon,android:name,android:allowBackup, android:supportsRtl, android:theme">
        <activity
            android:name=".activities.CrashHandlerActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:exported="true"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor"
            android:windowSoftInputMode="stateAlwaysHidden">
            <intent-filter>
                <action android:name="com.itsaky.androidide.REPORT_CRASH" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>

        <activity
            android:name=".activities.SplashActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:exported="true"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor"
            android:theme="@style/AppTheme.Splash">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name=".activities.OnboardingActivity"
            android:exported="false" />
        <activity
            android:name=".activities.MainActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:exported="false"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor"
            android:theme="@style/Theme.AndroidIDE" />
        <activity
            android:name=".activities.editor.EditorActivityKt"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:launchMode="singleTop"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor" />
        <activity
            android:name=".activities.PreferencesActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor" />
        <activity
            android:name=".activities.AboutActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor" />
        <activity
            android:name=".activities.editor.FAQActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor" />
        <activity
            android:name=".activities.editor.HelpActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor" />
        <activity
            android:name=".activities.ContributorsActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor" />
        <activity
            android:name=".activities.TerminalActivity"
            android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboardHidden"
            android:resizeableActivity="true"
            android:screenOrientation="fullSensor"
            android:windowSoftInputMode="adjustResize" />

        <!--    &lt;!&ndash; Required: set your sentry.io project identifier (DSN) &ndash;&gt;-->
        <!--    <meta-data android:name="io.sentry.dsn" android:value="https://e27b85ad9ff58221029395291bf1617c@o4508003514712064.ingest.us.sentry.io/4508003516940288" />-->

        <!--    &lt;!&ndash; enable automatic breadcrumbs for user interactions (clicks, swipes, scrolls) &ndash;&gt;-->
        <!--    <meta-data android:name="io.sentry.traces.user-interaction.enable" android:value="true" />-->
        <!--    &lt;!&ndash; enable screenshot for crashes &ndash;&gt;-->
        <!--    <meta-data android:name="io.sentry.attach-screenshot" android:value="true" />-->
        <!--    &lt;!&ndash; enable view hierarchy for crashes &ndash;&gt;-->
        <!--    <meta-data android:name="io.sentry.attach-view-hierarchy" android:value="true" />-->

        <!--    &lt;!&ndash; enable the performance API by setting a sample-rate, adjust in production env &ndash;&gt;-->
        <!--    <meta-data android:name="io.sentry.traces.sample-rate" android:value="1.0" />-->
        <!--    &lt;!&ndash; enable profiling when starting transactions, adjust in production env &ndash;&gt;-->
        <!--    <meta-data android:name="io.sentry.traces.profiling.sample-rate" android:value="1.0" />-->

        <provider
            android:name=".provider.IDEDocumentsProvider"
            android:authorities="com.itsaky.androidide.documents"
            android:exported="true"
            android:grantUriPermissions="true"
            android:permission="android.permission.MANAGE_DOCUMENTS">
            <intent-filter>
                <action android:name="android.content.action.DOCUMENTS_PROVIDER" />
            </intent-filter>
        </provider>

        <provider
            android:name=".provider.IDEFileProvider"
            android:authorities="${applicationId}.providers.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/ide_file_provider_paths" />
        </provider>

        <provider
            android:name=".services.debug.DebuggerStatusProvider"
            android:authorities="org.adfa.cogo.debugger"
            android:exported="true"
            android:grantUriPermissions="false"
            android:permission="org.adfa.cogo.debugger.DEBUGGER" />

        <receiver
            android:name=".services.InstallationResultReceiver"
            android:enabled="true"
            android:exported="true"
            tools:ignore="ExportedReceiver">
            <intent-filter>
                <action android:name="com.itsaky.androidide.installer.INSTALL_PACKAGE" />
            </intent-filter>
        </receiver>

        <service
            android:name=".services.builder.GradleBuildService"
            android:exported="false" />

        <service
            android:name=".services.debug.DebuggerService"
            android:exported="false" />

        <service
            android:name=".services.debug.ForegroundDetectionService"
            android:exported="true"
            android:label="@string/app_name"
            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE">
            <intent-filter>
                <action android:name="android.accessibilityservice.AccessibilityService" />
            </intent-filter>

            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/debugger_accessibility_service_config" />
        </service>

        <service
            android:name=".services.log.LogReceiverService"
            android:exported="true"
            android:permission="com.itsaky.androidide.permission.BIND_LOG_SERVICE">
            <intent-filter>
                <action android:name="com.itsaky.androidide.LOG_SERVICE_ACTION" />
            </intent-filter>
        </service>
        <service
            android:name="androidx.appcompat.app.AppLocalesMetadataHolderService"
            android:enabled="false"
            android:exported="false">
            <meta-data
                android:name="autoStoreLocales"
                android:value="true" />
        </service>
    </application>
</manifest>


================================================
File: java/com/itsaky/androidide/actions/BaseBuildAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions

import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.projects.builder.BuildService

/**
 * Marker class for actions that execute build related tasks.
 *
 * @author Akash Yadav
 */
abstract class BaseBuildAction : EditorActivityAction() {

  protected val buildService: BuildService?
    get() = Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE)

  override fun prepare(data: ActionData) {
    super.prepare(data)
    val context = data.getActivity()
    if (context == null) {
      visible = false
      return
    } else {
      visible = true
    }

    enabled = buildService?.let { !it.isBuildInProgress } == true
  }
}



================================================
File: java/com/itsaky/androidide/actions/BaseEditorAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.itsaky.androidide.editor.ui.IDEEditor

/** @author Akash Yadav */
abstract class BaseEditorAction : EditorActionItem {

  override var label: String = ""
  override var visible: Boolean = true
  override var enabled: Boolean = true
  override var icon: Drawable? = null
  override var requiresUIThread: Boolean = true // all editor actions must be executed on UI thread
  override var location: ActionItem.Location = ActionItem.Location.EDITOR_TEXT_ACTIONS

  override fun prepare(data: ActionData) {
    super.prepare(data)
    getEditor(data)
      ?: kotlin.run {
        visible = false
        enabled = false
        return
      }

    visible = true
    enabled = true
  }

  fun getEditor(data: ActionData): IDEEditor? {
    return data.get(IDEEditor::class.java)
  }

  fun getContext(data: ActionData): Context? {
    val editor = getEditor(data) ?: return null
    return editor.context
  }

  fun tintDrawable(context: Context, drawable: Drawable): Drawable {
    drawable.setTint(
      ContextCompat.getColor(context, com.itsaky.androidide.resources.R.color.primaryIconColor)
    )
    return drawable
  }
}



================================================
File: java/com/itsaky/androidide/actions/EditorActivityAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions

import android.content.Context
import android.graphics.drawable.Drawable
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.tasks.cancelIfActive
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.plus

/** @author Akash Yadav */
abstract class EditorActivityAction : ActionItem {

  override var enabled: Boolean = true
  override var visible: Boolean = true
  override var icon: Drawable? = null
  override var label: String = ""
  override var location: ActionItem.Location = ActionItem.Location.EDITOR_TOOLBAR

  override var requiresUIThread: Boolean = false

  protected val actionScope = CoroutineScope(Dispatchers.Default) +
      CoroutineName("${javaClass.simpleName}Scope")

  override fun prepare(data: ActionData) {
    super.prepare(data)
    if (!data.hasRequiredData(Context::class.java)) {
      markInvisible()
    }
  }

  fun ActionData.getActivity(): EditorHandlerActivity? {
    return this[Context::class.java] as? EditorHandlerActivity
  }

  fun ActionData.requireActivity(): EditorHandlerActivity {
    return getActivity()!!
  }

  override fun destroy() {
    super.destroy()
    actionScope.cancelIfActive("Action is being destroyed")
  }

}



================================================
File: java/com/itsaky/androidide/actions/EditorRelatedAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions

import com.itsaky.androidide.editor.ui.IDEEditor
import com.itsaky.androidide.ui.CodeEditorView

/** @author Akash Yadav */
abstract class EditorRelatedAction : EditorActivityAction(), EditorActionItem {

  override var requiresUIThread: Boolean = true

  override fun prepare(data: ActionData) {
    super<EditorActionItem>.prepare(data)
    super<EditorActivityAction>.prepare(data)
    val editor =
      data.getEditor()
        ?: run {
          visible = false
          enabled = false
          return
        }

    val file = editor.file

    visible = file != null
    enabled = visible
  }

  fun ActionData.getEditor(): IDEEditor? = get(IDEEditor::class.java)

  fun ActionData.getEditorView(): CodeEditorView? = get(CodeEditorView::class.java)

}



================================================
File: java/com/itsaky/androidide/actions/internalActionUtils.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *  
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions

import android.content.Context
import com.itsaky.androidide.R
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.projects.api.AndroidModule
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.ILogger
import com.itsaky.androidide.utils.flashError

/**
 * @see openApplicationModuleChooser
 */
inline fun openApplicationModuleChooser(data: ActionData,
  crossinline callback: (AndroidModule) -> Unit) =
  openApplicationModuleChooser(data.requireContext(), callback)

/**
 * Shows a dialog to let the user choose between Android application modules in case the project has
 * multiple subproject with `com.android.application` plugin. If the project contains only a single
 * application module, it is selected by default and the dialog is not shown to the user.
 *
 * @param
 */
inline fun openApplicationModuleChooser(context: Context,
  crossinline callback: (AndroidModule) -> Unit) {
  val projectManager = IProjectManager.getInstance()
  val applications = projectManager.getAndroidAppModules()
  if (applications.isEmpty()) {
    flashError(R.string.msg_launch_failure_no_app_module)
    ILogger.ROOT.error("Cannot run application. No application modules found in project.")
    return
  }

  if (applications.size == 1) {
    // Only one application module in available in the project.
    callback(applications.first())
    return
  }

  // there are multiple application modules in the project
  // ask the user to select the application module to build
  val builder = DialogUtils.newSingleChoiceDialog(
    context,
    context.getString(R.string.title_choose_application),
    applications.map { it.path }.toTypedArray(),
    0) { selection ->
    val app = applications[selection]
    ILogger.ROOT.info("Selected application: '{}'", app.path)
    callback(app)
  }

  builder.show()
}


================================================
File: java/com/itsaky/androidide/actions/build/AbstractCancellableRunAction.kt
================================================
package com.itsaky.androidide.actions.build

import android.content.Context
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.BaseBuildAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.flashError
import org.slf4j.Logger
import org.slf4j.LoggerFactory

/**
 * @author Akash Yadav
 */
abstract class AbstractCancellableRunAction(
    context: Context,
    @StringRes private val labelRes: Int,
    @DrawableRes private val iconRes: Int,
) : BaseBuildAction() {

    // Execute on UI thread as this action might try to show dialogs to the user
    final override var requiresUIThread: Boolean = true

    init {
        label = context.getString(labelRes)
        icon = ContextCompat.getDrawable(context, iconRes)
        enabled = false
    }

    override fun prepare(data: ActionData) {
        super.prepare(data)
        val context = data.getActivity() ?: run {
            markInvisible()
            return
        }

        if (data.getActivity().isBuildInProgress()) {
            label = context.getString(R.string.title_cancel_build)
            icon = ContextCompat.getDrawable(context, R.drawable.ic_stop_daemons)
        } else {
            label = context.getString(labelRes)
            icon = ContextCompat.getDrawable(context, iconRes)
        }

        visible = true
        enabled = true
    }

    final override suspend fun execAction(data: ActionData): Any {
        if (data.getActivity().isBuildInProgress()) {
            return cancelBuild()
        }

        return doExec(data)
    }

    protected abstract fun doExec(data: ActionData): Any

    protected fun cancelBuild(): Boolean {
        log.info("Sending build cancellation request...")
        val builder = Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE)
        if (builder?.isToolingServerStarted() != true) {
            flashError(com.itsaky.androidide.projects.R.string.msg_tooling_server_unavailable)
            return false
        }

        builder.cancelCurrentBuild().whenComplete { result,
                                                    error ->
            if (error != null) {
                log.error("Failed to send build cancellation request", error)
                return@whenComplete
            }

            if (!result.wasEnqueued) {
                log.warn(
                    "Unable to enqueue cancellation request reason={} reason.message={}",
                    result.failureReason,
                    result.failureReason!!.message
                )
                return@whenComplete
            }

            log.info("Build cancellation request was successfully enqueued...")
        }

        return true
    }

    companion object {
        @JvmStatic
        protected val log: Logger = LoggerFactory.getLogger(AbstractCancellableRunAction::class.java)

        fun EditorHandlerActivity?.isBuildInProgress(): Boolean {
            val buildService = Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE)
            return this?.editorViewModel?.let { it.isInitializing || it.isBuildInProgress } == true || buildService?.isBuildInProgress == true
        }
    }
}


================================================
File: java/com/itsaky/androidide/actions/build/AbstractModuleAssemblerAction.kt
================================================
package com.itsaky.androidide.actions.build

import android.content.Context
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.openApplicationModuleChooser
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.projects.api.AndroidModule
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.tooling.api.messages.result.TaskExecutionResult
import com.itsaky.androidide.tooling.api.models.BasicAndroidVariantMetadata
import com.itsaky.androidide.utils.flashError
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

/**
 * @author Akash Yadav
 */
abstract class AbstractModuleAssemblerAction(
    context: Context,
    @StringRes private val labelRes: Int,
    @DrawableRes private val iconRes: Int,
) : AbstractCancellableRunAction(context, labelRes, iconRes) {

    override fun doExec(data: ActionData): Boolean {
        openApplicationModuleChooser(data) { module ->
            val activity = data.requireActivity()

            val variant = module.getSelectedVariant() ?: run {
                activity.flashError(
                    activity.getString(R.string.err_selected_variant_not_found))
                return@openApplicationModuleChooser
            }

            onModuleSelected(data, module, variant)
        }
        return true
    }

    private fun onModuleSelected(
        data: ActionData,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata
    ) {
        val buildService = this.buildService ?: run {
            log.error("Cannot execute task. BuildService not found.")
            return
        }

        if (!buildService.isToolingServerStarted()) {
            flashError(com.itsaky.androidide.R.string.msg_tooling_server_unavailable)
            return
        }

        val activity =
            data.getActivity()
                ?: run {
                    log.error(
                        "Cannot execute task. Activity instance not provided in ActionData.")
                    return
                }

        actionScope.launch(Dispatchers.Default) {
            activity.saveAllResult()

            val result = doBuild(
                data,
                module,
                variant,
                buildService,
                activity
            )

            log.debug("Task execution result: {}", result)

            handleResult(data, result, module, variant)
        }.invokeOnCompletion { error ->
            if (error != null) {
                log.error("Failed to run task", error)
            }
        }
    }

    protected abstract suspend fun doBuild(
        data: ActionData,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata,
        buildService: BuildService,
        activity: EditorHandlerActivity,
    ): TaskExecutionResult?

    protected abstract suspend fun handleResult(
        data: ActionData,
        result: TaskExecutionResult?,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata
    )
}


================================================
File: java/com/itsaky/androidide/actions/build/AbstractRunAction.kt
================================================
package com.itsaky.androidide.actions.build

import android.content.Context
import android.content.Intent
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.models.ApkMetadata
import com.itsaky.androidide.projects.api.AndroidModule
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.tooling.api.messages.TaskExecutionMessage
import com.itsaky.androidide.tooling.api.messages.result.TaskExecutionResult
import com.itsaky.androidide.tooling.api.models.BasicAndroidVariantMetadata
import com.itsaky.androidide.utils.ApkInstaller
import com.itsaky.androidide.utils.InstallationResultHandler
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File

/**
 * @author Akash Yadav
 */
abstract class AbstractRunAction(
    context: Context,
    @StringRes labelRes: Int,
    @DrawableRes iconRes: Int,
): AbstractModuleAssemblerAction(context, labelRes, iconRes) {

    /**
     * Create the task execution message for the build.
     */
    protected abstract fun onCreateTaskExecMessage(
        data: ActionData,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata,
        buildService: BuildService,
        activity: EditorHandlerActivity
    ): TaskExecutionMessage

    override suspend fun doBuild(
        data: ActionData,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata,
        buildService: BuildService,
        activity: EditorHandlerActivity
    ): TaskExecutionResult? {
        val message = onCreateTaskExecMessage(
            data,
            module,
            variant,
            buildService,
            activity,
        )

        val result = withContext(Dispatchers.IO) {
            buildService.executeTasks(message).get()
        }

        if (result?.isSuccessful != true) {
            log.error("Tasks failed to execute: '{}'", message.tasks)
        }

        return result
    }

    override suspend fun handleResult(
        data: ActionData,
        result: TaskExecutionResult?,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata
    ) {
        if (result == null || !result.isSuccessful) {
            log.debug("Cannot install APK. Task execution failed.")
            return
        }

        log.debug("Installing APK(s) for project: '{}' variant: '{}'", module.path, variant.name)

        val main = variant.mainArtifact
        val outputListingFile = main.assembleTaskOutputListingFile
        if (outputListingFile == null) {
            log.error("No output listing file provided with project model")
            return
        }

        log.trace("Parsing metadata")
        val apkFile = ApkMetadata.findApkFile(outputListingFile)
        if (apkFile == null) {
            log.error("No apk file specified in output listing file: {}", outputListingFile)
            return
        }

        if (!apkFile.exists()) {
            log.error("APK file specified in output listing file does not exist! {}", apkFile)
            return
        }

        install(data, apkFile)
    }

    protected open suspend fun install(data: ActionData, apk: File) {
        val activity =
            data.getActivity()
                ?: run {
                    log.error("Cannot install APK. Unable to get activity instance.")
                    return
                }

        withContext(Dispatchers.Main) {
            log.debug("Installing APK: {}", apk)

            if (!apk.exists()) {
                log.error("APK file does not exist!")
                return@withContext
            }

            ApkInstaller.installApk(
                activity,
                InstallationResultHandler.createEditorActivitySender(activity, ::onCreateLaunchIntent),
                apk,
                activity.installationSessionCallback()
            )
        }
    }

    protected open fun onCreateLaunchIntent() = Intent()
}


================================================
File: java/com/itsaky/androidide/actions/build/DebugAction.kt
================================================
package com.itsaky.androidide.actions.build

import android.content.Context
import android.content.Intent
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.lsp.java.debug.JdwpOptions
import com.itsaky.androidide.projects.api.AndroidModule
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.tooling.api.ToolingConfig.PROP_JDWP_DIR
import com.itsaky.androidide.tooling.api.ToolingConfig.PROP_JDWP_INJECT
import com.itsaky.androidide.tooling.api.ToolingConfig.PROP_JDWP_OPTIONS
import com.itsaky.androidide.tooling.api.messages.TaskExecutionMessage
import com.itsaky.androidide.tooling.api.models.BasicAndroidVariantMetadata
import com.itsaky.androidide.utils.Environment

/**
 * Run the application to
 *
 * @author Akash Yadav
 */
class DebugAction(
    context: Context,
    override val order: Int
): AbstractRunAction(
    context = context,
    labelRes = R.string.action_start_debugger,
    iconRes = R.drawable.ic_db_startdebugger
) {

    override val id = ID

    companion object {
        const val ID = "ide.editor.build.debug"
    }

    override fun prepare(data: ActionData) {
        super.prepare(data)
        if (data.getActivity().isBuildInProgress()) {
            // if a build is in progress, then the 'Quick run' action will be used to
            // show the cancellation button
            visible = false
        }
        enabled = JdwpOptions.JDWP_ENABLED
    }

    override fun onCreateTaskExecMessage(
        data: ActionData,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata,
        buildService: BuildService,
        activity: EditorHandlerActivity
    ): TaskExecutionMessage {
        val taskName = "${module.path}:${variant.mainArtifact.assembleTaskName}"
        log.info("Running task '{}' to debug variant '{}' of project '{}'", taskName, variant.name, module.path)

        val debugArgs = mutableListOf<String>()
        debugArgs.add("-P$PROP_JDWP_INJECT=${JdwpOptions.JDWP_ENABLED}")
        if (JdwpOptions.JDWP_ENABLED) {
            debugArgs.add("-P$PROP_JDWP_DIR=${Environment.JDWP_DIR.absolutePath}")
            debugArgs.add("-P$PROP_JDWP_OPTIONS=${JdwpOptions.JDWP_OPTIONS}")
        }

        val executionMessage = TaskExecutionMessage(
            tasks = listOf(taskName),
            gradleArgs = debugArgs
        )

        return executionMessage
    }

    override fun onCreateLaunchIntent(): Intent = super.onCreateLaunchIntent().apply {
        // add an extra value to indicate that the debugger should be started before launching
        // this application
        putExtra(ID, true)
    }
}


================================================
File: java/com/itsaky/androidide/actions/build/ProjectSyncAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.build

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.BaseBuildAction
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.resources.R.string

/**
 * Triggers a project sync request.
 *
 * @author Akash Yadav
 */
class ProjectSyncAction(context: Context, override val order: Int) : BaseBuildAction() {

  override val id: String = "ide.editor.syncProject"
  override var requiresUIThread = false

  init {
    label = context.getString(string.title_sync_project)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_sync)
  }

  override suspend fun execAction(data: ActionData): Any {
    return data.requireActivity().saveAll(requestSync = false)
  }

  override fun postExec(data: ActionData, result: Any) {
    val activity = data.requireActivity()
    activity.initializeProject()
  }
}



================================================
File: java/com/itsaky/androidide/actions/build/QuickRunAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.build

import android.content.Context
import android.graphics.ColorFilter
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.getContext
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.projects.api.AndroidModule
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.tooling.api.messages.TaskExecutionMessage
import com.itsaky.androidide.tooling.api.models.BasicAndroidVariantMetadata
import com.itsaky.androidide.utils.resolveAttr

/**
 * The 'Quick Run' and 'Cancel build' action in the editor activity.
 *
 * If a build is in progress, executing this action cancels the build. Otherwise, the selected
 * build variant is built and installed to the device.
 *
 * @author Akash Yadav
 */
class QuickRunAction(context: Context, override val order: Int) :
    AbstractRunAction(
        context = context,
        labelRes = R.string.quick_run_debug,
        iconRes = R.drawable.ic_run_outline
    ) {

    override val id: String = "ide.editor.build.quickRun"

    override fun onCreateTaskExecMessage(
        data: ActionData,
        module: AndroidModule,
        variant: BasicAndroidVariantMetadata,
        buildService: BuildService,
        activity: EditorHandlerActivity
    ): TaskExecutionMessage {
        val taskName = "${module.path}:${variant.mainArtifact.assembleTaskName}"
        log.info("Running task '{}' to assemble variant '{}' of project '{}'", taskName, variant.name, module.path)

        return TaskExecutionMessage(tasks = listOf(taskName))
    }

    override fun createColorFilter(data: ActionData): ColorFilter? {
        return data.getContext()?.let {
            PorterDuffColorFilter(
                it.resolveAttr(
                    if (data.getActivity().isBuildInProgress())
                        R.attr.colorError
                    else R.attr.colorSuccess
                ), PorterDuff.Mode.SRC_ATOP
            )
        }
    }
}



================================================
File: java/com/itsaky/androidide/actions/build/RunTasksAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.build

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.BaseBuildAction
import com.itsaky.androidide.fragments.RunTasksDialogFragment
import com.itsaky.androidide.resources.R

/** @author Akash Yadav */
class RunTasksAction(context: Context, override val order: Int) : BaseBuildAction() {
  override val id: String = "ide.editor.build.runTasks"
  private var dialog: RunTasksDialogFragment? = null

  init {
    label = context.getString(R.string.title_run_tasks)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_run_tasks)
  }

  override suspend fun execAction(data: ActionData): Any {
    dialog?.dismiss()
    dialog = null
    dialog = RunTasksDialogFragment()
    return dialog!!
  }

  override fun postExec(data: ActionData, result: Any) {
    if (result !is RunTasksDialogFragment) {
      return
    }

    val activity = data.getActivity()!!
    result.show(activity.supportFragmentManager, this.id)
  }
  
  override fun destroy() {
    super.destroy()
    try {
      dialog?.dismiss()
    } catch (e: Exception) {
      // ignored
    }
    dialog = null
  }
}



================================================
File: java/com/itsaky/androidide/actions/debug/AbstractDebuggerAction.kt
================================================
package com.itsaky.androidide.actions.debug

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.lsp.IDEDebugClientImpl

/**
 * @author Akash Yadav
 */
abstract class AbstractDebuggerAction(
    @DrawableRes private val iconRes: Int
) : ActionItem {

    // debugger actions must always be executed in a background thread
    override var requiresUIThread = false
    override var location = ActionItem.Location.DEBUGGER_ACTIONS

    override var visible = true
    override var enabled = true
    override var icon: Drawable? = null

    protected val debugClient: IDEDebugClientImpl
        get() = IDEDebugClientImpl.requireInstance()

    protected open fun checkEnabled(data: ActionData): Boolean = debugClient.isVmConnected()

    override fun prepare(data: ActionData) {
        super.prepare(data)

        icon = ContextCompat.getDrawable(data.requireContext(), iconRes)
        enabled = checkEnabled(data)
    }
}


================================================
File: java/com/itsaky/androidide/actions/debug/AbstractStepAction.kt
================================================
package com.itsaky.androidide.actions.debug

import androidx.annotation.DrawableRes
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.viewmodel.DebuggerConnectionState

abstract class AbstractStepAction(
    @DrawableRes iconRes: Int
): AbstractDebuggerAction(iconRes) {

    override fun checkEnabled(data: ActionData): Boolean =
        debugClient.connectionState >= DebuggerConnectionState.AWAITING_BREAKPOINT
}


================================================
File: java/com/itsaky/androidide/actions/debug/KillVmAction.kt
================================================
package com.itsaky.androidide.actions.debug

import android.content.Context
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData

/**
 * @author Akash Yadav
 */
class KillVmAction(
    context: Context
) : AbstractDebuggerAction(R.drawable.ic_stop) {
    override val id = "ide.debug.stop-vm"
    override var label = context.getString(R.string.debugger_kill)
    override val order = 4

    override suspend fun execAction(data: ActionData) {
        debugClient.killVm()
    }
}


================================================
File: java/com/itsaky/androidide/actions/debug/RestartVmAction.kt
================================================
package com.itsaky.androidide.actions.debug

import android.content.Context
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.utils.IntentUtils
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import kotlin.time.Duration.Companion.seconds

/**
 * @author Akash Yadav
 */
class RestartVmAction(
    context: Context
) : AbstractDebuggerAction(R.drawable.ic_restart) {
    override val id = "ide.debug.restart-vm"
    override var label = context.getString(R.string.debugger_restart)
    override val order = 5

    companion object {
        val RESTART_DELAY = 1.seconds
    }

    override suspend fun execAction(data: ActionData) {
        val context = data.requireContext()

        // kill the current VM
        debugClient.killVm()

        // wait for some time
        delay(RESTART_DELAY)

        // then launch the debugee again
        withContext(Dispatchers.Main.immediate) {
            IntentUtils.launchApp(context, debugClient.debugeePackage)
        }
    }
}



================================================
File: java/com/itsaky/androidide/actions/debug/StepIntoAction.kt
================================================
package com.itsaky.androidide.actions.debug

import android.content.Context
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData

/**
 * @author Akash Yadav
 */
class StepIntoAction(
    context: Context
) : AbstractStepAction(R.drawable.ic_step_into) {
    override val id = "ide.debug.step-into"
    override var label = context.getString(R.string.debugger_step_into)
    override val order = 2

    override suspend fun execAction(data: ActionData) {
        debugClient.stepInto()
    }
}


================================================
File: java/com/itsaky/androidide/actions/debug/StepOutAction.kt
================================================
package com.itsaky.androidide.actions.debug

import android.content.Context
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData

/**
 * @author Akash Yadav
 */
class StepOutAction(
    context: Context
) : AbstractStepAction(R.drawable.ic_step_out) {
    override val id = "ide.debug.step-out"
    override var label = context.getString(R.string.debugger_step_out)
    override val order = 3

    override suspend fun execAction(data: ActionData) {
        debugClient.stepOut()
    }
}


================================================
File: java/com/itsaky/androidide/actions/debug/StepOverAction.kt
================================================
package com.itsaky.androidide.actions.debug

import android.content.Context
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData

/**
 * @author Akash Yadav
 */
class StepOverAction(
    context: Context
) : AbstractStepAction(R.drawable.ic_step_over) {
    override val id = "ide.debug.step-over"
    override var label = context.getString(R.string.debugger_step_over)
    override val order = 1

    override suspend fun execAction(data: ActionData) {
        debugClient.stepOver()
    }
}


================================================
File: java/com/itsaky/androidide/actions/debug/SuspendResumeVmAction.kt
================================================
package com.itsaky.androidide.actions.debug

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireContext

/**
 * @author Akash Yadav
 */
class SuspendResumeVmAction(
    context: Context
) : AbstractDebuggerAction(R.drawable.ic_pause) {

    override val id = "ide.debug.suspend-resume"
    override var label = context.getString(R.string.debugger_suspend)
    override val order = 0

    override fun prepare(data: ActionData) {
        super.prepare(data)
        val context = data.requireContext()
        val isSuspended = debugClient.isVmSuspended()
        if (isSuspended) {
            label = context.getString(R.string.debugger_resume)
            icon = ContextCompat.getDrawable(context, R.drawable.ic_run)
        } else {
            label = context.getString(R.string.debugger_suspend)
            icon = ContextCompat.getDrawable(context, R.drawable.ic_pause)
        }
    }

    override suspend fun execAction(data: ActionData) {
        if (debugClient.isVmSuspended()) {
            debugClient.resumeVm()
        } else {
            debugClient.suspendVm()
        }
    }
}


================================================
File: java/com/itsaky/androidide/actions/editor/CopyAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.editor

import android.content.Context
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.BaseEditorAction
import com.itsaky.androidide.resources.R

/** @author Akash Yadav */
class CopyAction(context: Context, override val order: Int) : BaseEditorAction() {

  init {
    label = context.getString(R.string.copy)

    val arr = context.obtainStyledAttributes(intArrayOf(android.R.attr.actionModeCopyDrawable))
    icon = arr.getDrawable(0)?.let { tintDrawable(context, it) }
    arr.recycle()
  }

  override val id: String = "ide.editor.code.text.copy"
  override suspend fun execAction(data: ActionData): Boolean {
    val editor = getEditor(data) ?: return false
    editor.copyText()
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/editor/CutAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.editor

import android.content.Context
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.BaseEditorAction

/** @author Akash Yadav */
class CutAction(context: Context, override val order: Int) : BaseEditorAction() {

  init {
    label = context.getString(android.R.string.cut)

    val arr = context.obtainStyledAttributes(intArrayOf(android.R.attr.actionModeCutDrawable))
    icon = arr.getDrawable(0)?.let { tintDrawable(context, it) }
    arr.recycle()
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)

    if (!visible) {
      return
    }

    visible = getEditor(data)?.isEditable ?: false
    enabled = visible
  }

  override val id: String = "ide.editor.code.text.cut"
  override suspend fun execAction(data: ActionData): Boolean {
    val editor = getEditor(data) ?: return false
    editor.cutText()
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/editor/ExpandSelectionAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.editor

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.resources.R

/**
 * Expands the current selection using the language server set in editor.
 *
 * @author Akash Yadav
 */
class ExpandSelectionAction(context: Context, override val order: Int) : EditorRelatedAction() {
  override val id: String = "ide.editor.code.actions.expandSelection"
  override var location: ActionItem.Location = ActionItem.Location.EDITOR_TEXT_ACTIONS

  init {
    label = context.getString(R.string.action_expand_selection)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_expand_selection)
  }

  override suspend fun execAction(data: ActionData): Any {
    return data.getEditor()?.expandSelection() ?: false
  }
}



================================================
File: java/com/itsaky/androidide/actions/editor/LongSelectAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *  
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.editor

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.actions.markInvisible

/**
 * An action to long select text in the editor.
 *
 * @author Akash Yadav
 */
class LongSelectAction(context: Context, override val order: Int) : EditorRelatedAction() {

  override val id: String = "ide.editor.code.text.longSelect"
  override var location: ActionItem.Location = ActionItem.Location.EDITOR_TEXT_ACTIONS

  init {
    label = context.getString(R.string.title_begin_long_select)
    icon = ContextCompat.getDrawable(context, R.drawable.editor_text_select_start)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getEditor() ?: markInvisible()
  }

  override suspend fun execAction(data: ActionData): Any {
    return data.getEditor()?.beginLongSelect() ?: false
  }
}


================================================
File: java/com/itsaky/androidide/actions/editor/PasteAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.editor

import android.content.Context
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.BaseEditorAction

/** @author Akash Yadav */
class PasteAction(context: Context, override val order: Int) : BaseEditorAction() {

  init {
    label = context.getString(android.R.string.paste)

    val arr = context.obtainStyledAttributes(intArrayOf(android.R.attr.actionModePasteDrawable))
    icon = arr.getDrawable(0)?.let { tintDrawable(context, it) }
    arr.recycle()
  }

  override val id: String = "ide.editor.code.text.paste"

  override fun prepare(data: ActionData) {
    super.prepare(data)

    if (!visible) {
      return
    }

    visible = getEditor(data)?.isEditable ?: false
    enabled = visible
  }

  override suspend fun execAction(data: ActionData): Boolean {
    val editor = getEditor(data) ?: return false
    editor.pasteText()
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/editor/SelectAllAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.editor

import android.content.Context
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.BaseEditorAction

/** @author Akash Yadav */
class SelectAllAction(context: Context, override val order: Int) : BaseEditorAction() {

  init {
    label = context.getString(android.R.string.selectAll)

    val arr = context.obtainStyledAttributes(intArrayOf(android.R.attr.actionModeSelectAllDrawable))
    icon = arr.getDrawable(0)?.let { tintDrawable(context, it) }
    arr.recycle()
  }

  override val id: String = "ide.editor.code.text.selectAll"

  override suspend fun execAction(data: ActionData): Boolean {
    val editor = getEditor(data) ?: return false
    editor.selectAll()
    return true
  }

  override fun dismissOnAction() = false
}



================================================
File: java/com/itsaky/androidide/actions/etc/DisconnectLogSendersAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.etc

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.services.log.lookupLogService

/**
 * An action to disconnect all connected LogSenders at once.
 *
 * @author Akash Yadav
 */
class DisconnectLogSendersAction(context: Context, override val order: Int) : EditorActivityAction() {

  override val id: String = "ide.editor.service.logreceiver.disconnectSenders"

  init {
    label = context.getString(R.string.title_disconnect_log_senders)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_logs_disconnect)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getActivity() ?: run {
      markInvisible()
      return
    }

    val receiverService = lookupLogService()
    if (receiverService == null) {
      markInvisible()
      return
    }
  }

  override suspend fun execAction(data: ActionData): Any {
    val receiverService = lookupLogService()
    receiverService?.disconnectAll()

    markInvisible()
    data.getActivity()?.invalidateOptionsMenu()
    return true
  }
}


================================================
File: java/com/itsaky/androidide/actions/etc/FindActionMenu.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.etc

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.ActionMenu
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.resources.R

/** @author Akash Yadav */
class FindActionMenu(context: Context, override val order: Int) : EditorActivityAction(),
  ActionMenu {

  override val children: MutableSet<ActionItem> = mutableSetOf()
  override val id: String = "ide.editor.find"

  init {
    label = context.getString(R.string.menu_find)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_search)

    addAction(FindInFileAction(context, 0))
    addAction(FindInProjectAction(context, 1))
  }

  override fun prepare(data: ActionData) {
    super<EditorActivityAction>.prepare(data)
    super<ActionMenu>.prepare(data)
  }
}



================================================
File: java/com/itsaky/androidide/actions/etc/FindInFileAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.etc

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.resources.R

/** @author Akash Yadav */
class FindInFileAction() : EditorRelatedAction() {

  override val id: String = "ide.editor.find.inFile"
  override var requiresUIThread: Boolean = true

  override var order: Int = 0

  constructor(context: Context, order: Int) : this() {
    this.label = context.getString(R.string.menu_find_file)
    this.icon = ContextCompat.getDrawable(context, R.drawable.ic_search_file)
    this.order = order
  }

  override suspend fun execAction(data: ActionData): Boolean {
    val editor = data.getEditorView() ?: return false
    editor.beginSearch()
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/etc/FindInProjectAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.etc

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.resources.R

/** @author Akash Yadav */
class FindInProjectAction() : EditorActivityAction() {

  override var requiresUIThread: Boolean = true
  override var order: Int = 0

  constructor(context: Context, order: Int) : this() {
    this.label = context.getString(R.string.menu_find_project)
    this.icon = ContextCompat.getDrawable(context, R.drawable.ic_search_project)
    this.order = order
  }

  override val id: String = "ide.editor.find.inProject"

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getActivity()
      ?: run {
        markInvisible()
        return
      }

    val project = IProjectManager.getInstance().rootProject
    if (project == null || project.subProjects.isEmpty()) {
      markInvisible()
      return
    }

    visible = true
    enabled = true
  }

  override suspend fun execAction(data: ActionData): Boolean {
    val context = data.getActivity() ?: return false
    val dialog = context.findInProjectDialog

    return run {
      dialog.show()
      true
    }
  }
}



================================================
File: java/com/itsaky/androidide/actions/etc/LaunchAppAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.etc

import android.content.Context
import android.view.MenuItem
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.actions.openApplicationModuleChooser
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.utils.IntentUtils
import com.itsaky.androidide.utils.flashError
import org.slf4j.LoggerFactory

/**
 * An action to launch the already installed application on the device.
 *
 * @author Akash Yadav
 */
class LaunchAppAction(context: Context, override val order: Int) : EditorActivityAction() {

  override val id: String = "ide.editor.launchInstalledApp"
  override var requiresUIThread: Boolean = true

  init {
    label = context.getString(R.string.title_launch_app)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_open_external)
  }

  companion object {
    private val log = LoggerFactory.getLogger(LaunchAppAction::class.java)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getActivity() ?: run {
      markInvisible()
      return
    }

    visible = true

    val projectManager = IProjectManager.getInstance()
    enabled = projectManager.getAndroidAppModules().isNotEmpty()
  }

  override suspend fun execAction(data: ActionData) {
    openApplicationModuleChooser(data) { app ->
      val variant = app.getSelectedVariant()

      log.debug("Selected variant: {}", variant?.name)

      if (variant == null) {
        flashError(R.string.err_selected_variant_not_found)
        return@openApplicationModuleChooser
      }

      val applicationId = variant.mainArtifact.applicationId
      if (applicationId == null) {
        log.error("Unable to launch application. variant.mainArtifact.applicationId is null")
        flashError(R.string.err_cannot_determine_package)
        return@openApplicationModuleChooser
      }

      log.info("Launching application: {}", applicationId)

      val activity = data.requireActivity()
      IntentUtils.launchApp(activity, applicationId, logError = false)
    }
  }

  override fun getShowAsActionFlags(data: ActionData): Int {
    // prefer showing this in the overflow menu
    return MenuItem.SHOW_AS_ACTION_IF_ROOM
  }
}


================================================
File: java/com/itsaky/androidide/actions/etc/PreviewLayoutAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.etc

import android.content.Context
import android.content.Intent
import android.view.MenuItem
import androidx.core.content.ContextCompat
import com.android.aaptcompiler.AaptResourceType.LAYOUT
import com.android.aaptcompiler.extractPathData
import com.blankj.utilcode.util.KeyboardUtils
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.actions.file.CloseFileAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.activities.editor.EditorActivityKt
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.editor.ui.IDEEditor
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.uidesigner.UIDesignerActivity
import com.itsvks.layouteditor.activities.EditorActivity
import com.itsvks.layouteditor.utils.Constants
import java.io.File



/** @author Akash Yadav */
class PreviewLayoutAction(context: Context, override val order: Int) : EditorRelatedAction() {

  override val id: String = "ide.editor.previewLayout"

  override var requiresUIThread: Boolean = false

  init {
    label = context.getString(R.string.title_preview_layout)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_preview_layout)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)

    val viewModel = data.requireActivity().editorViewModel
    if (viewModel.isInitializing) {
      visible = true
      enabled = false
      return
    }

    if (!visible) {
      return
    }

    val editor = data.requireEditor()
    val file = editor.file!!

    val isXml = file.name.endsWith(".xml")

    if (!isXml) {
      markInvisible()
      return
    }

    val type = try {
      extractPathData(file).type
    } catch (err: Throwable) {
      markInvisible()
      return
    }

    visible = type == LAYOUT
    enabled = visible
  }

  override fun getShowAsActionFlags(data: ActionData): Int {
    val activity = data.getActivity() ?: return super.getShowAsActionFlags(data)
    return if (KeyboardUtils.isSoftInputVisible(activity)) {
      MenuItem.SHOW_AS_ACTION_IF_ROOM
    } else {
      MenuItem.SHOW_AS_ACTION_ALWAYS
    }
  }

  override suspend fun execAction(data: ActionData): Boolean {
    val activity = data.requireActivity()
    activity.saveAll()
    return true
  }

  override fun postExec(data: ActionData, result: Any) {
    val activity = data.requireActivity()
    activity.previewLayout(data.requireEditor().file!!)
  }

  private fun EditorHandlerActivity.previewLayout(file: File) {
//    //close any open xml files first
//    val openEditors = editorViewModel.getOpenedFileCount()
//    for(index in 1..openEditors) {
//      closeFile(index-1) //zero based
//    }
//    invalidateOptionsMenu()

    val intent = Intent(this, EditorActivity::class.java)
    intent.putExtra(Constants.EXTRA_KEY_FILE_PATH, file.absolutePath.substringBefore("layout"))
    intent.putExtra(Constants.EXTRA_KEY_LAYOUT_FILE_NAME, file.name.substringBefore("."))
    uiDesignerResultLauncher?.launch(intent)
  }

  private fun ActionData.requireEditor(): IDEEditor {
    return this.getEditor() ?: throw IllegalArgumentException(
      "An editor instance is required but none was provided")
  }
}



================================================
File: java/com/itsaky/androidide/actions/file/CloseAllFilesAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.file

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.activities.editor.EditorHandlerActivity

/**
 * Closes all opened files.
 *
 * @author Akash Yadav
 */
class CloseAllFilesAction(context: Context, override val order: Int) : FileTabAction() {

  override val id: String = "ide.editor.fileTab.close.all"

  init {
    label = context.getString(R.string.action_closeAll)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_close_all)
  }

  override fun EditorHandlerActivity.doAction(data: ActionData): Boolean {
    closeAll {
      invalidateOptionsMenu()
    }
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/file/CloseFileAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.file

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.activities.editor.EditorHandlerActivity

/**
 * Closes the current file.
 *
 * @author Akash Yadav
 */
class CloseFileAction(context: Context, override val order: Int) : FileTabAction() {

  override val id: String = "ide.editor.fileTab.close.current"

  init {
    label = context.getString(R.string.action_closeThis)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_close_this)
  }

  override fun EditorHandlerActivity.doAction(data: ActionData): Boolean {
    data.getActivity()?.closeCurrentFile()
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/file/CloseOtherFilesAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.file

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.activities.editor.EditorHandlerActivity

/**
 * Closes all opened files except the selected one.
 *
 * @author Akash Yadav
 */
class CloseOtherFilesAction(context: Context, override val order: Int) : FileTabAction() {

  override val id: String = "ide.editor.fileTab.close.others"

  init {
    label = context.getString(R.string.action_closeOthers)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_close_others)
  }

  override fun EditorHandlerActivity.doAction(data: ActionData): Boolean {
    closeOthers()
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/file/FileTabAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.file

import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem.Location
import com.itsaky.androidide.actions.ActionItem.Location.EDITOR_FILE_TABS
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.activities.editor.EditorHandlerActivity

/**
 * Action related to file tabs. Shown only when there is at least one file opened.
 *
 * @author Akash Yadav
 */
abstract class FileTabAction : EditorActivityAction() {

  override var location: Location = EDITOR_FILE_TABS
  override var requiresUIThread: Boolean = true

  override fun prepare(data: ActionData) {
    super.prepare(data)

    if (!visible) {
      return
    }

    val activity =
      data.getActivity()
        ?: run {
          markInvisible()
          return
        }

    visible = activity.editorViewModel.getOpenedFiles().isNotEmpty()
    enabled = visible
  }

  override suspend fun execAction(data: ActionData): Any {
    val activity = data.getActivity() ?: return false
    return activity.doAction(data)
  }

  abstract fun EditorHandlerActivity.doAction(data: ActionData): Boolean
}



================================================
File: java/com/itsaky/androidide/actions/file/FormatCodeAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.file

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.resources.R

/**
 * Action that formats the code in the editor.
 *
 * @author Akash Yadav
 */
class FormatCodeAction(context: Context, override val order: Int) : EditorRelatedAction() {
  override val id: String = "ide.editor.code.text.format"
  override var location: ActionItem.Location = ActionItem.Location.EDITOR_TEXT_ACTIONS

  init {
    label = context.getString(R.string.title_format_code)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_format_code)
  }

  override suspend fun execAction(data: ActionData): Any {
    val editor = data.getEditor()!!
    val cursor = editor.text.cursor

    if (cursor.isSelected) {
      editor.formatCodeAsync(cursor.left(), cursor.right())
    } else {
      editor.formatCodeAsync()
    }
    return true
  }
}



================================================
File: java/com/itsaky/androidide/actions/file/SaveFileAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.file

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.models.SaveResult
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import org.slf4j.LoggerFactory

/** @author Akash Yadav */
class SaveFileAction(context: Context, override val order: Int) : EditorRelatedAction() {

  override val id: String = "ide.editor.files.saveAll"
  override var requiresUIThread: Boolean = false

  companion object {
    private val log = LoggerFactory.getLogger(SaveFileAction::class.java)
  }

  init {
    label = context.getString(R.string.save)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_save)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    val context = data.getActivity() ?: run {
      visible = false
      enabled = false
      return
    }

    visible = context.editorViewModel.getOpenedFiles().isNotEmpty()
    enabled = context.areFilesModified() && !context.areFilesSaving()
  }

  override suspend fun execAction(data: ActionData): ResultWrapper {
    val context = data.getActivity() ?: return ResultWrapper()

    if (context.areFilesSaving()) {
      return ResultWrapper(isAlreadySaving = true)
    }

    return try {
      // Cannot use context.saveAll() because this.execAction is called on non-UI thread
      // and saveAll call will result in UI actions
      ResultWrapper(result = context.saveAllResult())
    } catch (error: Throwable) {
      log.error("Failed to save file", error)
      ResultWrapper()
    }
  }

  override fun postExec(data: ActionData, result: Any) {
    if (result is ResultWrapper && result.result != null) {
      val context = data.requireActivity()

      if (result.isAlreadySaving) {
        context.flashError(R.string.msg_files_being_saved)
        return
      }

      // show save notification before calling 'notifySyncNeeded' so that the file save notification
      // does not overlap the sync notification
      context.flashSuccess(R.string.all_saved)

      val saveResult = result.result
      if (saveResult.xmlSaved) {
        ProjectManagerImpl.getInstance().generateSources()
      }

      if (saveResult.gradleSaved) {
        context.editorViewModel.isSyncNeeded = true
      }

      context.invalidateOptionsMenu()
    } else {
      log.error("Failed to save file")
      flashError(R.string.save_failed)
    }
  }

  inner class ResultWrapper(val isAlreadySaving: Boolean = false, val result: SaveResult? = null)
}



================================================
File: java/com/itsaky/androidide/actions/file/ShowTooltipAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.file

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.idetooltips.IDETooltipItem
import com.itsaky.androidide.utils.TooltipUtils

class ShowTooltipAction(private val context: Context, override val order: Int) :
    EditorRelatedAction() {
    override val id: String = "ide.editor.code.text.format"
    override var location: ActionItem.Location = ActionItem.Location.EDITOR_TEXT_ACTIONS
    private var htmlString: String = ""

    init {
        label = context.getString(R.string.title_show_tooltip)
        icon = ContextCompat.getDrawable(context, R.drawable.ic_action_help)
    }

    override suspend fun execAction(data: ActionData): Any {
        val editor = data.getEditor()!!
        val cursor = editor.text.cursor
        val activity = data.getActivity()
        val category = when(editor.file!!.extension.toString()) {
            "java" -> "java"
            "kt" -> "kotlin"
            else -> "ide"
        }
        val word = editor.text.substring(cursor.left, cursor.right)
        if (cursor.isSelected) {
            activity?.getTooltipData(category, word)?.let { tooltipData ->
                TooltipUtils.showIDETooltip(
                    context,
                    editor,
                    0,
                    IDETooltipItem(
                        tooltipCategory = category,
                        tooltipTag = tooltipData.tooltipTag,
                        detail = tooltipData.detail,
                        summary = tooltipData.summary,
                        buttons = tooltipData.buttons,
                    ),
                )
            }
        }
        return true
    }

}



================================================
File: java/com/itsaky/androidide/actions/filetree/BaseDirNodeAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.content.Context
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.actions.requireFile

/**
 * Base class for action items for directory nodes.
 *
 * @author Akash Yadav
 */
abstract class BaseDirNodeAction(context: Context,
  @StringRes labelRes: Int? = null,
  @DrawableRes iconRes: Int? = null) : BaseFileTreeAction(context, labelRes, iconRes) {

  override fun prepare(data: ActionData) {
    super.prepare(data)
    if (!data.hasFileTreeData()) {
      markInvisible()
      return
    }

    val file = data.requireFile()
    if (!file.isDirectory) {
      markInvisible()
      return
    }

    visible = true
    enabled = true
  }
}



================================================
File: java/com/itsaky/androidide/actions/filetree/BaseFileTreeAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.content.Context
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.hasRequiredData
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.eventbus.events.Event
import com.itsaky.androidide.events.CollapseTreeNodeRequestEvent
import com.itsaky.androidide.events.ExpandTreeNodeRequestEvent
import com.itsaky.androidide.events.ListProjectFilesRequestEvent
import com.unnamed.b.atv.model.TreeNode
import org.greenrobot.eventbus.EventBus
import java.io.File

/**
 * Base class for actions related to the file tree.
 *
 * @author Akash Yadav
 */
abstract class BaseFileTreeAction(
  context: Context,
  @StringRes labelRes: Int? = null,
  @DrawableRes iconRes: Int? = null
) : EditorActivityAction() {

  override var requiresUIThread: Boolean = true
  override var location: ActionItem.Location = ActionItem.Location.EDITOR_FILE_TREE

  init {
    labelRes?.let { label = context.getString(it) }
    iconRes?.let { icon = ContextCompat.getDrawable(context, it) }
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    if (!data.hasFileTreeData()) {
      markInvisible()
      return
    }

    visible = true
    enabled = true
  }

  protected open fun ActionData.hasFileTreeData(): Boolean {
    return hasRequiredData(Context::class.java, File::class.java, TreeNode::class.java)
  }

  protected fun ActionData.getTreeNode() : TreeNode? {
    return this[TreeNode::class.java]
  }

  protected fun ActionData.requireTreeNode() : TreeNode {
    return getTreeNode()!!
  }

  protected fun Event.putData(context: Context): Event {
    put(Context::class.java, context)
    return this
  }

  protected fun requestFileListing() {
    EventBus.getDefault().post(ListProjectFilesRequestEvent())
  }

  protected fun requestExpandNode(node: TreeNode) {
    EventBus.getDefault().post(ExpandTreeNodeRequestEvent(node))
  }

  protected fun requestCollapseNode(node: TreeNode, includeSubnodes: Boolean) {
    EventBus.getDefault().post(CollapseTreeNodeRequestEvent(node, includeSubnodes))
  }
}



================================================
File: java/com/itsaky/androidide/actions/filetree/CopyPathAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.content.Context
import com.blankj.utilcode.util.ClipboardUtils
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireFile
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.flashSuccess

/**
 * Action to copy the absolute path of the selected file.
 *
 * @author Akash Yadav
 */
class CopyPathAction(context: Context, override val order: Int) :
  BaseFileTreeAction(context, labelRes = R.string.copy_path, iconRes = R.drawable.ic_copy) {

  override val id: String = "ide.editor.fileTree.copyPath"

  override suspend fun execAction(data: ActionData) {
    val file = data.requireFile()
    ClipboardUtils.copyText("[AndroidIDE] Copied File Path", file.absolutePath)
    flashSuccess(R.string.copied)
  }
}



================================================
File: java/com/itsaky/androidide/actions/filetree/DeleteAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.app.ProgressDialog
import android.content.Context
import com.blankj.utilcode.util.FileUtils
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireFile
import com.itsaky.androidide.eventbus.events.file.FileDeletionEvent
import com.itsaky.androidide.projects.FileManager
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.tasks.executeAsync
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.FlashType
import com.itsaky.androidide.utils.flashMessage
import org.greenrobot.eventbus.EventBus
import java.io.File

/**
 * File tree action to delete files.
 *
 * @author Akash Yadav
 */
class DeleteAction(context: Context, override val order: Int) :
  BaseFileTreeAction(context, labelRes = R.string.delete_file, iconRes = R.drawable.ic_delete) {

  override val id: String = "ide.editor.fileTree.delete"

  override suspend fun execAction(data: ActionData) {
    val context = data.requireActivity()
    val file = data.requireFile()
    val lastHeld = data.getTreeNode()
    val builder = DialogUtils.newMaterialDialogBuilder(context)
    builder
      .setNegativeButton(R.string.no, null)
      .setPositiveButton(R.string.yes) { dialogInterface, _ ->
        dialogInterface.dismiss()
        @Suppress("DEPRECATION")
        val progressDialog =
          ProgressDialog.show(context, null, context.getString(R.string.please_wait), true, false)
        executeAsync({ FileUtils.delete(file) }) {
          progressDialog.dismiss()

          val deleted = it ?: false

          flashMessage(
            if (deleted) R.string.deleted else R.string.delete_failed,
            if (deleted) FlashType.SUCCESS else FlashType.ERROR
          )

          if (!deleted) {
            return@executeAsync
          }

          notifyFileDeleted(file, context)

          if (lastHeld != null) {
            val parent = lastHeld.parent
            parent.deleteChild(lastHeld)
            requestExpandNode(parent)
          } else {
            requestFileListing()
          }

          val frag = context.getEditorForFile(file)
          if (frag != null) {
            context.closeFile(context.findIndexOfEditorByFile(frag.file))
          }
        }
      }
      .setTitle(R.string.title_confirm_delete)
      .setMessage(
        context.getString(
          R.string.msg_confirm_delete,
          String.format("%s [%s]", file.name, file.absolutePath)
        )
      )
      .setCancelable(false)
      .create()
      .show()
  }

  private fun notifyFileDeleted(file: File, context: Context) {
    val deletionEvent = FileDeletionEvent(file)

    // Notify FileManager first
    FileManager.onFileDeleted(deletionEvent)

    EventBus.getDefault().post(deletionEvent.putData(context))
  }
}



================================================
File: java/com/itsaky/androidide/actions/filetree/HelpAction.kt
================================================
package com.itsaky.androidide.actions.filetree

import android.content.Context
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.utils.UrlManager

class HelpAction(context: Context, override val order: Int) :
    BaseFileTreeAction(
        context = context,
        labelRes = R.string.help,
        iconRes = R.drawable.ic_action_help
    ) {
    override val id: String = "ide.editor.fileTree.help"

    override suspend fun execAction(data: ActionData) {
        val context = data.requireContext()
        UrlManager.openUrl(
            url = HELP_URL,
            context = context
        )
    }

    companion object {
        private const val HELP_URL = "https://code-on-the-go.com/help"
    }
}


================================================
File: java/com/itsaky/androidide/actions/filetree/NewFileAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.content.Context
import android.view.LayoutInflater
import androidx.core.view.isVisible
import com.blankj.utilcode.util.FileIOUtils
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireFile
import com.itsaky.androidide.adapters.viewholders.FileTreeViewHolder
import com.itsaky.androidide.databinding.LayoutCreateFileJavaBinding
import com.itsaky.androidide.eventbus.events.file.FileCreationEvent
import com.itsaky.androidide.preferences.databinding.LayoutDialogTextInputBinding
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.ProjectWriter
import com.itsaky.androidide.utils.SingleTextWatcher
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import com.unnamed.b.atv.model.TreeNode
import jdkx.lang.model.SourceVersion
import org.greenrobot.eventbus.EventBus
import org.slf4j.LoggerFactory
import java.io.File
import java.util.Objects
import java.util.regex.Pattern

/**
 * File tree action to create a new file.
 *
 * @author Akash Yadav
 */
class NewFileAction(context: Context, override val order: Int) :
  BaseDirNodeAction(
    context = context,
    labelRes = R.string.new_file,
    iconRes = R.drawable.ic_new_file
  ) {

  override val id: String = "ide.editor.fileTree.newFile"

  companion object {

    const val RES_PATH_REGEX = "/.*/src/.*/res"
    const val LAYOUT_RES_PATH_REGEX = "/.*/src/.*/res/layout"
    const val MENU_RES_PATH_REGEX = "/.*/src/.*/res/menu"
    const val DRAWABLE_RES_PATH_REGEX = "/.*/src/.*/res/drawable"
    const val JAVA_PATH_REGEX = "/.*/src/.*/java"

    private val log = LoggerFactory.getLogger(NewFileAction::class.java)
  }

  override suspend fun execAction(data: ActionData) {
    val context = data.requireActivity()
    val file = data.requireFile()
    val node = data.getTreeNode()
    try {
      createNewFile(context, node, file, false)
    } catch (e: Exception) {
      log.error("Failed to create new file", e)
      flashError(e.cause?.message ?: e.message)
    }
  }

  private fun createNewFile(
    context: Context,
    node: TreeNode?,
    file: File,
    forceUnknownType: Boolean
  ) {
    if (forceUnknownType) {
      createNewEmptyFile(context, node, file)
      return
    }

    val projectDir = IProjectManager.getInstance().projectDirPath
    Objects.requireNonNull(projectDir)
    val isJava =
      Pattern.compile(Pattern.quote(projectDir) + JAVA_PATH_REGEX).matcher(file.absolutePath).find()
    val isRes =
      Pattern.compile(Pattern.quote(projectDir) + RES_PATH_REGEX).matcher(file.absolutePath).find()
    val isLayoutRes =
      Pattern.compile(Pattern.quote(projectDir) + LAYOUT_RES_PATH_REGEX)
        .matcher(file.absolutePath)
        .find()
    val isMenuRes =
      Pattern.compile(Pattern.quote(projectDir) + MENU_RES_PATH_REGEX)
        .matcher(file.absolutePath)
        .find()
    val isDrawableRes =
      Pattern.compile(Pattern.quote(projectDir) + DRAWABLE_RES_PATH_REGEX)
        .matcher(file.absolutePath)
        .find()

    if (isJava) {
      createJavaClass(context, node, file)
      return
    }

    if (isLayoutRes && file.name == "layout") {
      createLayoutRes(context, node, file)
      return
    }

    if (isMenuRes && file.name == "menu") {
      createMenuRes(context, node, file)
      return
    }

    if (isDrawableRes && file.name == "drawable") {
      createDrawableRes(context, node, file)
      return
    }

    if (isRes && file.name == "res") {
      createNewResource(context, node, file)
      return
    }

    createNewEmptyFile(context, node, file)
  }

  private fun createJavaClass(context: Context, node: TreeNode?, file: File) {
    val builder = DialogUtils.newMaterialDialogBuilder(context)
    val binding: LayoutCreateFileJavaBinding =
      LayoutCreateFileJavaBinding.inflate(LayoutInflater.from(context))
    binding.typeGroup.addOnButtonCheckedListener { _, _, _ ->
      binding.createLayout.isVisible = binding.typeGroup.checkedButtonId == binding.typeActivity.id
    }
    binding.name.editText?.addTextChangedListener(
      object : SingleTextWatcher() {
        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
          if (isValidJavaName(s)) {
            binding.name.isErrorEnabled = true
            binding.name.error = context.getString(R.string.msg_invalid_name)
          } else {
            binding.name.isErrorEnabled = false
          }
        }
      }
    )
    builder.setView(binding.root)
    builder.setTitle(R.string.new_java_class)
    builder.setPositiveButton(R.string.text_create) { dialogInterface, _ ->
      dialogInterface.dismiss()
      try {
        doCreateJavaFile(binding, file, context, node)
      } catch (e: Exception) {
        log.error("Failed to create Java file", e)
        flashError(e.cause?.message ?: e.message)
      }
    }
    builder.setNegativeButton(android.R.string.cancel, null)
    builder.setCancelable(false)
    builder.create().show()
  }

  private fun doCreateJavaFile(
    binding: LayoutCreateFileJavaBinding,
    file: File,
    context: Context,
    node: TreeNode?
  ) {
    if (binding.name.isErrorEnabled) {
      flashError(R.string.msg_invalid_name)
      return
    }

    val name: String = binding.name.editText!!.text.toString().trim()
    if (name.isBlank()) {
      flashError(R.string.msg_invalid_name)
      return
    }

    val autoLayout =
      binding.typeGroup.checkedButtonId == binding.typeActivity.id &&
          binding.createLayout.isChecked
    val pkgName = ProjectWriter.getPackageName(file)

    val id: Int = binding.typeGroup.checkedButtonId
    val javaName = if (name.endsWith(".java")) name else "$name.java"
    val className = if (!name.contains(".")) name else name.substring(0, name.lastIndexOf("."))

    // Package Structure Check: When the package is "com", it checks if a com subdirectory exists within the current directory.
    // If com/ exists, it means the package structure is organized correctly.
    // The Java file should be created within com/ to maintain package consistency.
    // If the com subdirectory does not exist, use the original directory (file), avoiding FileNotFoundException errors.
    val javaFileDirectory = if (pkgName == "com") {
      val subDir = File(file, "com")
      if (subDir.exists() && subDir.isDirectory) subDir else file
    } else {
      file
    }

    val created =
      when (id) {
        binding.typeClass.id ->
          createFile(
              context,
              node,
              javaFileDirectory,
              javaName,
              ProjectWriter.createJavaClass(pkgName, className),
          )

        binding.typeInterface.id ->
          createFile(
            context,
            node,
            javaFileDirectory,
            javaName,
            ProjectWriter.createJavaInterface(pkgName, className)
          )

        binding.typeEnum.id ->
          createFile(
            context,
            node,
            javaFileDirectory,
            javaName,
            ProjectWriter.createJavaEnum(pkgName, className)
          )

        binding.typeActivity.id ->
          createFile(
            context,
            node,
            javaFileDirectory,
            javaName,
            ProjectWriter.createActivity(pkgName, className)
          )

        else -> createFile(context, node, javaFileDirectory, name, "")
      }

    node?.let {
      requestCollapseNode(it, true)
    }

    if (created is Boolean && autoLayout) {
      val packagePath = pkgName.toString().replace(".", "/")
      createAutoLayout(context, javaFileDirectory, name, packagePath)
    }
  }

  private fun isValidJavaName(s: CharSequence?) =
    s == null || !SourceVersion.isName(s) || SourceVersion.isKeyword(s)

  private fun createLayoutRes(context: Context, node: TreeNode?, file: File) {
    createNewFileWithContent(
      context,
      node,
      Environment.mkdirIfNotExits(file),
      ProjectWriter.createLayout(),
      ".xml"
    )
  }

  private fun createAutoLayout(
    context: Context,
    directory: File,
    fileName: String,
    packagePath: String
  ) {
    val dir = directory.toString().replace("java/$packagePath", "res/layout/")
    val layoutName = ProjectWriter.createLayoutName(fileName.replace(".java", ".xml"))
    val newFileLayout = File(dir, layoutName)
    if (newFileLayout.exists()) {
      flashError(R.string.msg_layout_file_exists)
      return
    }

    if (!FileIOUtils.writeFileFromString(newFileLayout, ProjectWriter.createLayout())) {
      flashError(R.string.msg_layout_file_creation_failed)
      return
    }

    notifyFileCreated(newFileLayout, context)
  }

  private fun createMenuRes(context: Context, node: TreeNode?, file: File) {
    createNewFileWithContent(
      context,
      node,
      Environment.mkdirIfNotExits(file),
      ProjectWriter.createMenu(),
      ".xml"
    )
  }

  private fun createDrawableRes(context: Context, node: TreeNode?, file: File) {
    createNewFileWithContent(
      context,
      node,
      Environment.mkdirIfNotExits(file),
      ProjectWriter.createDrawable(),
      ".xml"
    )
  }

  private fun createNewResource(context: Context, node: TreeNode?, file: File) {
    val labels =
      arrayOf(
        context.getString(R.string.restype_drawable),
        context.getString(R.string.restype_layout),
        context.getString(R.string.restype_menu),
        context.getString(R.string.restype_other)
      )
    val builder = DialogUtils.newMaterialDialogBuilder(context)
    builder.setTitle(R.string.new_xml_resource)
    builder.setItems(labels) { _, position ->
      when (position) {
        0 -> createDrawableRes(context, node, File(file, "drawable"))
        1 -> createLayoutRes(context, node, File(file, "layout"))
        2 -> createMenuRes(context, node, File(file, "menu"))
        3 -> createNewFile(context, node, file, true)
      }
    }
    builder.create().show()
  }

  private fun createNewEmptyFile(context: Context, node: TreeNode?, file: File) {
    createNewFileWithContent(context, node, file, "")
  }

  private fun createNewFileWithContent(
    context: Context,
    node: TreeNode?,
    file: File,
    content: String
  ) {
    createNewFileWithContent(context, node, file, content, null)
  }

  private fun createNewFileWithContent(
    context: Context,
    node: TreeNode?,
    folder: File,
    content: String,
    extension: String?,
  ) {
    val binding = LayoutDialogTextInputBinding.inflate(LayoutInflater.from(context))
    val builder = DialogUtils.newMaterialDialogBuilder(context)
    binding.name.editText!!.setHint(R.string.file_name)
    builder.setTitle(R.string.new_file)
    builder.setMessage(
      context.getString(R.string.msg_can_contain_slashes) +
          "\n\n" +
          context.getString(R.string.msg_newfile_dest, folder.absolutePath)
    )
    builder.setView(binding.root)
    builder.setCancelable(false)
    builder.setPositiveButton(R.string.text_create) { dialogInterface, _ ->
      dialogInterface.dismiss()
      var name = binding.name.editText!!.text.toString().trim()
      if (name.isBlank()) {
        flashError(R.string.msg_invalid_name)
        return@setPositiveButton
      }

      if (extension != null && extension.trim { it <= ' ' }.isNotEmpty()) {
        name = if (name.endsWith(extension)) name else name + extension
      }

      try {
        createFile(context, node, folder, name, content)
      } catch (e: Exception) {
        log.error("Failed to create file", e)
        flashError(e.cause?.message ?: e.message)
      }
    }
    builder.setNegativeButton(android.R.string.cancel, null)
    builder.create().show()
  }

  private fun createFile(
    context: Context,
    node: TreeNode?,
    directory: File,
    name: String,
    content: String
  ): Boolean {
    if (name.length !in 1..40 || name.startsWith("/")) {
      flashError(R.string.msg_invalid_name)
      return false
    }

    val newFile = File(directory, name)
    if (newFile.exists()) {
      flashError(R.string.msg_file_exists)
      return false
    }
    if (!FileIOUtils.writeFileFromString(newFile, content)) {
      flashError(R.string.msg_file_creation_failed)
      return false
    }

    notifyFileCreated(newFile, context)
    // TODO Notify language servers about file created event
    flashSuccess(R.string.msg_file_created)
    if (node != null) {
      val newNode = TreeNode(newFile)
      newNode.viewHolder = FileTreeViewHolder(context)
      node.addChild(newNode)
      requestExpandNode(node)
    } else {
      requestFileListing()
    }

    return true
  }

  private fun notifyFileCreated(file: File, context: Context) {
    EventBus.getDefault().post(FileCreationEvent(file).putData(context))
  }
}



================================================
File: java/com/itsaky/androidide/actions/filetree/NewFolderAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.content.Context
import android.view.LayoutInflater
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireFile
import com.itsaky.androidide.adapters.viewholders.FileTreeViewHolder
import com.itsaky.androidide.preferences.databinding.LayoutDialogTextInputBinding
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import com.unnamed.b.atv.model.TreeNode
import java.io.File

/**
 * File tree action to create a new folder.
 *
 * @author Akash Yadav
 */
class NewFolderAction(context: Context, override val order: Int) :
  BaseDirNodeAction(
    context = context,
    labelRes = R.string.new_folder,
    iconRes = R.drawable.ic_new_folder
  ) {

  override val id: String = "ide.editor.fileTree.newFolder"

  override suspend fun execAction(data: ActionData) {
    val context = data.requireActivity()
    val currentDir = data.requireFile()
    val lastHeld = data.getTreeNode()
    val binding = LayoutDialogTextInputBinding.inflate(LayoutInflater.from(context))
    val builder = DialogUtils.newMaterialDialogBuilder(context)
    binding.name.editText!!.setHint(R.string.folder_name)
    builder.setTitle(R.string.new_folder)
    builder.setMessage(R.string.msg_can_contain_slashes)
    builder.setView(binding.root)
    builder.setCancelable(false)
    builder.setPositiveButton(R.string.text_create) { dialogInterface, _ ->
      dialogInterface.dismiss()
      val name: String = binding.name.editText!!.text.toString().trim()
      if (name.length !in 1..40 || name.startsWith("/")) {
        flashError(R.string.msg_invalid_name)
        return@setPositiveButton
      }

      val newDir = File(currentDir, name)
      if (newDir.exists()) {
        flashError(R.string.msg_folder_exists)
        return@setPositiveButton
      }

      if (!newDir.mkdirs()) {
        flashError(R.string.msg_folder_creation_failed)
        return@setPositiveButton
      }

      flashSuccess(R.string.msg_folder_created)
      if (lastHeld != null) {
        val node = TreeNode(newDir)
        node.viewHolder = FileTreeViewHolder(context)
        lastHeld.addChild(node)
        requestExpandNode(lastHeld)
      } else {
        requestFileListing()
      }
    }
    builder.setNegativeButton(android.R.string.cancel, null)
    builder.create().show()
  }
}



================================================
File: java/com/itsaky/androidide/actions/filetree/OpenWithAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.content.Context
import android.content.Intent
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.actions.requireFile
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.IntentUtils

/**
 * File tree action to open files with external applications.
 *
 * @author Akash Yadav
 */
class OpenWithAction(context: Context, override val order: Int) :
  BaseFileTreeAction(
    context = context,
    labelRes = R.string.open_with,
    iconRes = R.drawable.ic_open_with
  ) {

  override val id: String = "ide.editor.fileTree.openWith"

  override fun prepare(data: ActionData) {
    super.prepare(data)
    
    // Hide "Open with" option for directories
    val file = data.requireFile()
    if (file.isDirectory) {
      markInvisible()
    }
  }

  override suspend fun execAction(data: ActionData) {
    IntentUtils.startIntent(data.requireActivity(), data.requireFile(), "*/*", Intent.ACTION_VIEW)
  }
}



================================================
File: java/com/itsaky/androidide/actions/filetree/RenameAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.filetree

import android.content.Context
import android.view.LayoutInflater
import com.blankj.utilcode.util.FileUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireFile
import com.itsaky.androidide.adapters.viewholders.FileTreeViewHolder
import com.itsaky.androidide.eventbus.events.file.FileRenameEvent
import com.itsaky.androidide.preferences.databinding.LayoutDialogTextInputBinding
import com.itsaky.androidide.projects.FileManager
import com.itsaky.androidide.tasks.launchAsyncWithProgress
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.FlashType
import com.itsaky.androidide.utils.flashMessage
import com.unnamed.b.atv.model.TreeNode
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.greenrobot.eventbus.EventBus
import java.io.File

/**
 * Action to rename the selected file.
 *
 * @author Akash Yadav
 */
class RenameAction(context: Context, override val order: Int) :
  BaseFileTreeAction(
    context,
    labelRes = R.string.rename_file,
    iconRes = R.drawable.ic_file_rename
  ) {

  override val id: String = "ide.editor.fileTree.rename"

  override suspend fun execAction(data: ActionData) {
    val context = data.requireActivity()
    val file = data.requireFile()
    val lastHeld = data.getTreeNode()
    val binding = LayoutDialogTextInputBinding.inflate(LayoutInflater.from(context))
    val builder = DialogUtils.newMaterialDialogBuilder(context)
    binding.name.editText!!.hint =
      context.getString(com.itsaky.androidide.resources.R.string.new_name)
    binding.name.editText!!.setText(file.name)
    builder.setTitle(com.itsaky.androidide.resources.R.string.rename_file)
    builder.setMessage(com.itsaky.androidide.resources.R.string.msg_rename_file)
    builder.setView(binding.root)
    builder.setNegativeButton(android.R.string.cancel, null)
    builder.setPositiveButton(com.itsaky.androidide.resources.R.string.rename_file) {
      dialogInterface,
      _ ->
      dialogInterface.dismiss()
      actionScope.launchAsyncWithProgress(
          configureFlashbar = { builder, cancelChecker ->
            builder.message(com.itsaky.androidide.resources.R.string.please_wait)
          },
          action = { _, _ ->
            val name: String = binding.name.editText!!.text.toString().trim()
            val renamed = name.length in 1..40 && FileUtils.rename(file, name)

            if (renamed) {
              notifyFileRenamed(file, name, context)
            }

            withContext(Dispatchers.Main) {
              flashMessage(
                  if (renamed) com.itsaky.androidide.resources.R.string.renamed
                  else com.itsaky.androidide.resources.R.string.rename_failed,
                  if (renamed) FlashType.SUCCESS else FlashType.ERROR)
              if (!renamed) {
                return@withContext
              }

              if (lastHeld != null) {
                val parent = lastHeld.parent
                parent.deleteChild(lastHeld)
                val node = TreeNode(File(file.parentFile, name))
                node.viewHolder = FileTreeViewHolder(context)
                parent.addChild(node)
                requestExpandNode(parent)
              } else {
                requestFileListing()
              }
            }
          })
    }
    builder.create().show()
  }

  private fun notifyFileRenamed(file: File, name: String, context: Context) {
    val renameEvent = FileRenameEvent(file, File(file.parent, name))

    // Notify FileManager first
    FileManager.onFileRenamed(renameEvent)

    EventBus.getDefault().post(renameEvent.apply { putData(context) })
  }
}



================================================
File: java/com/itsaky/androidide/actions/github/GitHubCommitAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.github

import android.content.Context
import android.view.MenuItem
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.git.GitCommitTask
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.projects.ProjectManagerImpl
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.errors.RepositoryNotFoundException

class GitHubCommitAction(context: Context, override val order: Int) : EditorActivityAction() {
  val context = context

  /**
   * A unique ID for this action.
   */
  override val id: String = "ide.editor.github.commit"

  override var requiresUIThread: Boolean = true

  init {
    label = context.getString(R.string.title_github_commit)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_github)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getActivity() ?: run {
      markInvisible()
      return
    }

    val targetDir = ProjectManagerImpl.getInstance().projectDir
    val git : Git? = try {
      Git.open(targetDir)
    } catch(e : RepositoryNotFoundException) {
      null
    }

    git ?: run {
      markInvisible()
      return
    }


    visible = true

    val projectManager = IProjectManager.getInstance()
    enabled = projectManager.getAndroidAppModules().isNotEmpty()
  }


  /**
   * Execute the action. The action executed in a background thread by default.
   *
   * @param data The data containing various information about the event.
   * @return `true` if this action was executed successfully, `false` otherwise.
   */
  override suspend fun execAction(data: ActionData): Any {
    GitCommitTask.commit(context)
    return true
  }

  override fun getShowAsActionFlags(data: ActionData): Int {
    // prefer showing this in the overflow menu
    return MenuItem.SHOW_AS_ACTION_IF_ROOM
  }
}


================================================
File: java/com/itsaky/androidide/actions/github/GitHubFetchAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.github

import android.content.Context
import android.view.MenuItem
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.git.GitFetchTask
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.projects.ProjectManagerImpl
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.errors.RepositoryNotFoundException


class GitHubFetchAction(context: Context, override val order: Int) : EditorActivityAction() {
  val context = context

  /**
   * A unique ID for this action.
   */
  override val id: String = "ide.editor.github.fetch"

  override var requiresUIThread: Boolean = true

  init {
    label = context.getString(R.string.title_github_fetch)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_github)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getActivity() ?: run {
      markInvisible()
      return
    }
    val targetDir = ProjectManagerImpl.getInstance().projectDir
    val git : Git? = try {
      Git.open(targetDir)
    } catch(e : RepositoryNotFoundException) {
      null
    }

    git ?: run {
      markInvisible()
      return
    }

    visible = true

    val projectManager = IProjectManager.getInstance()
    enabled = projectManager.getAndroidAppModules().isNotEmpty()
  }

  /**
   * Execute the action. The action executed in a background thread by default.
   *
   * @param data The data containing various information about the event.
   * @return `true` if this action was executed successfully, `false` otherwise.
   */
  override suspend fun execAction(data: ActionData): Any {
    GitFetchTask.fetch(context)
    return true
  }

  override fun getShowAsActionFlags(data: ActionData): Int {
    // prefer showing this in the overflow menu
    return MenuItem.SHOW_AS_ACTION_IF_ROOM
  }
}


================================================
File: java/com/itsaky/androidide/actions/github/GitHubPullAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.github

import android.content.Context
import android.view.MenuItem
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.git.GitPullTask
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.projects.ProjectManagerImpl
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.errors.RepositoryNotFoundException

class GitHubPullAction(context: Context, override val order: Int) : EditorActivityAction() {
  val context = context

  /**
   * A unique ID for this action.
   */
  override val id: String = "ide.editor.github.pull"

  override var requiresUIThread: Boolean = true

  init {
    label = context.getString(R.string.title_github_pull)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_github)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getActivity() ?: run {
      markInvisible()
      return
    }
    val targetDir = ProjectManagerImpl.getInstance().projectDir
    val git : Git? = try {
      Git.open(targetDir)
    } catch(e : RepositoryNotFoundException) {
      null
    }

    git ?: run {
      markInvisible()
      return
    }

    visible = true

    val projectManager = IProjectManager.getInstance()
    enabled = projectManager.getAndroidAppModules().isNotEmpty()
  }

  /**
   * Execute the action. The action executed in a background thread by default.
   *
   * @param data The data containing various information about the event.
   * @return `true` if this action was executed successfully, `false` otherwise.
   */
  override suspend fun execAction(data: ActionData): Any {
    GitPullTask.pull(context)
    return true
  }

  override fun getShowAsActionFlags(data: ActionData): Int {
    // prefer showing this in the overflow menu
    return MenuItem.SHOW_AS_ACTION_IF_ROOM
  }
}


================================================
File: java/com/itsaky/androidide/actions/github/GitHubPushAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.github

import android.content.Context
import android.view.MenuItem
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorActivityAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.git.GitCommitTask
import com.itsaky.androidide.git.GitPushTask
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.projects.ProjectManagerImpl
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.errors.RepositoryNotFoundException

class GitHubPushAction(context: Context, override val order: Int) : EditorActivityAction() {
  val context = context

  /**
   * A unique ID for this action.
   */
  override val id: String = "ide.editor.github.push"

  override var requiresUIThread: Boolean = true

  init {
    label = context.getString(R.string.title_github_push)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_github)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)
    data.getActivity() ?: run {
      markInvisible()
      return
    }
    val targetDir = ProjectManagerImpl.getInstance().projectDir
    val git : Git? = try {
      Git.open(targetDir)
    } catch(e : RepositoryNotFoundException) {
      null
    }

    git ?: run {
      markInvisible()
      return
    }

    visible = true

    val projectManager = IProjectManager.getInstance()
    enabled = projectManager.getAndroidAppModules().isNotEmpty()
  }

  /**
   * Execute the action. The action executed in a background thread by default.
   *
   * @param data The data containing various information about the event.
   * @return `true` if this action was executed successfully, `false` otherwise.
   */
  override suspend fun execAction(data: ActionData): Any {
    GitPushTask.push(context)
    return true
  }

  override fun getShowAsActionFlags(data: ActionData): Int {
    // prefer showing this in the overflow menu
    return MenuItem.SHOW_AS_ACTION_IF_ROOM
  }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/AbstractSidebarAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.sidebar

import android.graphics.drawable.Drawable
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.SidebarActionItem

/**
 * @author Akash Yadav
 */
abstract class AbstractSidebarAction : SidebarActionItem {

  // sidebar actions should always be executed on UI thread
  override var requiresUIThread = true
  override var visible = true
  override var enabled = true

  // should never change
  final override var location = ActionItem.Location.EDITOR_SIDEBAR

  // Subclasses should accept a Context in their constructor and initialize these values
  // when the object instance is initialized
  override var icon: Drawable? = null
  override var label: String = ""

  override suspend fun execAction(data: ActionData): Any {
    return false
  }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/BuildVariantsSidebarAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.sidebar

import android.content.Context
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import com.itsaky.androidide.fragments.sidebar.BuildVariantsFragment
import kotlin.reflect.KClass

/**
 * Sidebar action for showing the build variants of Android modules in the project.
 *
 * @author Akash Yadav
 */
class BuildVariantsSidebarAction(context: Context, override val order: Int) :
  AbstractSidebarAction() {

  override val fragmentClass: KClass<out Fragment> = BuildVariantsFragment::class
  override val id: String = "ide.editor.sidebar.buildVariants"

  init {
    label = context.getString(R.string.title_build_variants)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_android)
  }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/CloseProjectSidebarAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.sidebar

import android.content.Context
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.activities.editor.BaseEditorActivity
import com.itsaky.androidide.resources.R
import kotlin.reflect.KClass

/**
 * Sidebar action for closing the project.
 *
 * @author Akash Yadav
 */
class CloseProjectSidebarAction(context: Context, override val order: Int) :
  AbstractSidebarAction() {

  override val id: String = "ide.editor.sidebar.closeProject"
  override val fragmentClass: KClass<out Fragment>? = null

  init {
    label = context.getString(R.string.title_close_project)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_folder_close)
  }

  override suspend fun execAction(data: ActionData): Any {
    val context = data.requireContext() as BaseEditorActivity
    context.doConfirmProjectClose()
    return true
  }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/EmailSideBarAction.kt
================================================
package com.itsaky.androidide.actions.sidebar

import android.content.Context
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.utils.EditorSidebarActions
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlin.reflect.KClass

class EmailSidebarAction(context: Context, override val order: Int) : AbstractSidebarAction() {

    override val id: String = "ide.editor.sidebar.email"

    override val fragmentClass: KClass<out Fragment>? = null

    init {
        label = "email"
        icon = ContextCompat.getDrawable(context, R.drawable.ic_mail_24_outlined)
    }

    override suspend fun execAction(data: ActionData): Any {
        val context = data.requireContext()
        withContext(Dispatchers.Main) {
            EditorSidebarActions.showContactDialog(context)
        }
        return Unit
    }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/FileTreeSidebarAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.sidebar

import android.content.Context
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import com.itsaky.androidide.fragments.sidebar.FileTreeFragment
import kotlin.reflect.KClass

/**
 * Sidebar action for showing file tree.
 *
 * @author Akash Yadav
 */
class FileTreeSidebarAction(context: Context, override val order: Int) : AbstractSidebarAction() {

  companion object {
    const val ID ="ide.editor.sidebar.fileTree"
  }

  override val id: String = ID
  override val fragmentClass: KClass<out Fragment> = FileTreeFragment::class

  init {
    label = context.getString(R.string.msg_file_tree)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_folder)
  }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/GitSidebarAction.kt
================================================
package com.itsaky.androidide.actions.sidebar

import android.content.Context
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import com.itsaky.androidide.fragments.sidebar.GitFragmentContainer
import kotlin.reflect.KClass

/**
 * Sidebar action for showing the build variants of Android modules in the project.
 *
 * @author Akash Yadav
 */
class GitSidebarAction(context: Context, override val order: Int) :
    AbstractSidebarAction() {

    override val fragmentClass: KClass<out Fragment> = GitFragmentContainer::class
    override val id: String = "ide.editor.sidebar.git"

    init {
        label = context.getString(R.string.title_build_variants)
        icon = ContextCompat.getDrawable(context, R.drawable.ic_git)
    }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/HelpSideBarAction.kt
================================================
package com.itsaky.androidide.actions.sidebar

/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

import android.content.Context
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.activities.editor.BaseEditorActivity
import com.itsaky.androidide.resources.R
import kotlin.reflect.KClass

/**
 * Sidebar action for opening the help section.
 *
 * @author Daniel Alome
 */
class HelpSideBarAction(context: Context, override val order: Int) :
    AbstractSidebarAction() {

    override val id: String = "ide.editor.sidebar.help"
    override val fragmentClass: KClass<out Fragment>? = null

    init {
        label = context.getString(R.string.action_open_help)
        icon = ContextCompat.getDrawable(context, R.drawable.ic_action_help_outlined)
    }

    override suspend fun execAction(data: ActionData): Any {
        val context = data.requireContext() as BaseEditorActivity
        context.doOpenHelp()
        return true
    }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/PreferencesSidebarAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.sidebar

import android.content.Context
import android.content.Intent
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.activities.PreferencesActivity
import kotlin.reflect.KClass

/**
 * A sidebar action to navigate the user to IDE Preferences.
 *
 * @author Akash Yadav
 */
class PreferencesSidebarAction(context: Context, override val order: Int) : AbstractSidebarAction() {

  override val id: String = "ide.editor.sidebar.preferences"

  // TODO : Should we show the preferences in the sidebar itself?
  override val fragmentClass: KClass<out Fragment>? = null

  init {
    label = context.getString(R.string.ide_preferences)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_settings)
  }

  override suspend fun execAction(data: ActionData): Any {
    val context = data.requireContext()
    return context.startActivity(Intent(context, PreferencesActivity::class.java))
  }
}


================================================
File: java/com/itsaky/androidide/actions/sidebar/TerminalSidebarAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.sidebar

import android.content.Context
import android.content.Intent
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.requireContext
import com.itsaky.androidide.activities.TerminalActivity
import com.itsaky.androidide.projects.IProjectManager
import com.termux.shared.termux.TermuxConstants.TERMUX_APP.TERMUX_ACTIVITY
import java.util.Objects
import kotlin.reflect.KClass

/**
 * Sidebar action for opening the terminal.
 *
 * @author Akash Yadav
 */
class TerminalSidebarAction(context: Context, override val order: Int) : AbstractSidebarAction() {

  override val id: String = ID
  override val fragmentClass: KClass<out Fragment>? = null

  init {
    label = context.getString(R.string.title_terminal)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_terminal)
  }

  companion object {

    const val ID = "ide.editor.sidebar.terminal"

    fun startTerminalActivity(data: ActionData, isFailsafe: Boolean) {
      val context = data.requireContext()
      val intent = Intent(context, TerminalActivity::class.java).apply {
        putExtra(
          TERMUX_ACTIVITY.EXTRA_SESSION_WORKING_DIR,
          Objects.requireNonNull(IProjectManager.getInstance().projectDirPath)
        )
        putExtra(
          TERMUX_ACTIVITY.EXTRA_SESSION_NAME,
          IProjectManager.getInstance().rootProject?.rootProject?.name
        )
        putExtra(TERMUX_ACTIVITY.EXTRA_FAILSAFE_SESSION, isFailsafe)
      }
      context.startActivity(intent)
    }
  }

  override suspend fun execAction(data: ActionData): Any {
    startTerminalActivity(data, false)
    return true
  }
}


================================================
File: java/com/itsaky/androidide/actions/text/RedoAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.text

import android.app.Activity
import android.content.Context
import android.view.MenuItem
import androidx.core.content.ContextCompat
import com.blankj.utilcode.util.KeyboardUtils
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.actions.markInvisible
import com.itsaky.androidide.resources.R

/** @author Akash Yadav */
class RedoAction(context: Context, override val order: Int) : EditorRelatedAction() {

  init {
    label = context.getString(R.string.redo)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_redo)
  }

  override val id: String = "ide.editor.code.text.redo"

  override fun prepare(data: ActionData) {
    super.prepare(data)

    if (!visible) {
      return
    }

    val editor = data.getEditor() ?: run {
      markInvisible()
      return
    }

    enabled = editor.canRedo()
  }

  override suspend fun execAction(data: ActionData): Boolean {
    val editor = data.getEditor() ?: run {
      markInvisible()
      return false
    }

    editor.redo()
    data.getActivity()?.invalidateOptionsMenu()
    return true
  }

  override fun getShowAsActionFlags(data: ActionData): Int {
    return if (KeyboardUtils.isSoftInputVisible(data.get(Context::class.java) as Activity)) {
      MenuItem.SHOW_AS_ACTION_IF_ROOM
    } else {
      MenuItem.SHOW_AS_ACTION_NEVER
    }
  }
}



================================================
File: java/com/itsaky/androidide/actions/text/UndoAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.actions.text

import android.content.Context
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.EditorRelatedAction
import com.itsaky.androidide.resources.R

/** @author Akash Yadav */
class UndoAction(context: Context, override val order: Int) : EditorRelatedAction() {

  override val id: String = "ide.editor.code.text.undo"

  init {
    label = context.getString(R.string.undo)
    icon = ContextCompat.getDrawable(context, R.drawable.ic_undo)
  }

  override fun prepare(data: ActionData) {
    super.prepare(data)

    if (!visible) {
      return
    }

    val editor = data.getEditor()!!
    enabled = editor.canUndo()
  }

  override suspend fun execAction(data: ActionData): Any {
    val editor = data.getEditor()
    return if (editor != null) {
      editor.undo()
      data.getActivity()?.invalidateOptionsMenu()
      true
    } else {
      false
    }
  }
}



================================================
File: java/com/itsaky/androidide/activities/AboutActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.activities

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.text.SpannableStringBuilder
import android.text.style.ForegroundColorSpan
import android.view.View
import androidx.annotation.ColorInt
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.core.content.ContextCompat
import androidx.core.graphics.Insets
import androidx.core.view.updatePaddingRelative
import com.blankj.utilcode.util.ClipboardUtils
import com.blankj.utilcode.util.SizeUtils
import com.itsaky.androidide.BuildConfig
import com.itsaky.androidide.R
import com.itsaky.androidide.adapters.SimpleIconTitleDescriptionAdapter
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.app.EdgeToEdgeIDEActivity
import com.itsaky.androidide.app.configuration.IDEBuildConfigProvider
import com.itsaky.androidide.buildinfo.BuildInfo
import com.itsaky.androidide.databinding.ActivityAboutBinding
import com.itsaky.androidide.models.IconTitleDescriptionItem
import com.itsaky.androidide.models.SimpleIconTitleDescriptionItem
import com.itsaky.androidide.utils.BuildInfoUtils
import com.itsaky.androidide.utils.flashSuccess
import com.itsaky.androidide.utils.resolveAttr

class AboutActivity : EdgeToEdgeIDEActivity() {

  private var _binding: ActivityAboutBinding? = null
  private val binding: ActivityAboutBinding
    get() = checkNotNull(_binding) {
      "Activity has been destroyed"
    }

  override fun bindLayout(): View {
    _binding = ActivityAboutBinding.inflate(layoutInflater)
    return _binding!!.root
  }

  companion object {

    private var id = 0
    private val ACTION_WEBSITE = id++
    private val ACTION_EMAIL = id++
    private val ACTION_TG_CHANNEL = id++
    private val ACTION_TG_GROUP = id++
    private val ACTION_CONTRIBUTE = id++
    private val ACTION_CONTRIBUTORS = id++
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding.apply {

      setSupportActionBar(toolbar)
      supportActionBar!!.setDisplayHomeAsUpEnabled(true)
      supportActionBar!!.setTitle(R.string.about)
      toolbar.setNavigationOnClickListener { onBackPressedDispatcher.onBackPressed() }

      aboutHeader.apply {
        ideVersion.text = createVersionText()
        ideVersion.isClickable = true
        ideVersion.isFocusable = true
        ideVersion.setBackgroundResource(R.drawable.bg_ripple)
        ideVersion.setOnClickListener {
          ClipboardUtils.copyText(BuildInfoUtils.getBuildInfoHeader())
          flashSuccess(R.string.copied)
        }
      }

      socials.apply {
        sectionTitle.setText(R.string.title_socials)
        sectionItems.adapter = AboutSocialItemsAdapter(createSocialItems(), ::handleActionClick)
      }

      misc.apply {
        sectionTitle.setText(R.string.title_misc)
        sectionItems.adapter = AboutSocialItemsAdapter(createMiscItems(), ::handleActionClick)
      }
    }
  }

  override fun onApplySystemBarInsets(insets: Insets) {
    binding.toolbar.apply {
      setPaddingRelative(
        paddingStart + insets.left,
        paddingTop,
        paddingEnd + insets.right,
        paddingBottom
      )
    }
  }

  private fun handleActionClick(action: SimpleIconTitleDescriptionItem) {
    when (action.id) {
      ACTION_WEBSITE -> app.openWebsite()
      ACTION_EMAIL -> app.emailUs()
      ACTION_TG_GROUP -> app.openTelegramGroup()
      ACTION_TG_CHANNEL -> app.openTelegramChannel()
      ACTION_CONTRIBUTE -> app.openUrl(BaseApplication.CONTRIBUTOR_GUIDE_URL)
      ACTION_CONTRIBUTORS -> startActivity(Intent(this, ContributorsActivity::class.java))
    }
  }

  private fun createSocialItems(): List<IconTitleDescriptionItem> {
    return mutableListOf<IconTitleDescriptionItem>().apply {
      add(
        createSimpleIconTextItem(
          this@AboutActivity,
          ACTION_WEBSITE,
          R.drawable.ic_website,
          R.string.about_option_website,
          BuildInfo.PROJECT_SITE
        )
      )
      add(
        createSimpleIconTextItem(
          this@AboutActivity,
          ACTION_EMAIL,
          R.drawable.ic_email,
          R.string.about_option_email,
          BaseApplication.EMAIL
        )
      )
      add(
        createSimpleIconTextItem(
          this@AboutActivity,
          ACTION_TG_GROUP,
          R.drawable.ic_telegram,
          R.string.discussions_on_telegram,
          BaseApplication.TELEGRAM_GROUP_URL
        )
      )
      add(
        createSimpleIconTextItem(
          this@AboutActivity,
          ACTION_TG_CHANNEL,
          R.drawable.ic_telegram,
          R.string.official_tg_channel,
          BaseApplication.TELEGRAM_CHANNEL_URL
        )
      )
    }
  }

  private fun createMiscItems(): List<IconTitleDescriptionItem> {
    return mutableListOf<IconTitleDescriptionItem>().apply {
      add(
        SimpleIconTitleDescriptionItem.create(
          this@AboutActivity,
          ACTION_CONTRIBUTE,
          R.drawable.ic_code,
          R.string.title_contribute,
          R.string.summary_contribute
        )
      )
      add(
        SimpleIconTitleDescriptionItem.create(
          this@AboutActivity,
          ACTION_CONTRIBUTORS,
          R.drawable.ic_heart_outline,
          R.string.title_contributors,
          R.string.summary_contributors
        )
      )
    }
  }

  private fun createSimpleIconTextItem(
    context: Context,
    id: Int,
    @DrawableRes icon: Int,
    @StringRes title: Int,
    description: CharSequence
  ): SimpleIconTitleDescriptionItem {
    return SimpleIconTitleDescriptionItem(
      id,
      ContextCompat.getDrawable(context, icon),
      ContextCompat.getString(context, title),
      description
    )
  }

  /**
   * Create the version name string that should be displayed to the user.
   *
   * Format of the version name string is :
   *
   * `v[version-name]-[variant] ([build-type]/[[UN]OFFICIAL])`
   */
  @Suppress("KDocUnresolvedReference")
  private fun createVersionText(): CharSequence {
    val builder = SpannableStringBuilder()
    builder.append("v")
    builder.append(BuildInfo.VERSION_NAME_SIMPLE)
    builder.append("-")
    builder.append(IDEBuildConfigProvider.getInstance().cpuAbiName)
    builder.append(" ")

    val colorPositive = ContextCompat.getColor(this, R.color.color_success)
    val colorNegative = ContextCompat.getColor(this, R.color.color_error)

    appendBuildType(builder, colorPositive, colorNegative)

    return builder
  }

  private fun appendBuildType(
    builder: SpannableStringBuilder,
    @ColorInt
    colorPositive: Int,
    @ColorInt
    colorNegative: Int
  ) {
    @Suppress("KotlinConstantConditions")
    var color = if (BuildConfig.BUILD_TYPE != "release") {
      colorNegative
    } else {
      colorPositive
    }

    builder.append("(")
    appendForegroundSpan(builder, BuildConfig.BUILD_TYPE, color)

    val isOfficialBuild = BuildInfoUtils.isOfficialBuild(this)

    color = if (isOfficialBuild) {
      colorPositive
    } else {
      colorNegative
    }

    builder.append("/")
    appendForegroundSpan(
      builder,
      BuildInfoUtils.getBuildType(this).lowercase(),
      color
    )

    builder.append(")")
  }

  private fun appendForegroundSpan(
    builder: SpannableStringBuilder,
    text: CharSequence,
    color: Int
  ) {
    builder.append(
      text,
      ForegroundColorSpan(color),
      SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE
    )
  }

  override fun onDestroy() {
    super.onDestroy()
    _binding = null
  }

  class AboutSocialItemsAdapter(
    items: List<IconTitleDescriptionItem>,
    private val onClickListener: (SimpleIconTitleDescriptionItem) -> Unit
  ) : SimpleIconTitleDescriptionAdapter(items) {

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
      super.onBindViewHolder(holder, position)
      val binding = holder.binding
      val item = getItem(position) as SimpleIconTitleDescriptionItem
      val dp8 = SizeUtils.dp2px(8f)
      binding.icon.updatePaddingRelative(dp8, dp8, dp8, dp8)
      binding.title.setTextAppearance(R.style.TextAppearance_Material3_TitleSmall)

      binding.description.maxLines = 3
      binding.description.setTextAppearance(R.style.TextAppearance_Material3_BodySmall)
      binding.description.setTextColor(binding.description.context.resolveAttr(R.attr.colorPrimary))

      binding.root.isClickable = true
      binding.root.isFocusable = true
      binding.root.setBackgroundResource(R.drawable.bg_ripple)
      binding.root.setOnClickListener {
        onClickListener(item)
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/activities/ContributorsActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities

import android.os.Bundle
import android.view.View
import androidx.activity.viewModels
import androidx.core.graphics.Insets
import androidx.core.view.isVisible
import com.itsaky.androidide.R
import com.itsaky.androidide.adapters.ContributorsGridAdapter
import com.itsaky.androidide.app.EdgeToEdgeIDEActivity
import com.itsaky.androidide.databinding.ActivityContributorsBinding
import com.itsaky.androidide.utils.getConnectionInfo
import com.itsaky.androidide.viewmodel.ContributorsViewModel

/**
 * @author Akash Yadav
 */
class ContributorsActivity : EdgeToEdgeIDEActivity() {

  private var _binding: ActivityContributorsBinding? = null
  private val binding: ActivityContributorsBinding
    get() = checkNotNull(_binding) {
      "Activity has been destroyed"
    }

  private val viewModel by viewModels<ContributorsViewModel>()

  override fun bindLayout(): View {
    _binding = ActivityContributorsBinding.inflate(layoutInflater)
    return binding.root
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding.apply {
      setSupportActionBar(toolbar)
      supportActionBar!!.setTitle(R.string.title_contributors)
      supportActionBar!!.setDisplayHomeAsUpEnabled(true)
      toolbar.setNavigationOnClickListener { onBackPressedDispatcher.onBackPressed() }

      githubContributors.apply {
        sectionTitle.setText(R.string.title_github_contributors)
      }

      translationContributors.apply {
        sectionTitle.setText(R.string.title_crowdin_translators)
      }

      noConnection.root.setText(R.string.msg_no_internet)
      loadingProgress.isVisible = false
    }

    viewModel._crowdinTranslators.observe(this) { translators ->
      binding.translationContributors.sectionItems.adapter = ContributorsGridAdapter(translators)
    }

    viewModel._githubContributors.observe(this) { githubContributors ->
      binding.githubContributors.sectionItems.adapter = ContributorsGridAdapter(githubContributors)
    }

    val connectionInfo = getConnectionInfo(this)
    binding.apply {
      noConnection.root.isVisible = !connectionInfo.isConnected
      githubContributorsCard.isVisible = connectionInfo.isConnected
      translationContributorsCard.isVisible = connectionInfo.isConnected

      if (connectionInfo.isConnected) {
        viewModel.observeLoadingState(this@ContributorsActivity) { isLoading ->
          binding.loadingProgress.isVisible = isLoading
        }

        viewModel.fetchAll()
      }
    }
  }

  override fun onApplySystemBarInsets(insets: Insets) {
    super.onApplySystemBarInsets(insets)
    binding.toolbar.apply {
      setPaddingRelative(
        paddingStart + insets.left,
        paddingTop,
        paddingEnd + insets.right,
        paddingBottom
      )
    }
  }

  override fun onDestroy() {
    super.onDestroy()
    _binding = null
  }

}


================================================
File: java/com/itsaky/androidide/activities/CrashHandlerActivity.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities;

import android.os.Bundle;
import android.view.View;
import androidx.annotation.NonNull;
import com.itsaky.androidide.app.IDEActivity;
import com.itsaky.androidide.databinding.ActivityCrashHandlerBinding;
import com.itsaky.androidide.fragments.CrashReportFragment;

public class CrashHandlerActivity extends IDEActivity {

  public static final String REPORT_ACTION = "com.itsaky.androidide.REPORT_CRASH";
  public static final String TRACE_KEY = "crash_trace";
  private ActivityCrashHandlerBinding binding;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    final var extra = getIntent().getExtras();
    if (extra == null) {
      finishAffinity();
      return;
    }

    final var report = extra.getString(TRACE_KEY, "Unable to get logs.");
    final var fragment = CrashReportFragment.newInstance(report);

    getSupportFragmentManager()
        .beginTransaction()
        .replace(binding.getRoot().getId(), fragment, "crash_report_fragment")
        .addToBackStack(null)
        .commit();
  }

  @Override
  @NonNull
  protected View bindLayout() {
    binding = ActivityCrashHandlerBinding.inflate(getLayoutInflater());
    return binding.getRoot();
  }

  @Override
  protected void onDestroy() {
    super.onDestroy();
    binding = null;
  }
}



================================================
File: java/com/itsaky/androidide/activities/MainActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities

import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.text.TextUtils
import android.util.Log
import android.view.View
import androidx.activity.OnBackPressedCallback
import androidx.activity.viewModels
import androidx.core.graphics.Insets
import androidx.core.view.isVisible
import androidx.transition.TransitionManager
import androidx.transition.doOnEnd
import com.google.android.material.transition.MaterialSharedAxis
import com.itsaky.androidide.activities.editor.EditorActivityKt
import com.itsaky.androidide.app.EdgeToEdgeIDEActivity
import com.itsaky.androidide.databinding.ActivityMainBinding
import com.itsaky.androidide.preferences.internal.GeneralPreferences
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.resources.R.string
import com.itsaky.androidide.templates.ITemplateProvider
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.flashInfo
import com.itsaky.androidide.viewmodel.MainViewModel
import com.itsaky.androidide.viewmodel.MainViewModel.Companion.SCREEN_DELETE_PROJECTS
import com.itsaky.androidide.viewmodel.MainViewModel.Companion.SCREEN_MAIN
import com.itsaky.androidide.viewmodel.MainViewModel.Companion.SCREEN_SAVED_PROJECTS
import com.itsaky.androidide.viewmodel.MainViewModel.Companion.SCREEN_TEMPLATE_DETAILS
import com.itsaky.androidide.viewmodel.MainViewModel.Companion.SCREEN_TEMPLATE_LIST
import com.itsaky.androidide.viewmodel.MainViewModel.Companion.TOOLTIPS_WEB_VIEW
import org.appdevforall.localwebserver.WebServer
import org.appdevforall.localwebserver.ServerConfig
import com.itsaky.androidide.utils.Environment

import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream

import android.hardware.display.DisplayManager
import android.view.Display

class MainActivity : EdgeToEdgeIDEActivity() {

    private val DATABASENAME = "documentation.db"
    private val TAG = "MainActivity"

    private val viewModel by viewModels<MainViewModel>()
    private var _binding: ActivityMainBinding? = null

    companion object {
        private var instance: MainActivity? = null

        // This method will be used to get access to MainActivity instance
        fun getInstance(): MainActivity? {
            return instance
        }
    }

    private val onBackPressedCallback = object : OnBackPressedCallback(true) {
        override fun handleOnBackPressed() {
            viewModel.apply {

                // Ignore back press if project creating is in progress
                if (creatingProject.value == true) {
                    return@apply
                }

                val newScreen = when (currentScreen.value) {
                    SCREEN_TEMPLATE_DETAILS -> SCREEN_TEMPLATE_LIST
                    SCREEN_TEMPLATE_LIST -> SCREEN_MAIN
                    else -> SCREEN_MAIN
                }

                if (currentScreen.value != newScreen) {
                    setScreen(newScreen)
                }
            }
        }
    }

    private val binding: ActivityMainBinding
        get() = checkNotNull(_binding)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Start WebServer after installation is complete
        startWebServer()
        
        openLastProject()
        setupSecondaryDisplay()

        viewModel.currentScreen.observe(this) { screen ->
            if (screen == -1) {
                return@observe
            }

            onScreenChanged(screen)
            onBackPressedCallback.isEnabled = screen != SCREEN_MAIN
        }

        // Data in a ViewModel is kept between activity rebuilds on
        // configuration changes (i.e. screen rotation)
        // * previous == -1 and current == -1 -> this is an initial instantiation of the activity
        if (viewModel.currentScreen.value == -1 && viewModel.previousScreen == -1) {
            viewModel.setScreen(SCREEN_MAIN)
        } else {
            onScreenChanged(viewModel.currentScreen.value)
        }

        onBackPressedDispatcher.addCallback(this, onBackPressedCallback)
        instance = this
    }

    override fun onApplySystemBarInsets(insets: Insets) {
        binding.fragmentContainersParent.setPadding(
            insets.left, 0, insets.right, insets.bottom
        )
    }

    private fun onScreenChanged(screen: Int?) {
        val previous = viewModel.previousScreen
        if (previous != -1) {
            closeKeyboard()

            // template list -> template details
            // ------- OR -------
            // template details -> template list
            val setAxisToX =
                (previous == SCREEN_TEMPLATE_LIST || previous == SCREEN_TEMPLATE_DETAILS) && (screen == SCREEN_TEMPLATE_LIST || screen == SCREEN_TEMPLATE_DETAILS)

            val axis = if (setAxisToX) {
                MaterialSharedAxis.X
            } else {
                MaterialSharedAxis.Y
            }

            val isForward = (screen ?: 0) - previous == 1

            val transition = MaterialSharedAxis(axis, isForward)
            transition.doOnEnd {
                viewModel.isTransitionInProgress = false
                onBackPressedCallback.isEnabled = viewModel.currentScreen.value != SCREEN_MAIN
            }

            viewModel.isTransitionInProgress = true
            TransitionManager.beginDelayedTransition(binding.root, transition)
        }

        val currentFragment = when (screen) {
            SCREEN_MAIN -> binding.main
            SCREEN_TEMPLATE_LIST -> binding.templateList
            SCREEN_TEMPLATE_DETAILS -> binding.templateDetails
            TOOLTIPS_WEB_VIEW -> binding.tooltipWebView
            SCREEN_SAVED_PROJECTS -> binding.savedProjectsView
            SCREEN_DELETE_PROJECTS -> binding.deleteProjectsView
            else -> throw IllegalArgumentException("Invalid screen id: '$screen'")
        }

        for (fragment in arrayOf(
            binding.main,
            binding.templateList,
            binding.templateDetails,
            binding.tooltipWebView,
            binding.savedProjectsView,
            binding.deleteProjectsView,
        )) {
            fragment.isVisible = fragment == currentFragment
        }
    }

    override fun bindLayout(): View {
        _binding = ActivityMainBinding.inflate(layoutInflater)
        return binding.root
    }

    private fun openLastProject() {
        binding.root.post { tryOpenLastProject() }
    }

    private fun tryOpenLastProject() {
        if (!GeneralPreferences.autoOpenProjects) {
            return
        }

        val openedProject = GeneralPreferences.lastOpenedProject
        if (GeneralPreferences.NO_OPENED_PROJECT == openedProject) {
            return
        }

        if (TextUtils.isEmpty(openedProject)) {
            app
            flashInfo(string.msg_opened_project_does_not_exist)
            return
        }

        val project = File(openedProject)
        if (!project.exists()) {
            flashInfo(string.msg_opened_project_does_not_exist)
            return
        }

        if (GeneralPreferences.confirmProjectOpen) {
            askProjectOpenPermission(project)
            return
        }

        openProject(project)
    }

    private fun askProjectOpenPermission(root: File) {
        val builder = DialogUtils.newMaterialDialogBuilder(this)
        builder.setTitle(string.title_confirm_open_project)
        builder.setMessage(getString(string.msg_confirm_open_project, root.absolutePath))
        builder.setCancelable(false)
        builder.setPositiveButton(string.yes) { _, _ -> openProject(root) }
        builder.setNegativeButton(string.no, null)
        builder.show()
    }

    internal fun openProject(root: File) {
        ProjectManagerImpl.getInstance().projectPath = root.absolutePath

        val intent = Intent(this, EditorActivityKt::class.java).apply {
            putExtra("PROJECT_PATH", root.absolutePath)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
        }

        startActivity(intent)
    }

    internal fun deleteProject(root: File) {
        ProjectManagerImpl.getInstance().projectPath = root.absolutePath
        try {
            val directory = File(ProjectManagerImpl.getInstance().projectPath)
            val parentDir = directory.parent
            deleteRecursive(directory)
        } catch (e: Exception) {
            flashInfo(string.msg_delete_existing_project_failed)
        }
    }

    fun deleteRecursive(fileOrDirectory: File) {
        if (fileOrDirectory.isDirectory) for (child in fileOrDirectory.listFiles()) deleteRecursive(
            child
        )

        fileOrDirectory.delete()
    }

    private fun startWebServer() {
        try {
            val dbFile = Environment.DOC_DB
            
            if (!dbFile.exists()) {
                Log.w(TAG, "Database file not found at: ${dbFile.absolutePath} - WebServer will not start")
                return
            }
            
            Log.i(TAG, "Starting WebServer - database file exists at: ${dbFile.absolutePath}")
            val webServer = WebServer(ServerConfig(databasePath = dbFile.absolutePath))
            Thread { webServer.start() }.start()
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start WebServer", e)
        }
    }

    override fun onDestroy() {
        ITemplateProvider.getInstance().release()
        super.onDestroy()
        _binding = null
    }

    private fun setupSecondaryDisplay() {
        val displayManager = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        val displays = displayManager.displays

        val secondDisplay = displays.firstOrNull { display ->
            display.displayId != Display.DEFAULT_DISPLAY
        }
        secondDisplay?.let {
            val presentation = SecondaryScreen(this, it)
            presentation.show()
        }
    }
}



================================================
File: java/com/itsaky/androidide/activities/OnboardingActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities

import android.annotation.SuppressLint
import android.content.Intent
import android.content.pm.ActivityInfo
import android.os.Bundle
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.github.appintro.AppIntro2
import com.github.appintro.AppIntroPageTransformerType
import com.itsaky.androidide.R
import com.itsaky.androidide.R.string
import com.itsaky.androidide.app.configuration.IDEBuildConfigProvider
import com.itsaky.androidide.app.configuration.IJdkDistributionProvider
import com.itsaky.androidide.fragments.onboarding.GreetingFragment
import com.itsaky.androidide.fragments.onboarding.IdeSetupConfigurationFragment
import com.itsaky.androidide.fragments.onboarding.OnboardingInfoFragment
import com.itsaky.androidide.fragments.onboarding.PermissionsFragment
import com.itsaky.androidide.fragments.onboarding.StatisticsFragment
import com.itsaky.androidide.models.JdkDistribution
import com.itsaky.androidide.preferences.internal.prefManager
import com.itsaky.androidide.tasks.launchAsyncWithProgress
import com.itsaky.androidide.ui.themes.IThemeManager
import com.itsaky.androidide.utils.AssetsInstallationHelper
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.OrientationUtilities
import com.itsaky.androidide.utils.withStopWatch
import com.termux.shared.android.PackageUtils
import com.termux.shared.markdown.MarkdownUtils
import com.termux.shared.termux.TermuxConstants
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory

class OnboardingActivity : AppIntro2() {

    private val activityScope =
        CoroutineScope(Dispatchers.Main + CoroutineName("OnboardingActivity"))

    private var listJdkInstallationsJob: Job? = null

    companion object {
        private val logger = LoggerFactory.getLogger(OnboardingActivity::class.java)
        private const val KEY_ARCHCONFIG_WARNING_IS_SHOWN =
            "ide.archConfig.experimentalWarning.isShown"
    }

    @SuppressLint("SourceLockedOrientationActivity")
    override fun onCreate(savedInstanceState: Bundle?) {
        IThemeManager.getInstance().applyTheme(this)
        setOrientationFunction {
            OrientationUtilities.setOrientation {
                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
            }
        }
        super.onCreate(savedInstanceState)

        if (tryNavigateToMainIfSetupIsCompleted()) {
            return
        }

        setSwipeLock(true)
        setTransformer(AppIntroPageTransformerType.Fade)
        setProgressIndicator()
        showStatusBar(true)
        isIndicatorEnabled = true
        isWizardMode = true

        addSlide(GreetingFragment())

        if (!PackageUtils.isCurrentUserThePrimaryUser(this)) {
            val errorMessage = getString(
                string.bootstrap_error_not_primary_user_message,
                MarkdownUtils.getMarkdownCodeForString(
                    TermuxConstants.TERMUX_PREFIX_DIR_PATH,
                    false
                )
            )
            addSlide(
                OnboardingInfoFragment.newInstance(
                    getString(string.title_unsupported_user),
                    errorMessage,
                    R.drawable.ic_alert,
                    ContextCompat.getColor(this, R.color.color_error)
                )
            )
            return
        }

        if (isInstalledOnSdCard()) {
            val errorMessage = getString(
                string.bootstrap_error_installed_on_portable_sd,
                MarkdownUtils.getMarkdownCodeForString(
                    TermuxConstants.TERMUX_PREFIX_DIR_PATH,
                    false
                )
            )
            addSlide(
                OnboardingInfoFragment.newInstance(
                    getString(string.title_install_location_error),
                    errorMessage,
                    R.drawable.ic_alert,
                    ContextCompat.getColor(this, R.color.color_error)
                )
            )
            return
        }

        if (!checkDeviceSupported()) {
            return
        }

        if (!PermissionsFragment.areAllPermissionsGranted(this)) {
            addSlide(PermissionsFragment.newInstance(this))
        }

        if (!checkToolsIsInstalled()) {
            addSlide(IdeSetupConfigurationFragment.newInstance(this))
        }
    }

    override fun onResume() {
        super.onResume()
        reloadJdkDistInfo {
            tryNavigateToMainIfSetupIsCompleted()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        activityScope.cancel("Activity is being destroyed")
    }

    override fun onNextPressed(currentFragment: Fragment?) {
        (currentFragment as? StatisticsFragment?)?.updateStatOptInStatus()
    }

    override fun onDonePressed(currentFragment: Fragment?) {
        (currentFragment as? StatisticsFragment?)?.updateStatOptInStatus()

        if (!IDEBuildConfigProvider.getInstance().supportsCpuAbi()) {
            finishAffinity()
            return
        }

        if (!checkToolsIsInstalled() && currentFragment is IdeSetupConfigurationFragment) {
            activityScope.launchAsyncWithProgress(Dispatchers.IO) { flashbar, cancelChecker ->
                runOnUiThread {
                    flashbar.flashbarView.setTitle(getString(R.string.ide_setup_in_progress))
                }

                val result = withStopWatch("Assets installation") {
                    AssetsInstallationHelper.install(this@OnboardingActivity) { progress ->
                        logger.debug("Assets installation progress: {}", progress.message)
                    }
                }

                logger.info("Assets installation result: {}", result)

                withContext(Dispatchers.Main) {
                    reloadJdkDistInfo {
                        tryNavigateToMainIfSetupIsCompleted()
                    }
                }
            }
            return
        }

        tryNavigateToMainIfSetupIsCompleted()
    }

    private fun checkToolsIsInstalled(): Boolean {
        return IJdkDistributionProvider.getInstance().installedDistributions.isNotEmpty()
                && Environment.ANDROID_HOME.exists()
    }

    private fun isSetupCompleted(): Boolean {
        return checkToolsIsInstalled()
                && PermissionsFragment.areAllPermissionsGranted(this)
    }

    private fun tryNavigateToMainIfSetupIsCompleted(): Boolean {
        if (isSetupCompleted()) {
            startActivity(Intent(this, MainActivity::class.java))
            finish()
            return true
        }

        return false
    }

    private inline fun reloadJdkDistInfo(crossinline distConsumer: (List<JdkDistribution>) -> Unit) {
        listJdkInstallationsJob?.cancel("Reloading JDK distributions")

        listJdkInstallationsJob = activityScope.launchAsyncWithProgress(Dispatchers.Default,
            configureFlashbar = { builder, _ ->
                builder.message(string.please_wait)
            }) { _, _ ->
            val distributionProvider = IJdkDistributionProvider.getInstance()
            distributionProvider.loadDistributions()
            withContext(Dispatchers.Main) {
                distConsumer(distributionProvider.installedDistributions)
            }
        }.also {
            it?.invokeOnCompletion {
                listJdkInstallationsJob = null
            }
        }
    }

    private fun isInstalledOnSdCard(): Boolean {
        // noinspection SdCardPath
        return PackageUtils.isAppInstalledOnExternalStorage(this) &&
                TermuxConstants.TERMUX_FILES_DIR_PATH != filesDir.absolutePath
            .replace("^/data/user/0/".toRegex(), "/data/data/")
    }

    private fun checkDeviceSupported(): Boolean {
        val configProvider = IDEBuildConfigProvider.getInstance()

        if (!configProvider.supportsCpuAbi()) {
            //TODO JMT figure out how to build v8a and/or x64_86
//            addSlide(
//                OnboardingInfoFragment.newInstance(
//                    getString(string.title_unsupported_device),
//                    getString(
//                        string.msg_unsupported_device,
//                        configProvider.cpuArch.abi,
//                        configProvider.deviceArch.abi
//                    ),
//                    R.drawable.ic_alert,
//                    ContextCompat.getColor(this, R.color.color_error)
//                )
//            )
//            return false
            return true
        }

        if (configProvider.cpuArch != configProvider.deviceArch) {
            // IDE's build flavor is NOT the primary arch of the device
            // warn the user
            if (!archConfigExperimentalWarningIsShown()) {
                //TODO JMT get build to support v8a and/or x86_64
//                addSlide(
//                    OnboardingInfoFragment.newInstance(
//                        getString(string.title_experiment_flavor),
//                        getString(
//                            string.msg_experimental_flavor,
//                            configProvider.cpuArch.abi,
//                            configProvider.deviceArch.abi
//                        ),
//                        R.drawable.ic_alert,
//                        ContextCompat.getColor(this, R.color.color_warning)
//                    )
//                )
                prefManager.putBoolean(KEY_ARCHCONFIG_WARNING_IS_SHOWN, true)
            }
        }

        return true
    }

    private fun archConfigExperimentalWarningIsShown() =
        prefManager.getBoolean(KEY_ARCHCONFIG_WARNING_IS_SHOWN, false)
}


================================================
File: java/com/itsaky/androidide/activities/PreferencesActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.activities

import android.os.Bundle
import android.view.View
import androidx.core.graphics.Insets
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import com.itsaky.androidide.app.EdgeToEdgeIDEActivity
import com.itsaky.androidide.databinding.ActivityPreferencesBinding
import com.itsaky.androidide.fragments.IDEPreferencesFragment
import com.itsaky.androidide.preferences.addRootPreferences
import com.itsaky.androidide.preferences.IDEPreferences as prefs

class PreferencesActivity : EdgeToEdgeIDEActivity() {

  private var _binding: ActivityPreferencesBinding? = null
  private val binding: ActivityPreferencesBinding
    get() = checkNotNull(_binding) { "Activity has been destroyed" }

  private val rootFragment by lazy {
    IDEPreferencesFragment()
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    setSupportActionBar(binding.toolbar)
    supportActionBar!!.setTitle(R.string.ide_preferences)
    supportActionBar!!.setDisplayHomeAsUpEnabled(true)

    binding.toolbar.setNavigationOnClickListener { onBackPressedDispatcher.onBackPressed() }

    if (savedInstanceState != null) {
      return
    }

    (prefs.children as MutableList?)?.clear()

    prefs.addRootPreferences()

    val args = Bundle()
    args.putParcelableArrayList(
      IDEPreferencesFragment.EXTRA_CHILDREN,
      ArrayList(prefs.children)
    )

    rootFragment.arguments = args
    loadFragment(rootFragment)
  }

  override fun onApplySystemBarInsets(insets: Insets) {
    val binding = _binding ?: return
    val toolbar: View = binding.toolbar
    toolbar.setPadding(
      toolbar.paddingLeft + insets.left,
      toolbar.paddingTop,
      toolbar.paddingRight + insets.right,
      toolbar.paddingBottom
    )

    val fragmentContainer: View = binding.fragmentContainerParent
    fragmentContainer.setPadding(
      fragmentContainer.paddingLeft + insets.left,
      fragmentContainer.paddingTop,
      fragmentContainer.paddingRight + insets.right,
      fragmentContainer.paddingBottom
    )
  }

  override fun bindLayout(): View {
    _binding = ActivityPreferencesBinding.inflate(
      layoutInflater
    )
    return binding.root
  }

  private fun loadFragment(fragment: Fragment) {
    super.loadFragment(fragment, binding.fragmentContainer.id)
  }

  override fun onDestroy() {
    super.onDestroy()
    _binding = null
  }
}



================================================
File: java/com/itsaky/androidide/activities/SecondaryScreen.kt
================================================
package com.itsaky.androidide.activities

import android.app.Presentation
import android.content.Context
import android.os.Bundle
import android.view.Display
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import androidx.core.view.MenuProvider
import com.itsaky.androidide.R

class SecondaryScreen(outerContext: Context?, display: Display?) : Presentation(
    outerContext,
    display
) {
    val outerContext = outerContext
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_secondary_screen)
    }
}


================================================
File: java/com/itsaky/androidide/activities/SplashActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities

import android.app.Activity
import android.content.Intent
import android.os.Bundle

/**
 * @author Akash Yadav
 */
class SplashActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    startActivity(Intent(this, OnboardingActivity::class.java))
    finish()
  }
}


================================================
File: java/com/itsaky/androidide/activities/editor/BaseEditorActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities.editor

import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageInstaller.SessionCallback
import android.graphics.Color
import android.graphics.drawable.GradientDrawable
import android.os.Bundle
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.Process
import android.text.Spannable
import android.text.SpannableString
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.TextUtils
import android.text.method.LinkMovementMethod
import android.text.style.ClickableSpan
import android.text.style.LeadingMarginSpan
import android.view.Gravity
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver.OnGlobalLayoutListener
import androidx.activity.OnBackPressedCallback
import androidx.activity.result.ActivityResult
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult
import androidx.activity.viewModels
import androidx.annotation.GravityInt
import androidx.annotation.StringRes
import androidx.annotation.UiThread
import androidx.appcompat.app.ActionBarDrawerToggle
import androidx.collection.MutableIntIntMap
import androidx.core.graphics.Insets
import androidx.core.view.GravityCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePadding
import androidx.core.view.updatePaddingRelative
import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import com.blankj.utilcode.constant.MemoryConstants
import com.blankj.utilcode.util.ConvertUtils.byte2MemorySize
import com.blankj.utilcode.util.FileUtils
import com.blankj.utilcode.util.ThreadUtils
import com.github.mikephil.charting.components.AxisBase
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import com.github.mikephil.charting.formatter.IAxisValueFormatter
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetBehavior.BottomSheetCallback
import com.google.android.material.tabs.TabLayout
import com.google.android.material.tabs.TabLayout.Tab
import com.itsaky.androidide.R
import com.itsaky.androidide.R.string
import com.itsaky.androidide.actions.ActionItem.Location.EDITOR_FILE_TABS
import com.itsaky.androidide.actions.build.DebugAction
import com.itsaky.androidide.adapters.DiagnosticsAdapter
import com.itsaky.androidide.adapters.SearchListAdapter
import com.itsaky.androidide.app.EdgeToEdgeIDEActivity
import com.itsaky.androidide.databinding.ActivityEditorBinding
import com.itsaky.androidide.databinding.ContentEditorBinding
import com.itsaky.androidide.databinding.LayoutDiagnosticInfoBinding
import com.itsaky.androidide.events.InstallationResultEvent
import com.itsaky.androidide.fragments.SearchResultFragment
import com.itsaky.androidide.fragments.sidebar.EditorSidebarFragment
import com.itsaky.androidide.fragments.sidebar.FileTreeFragment
import com.itsaky.androidide.handlers.EditorActivityLifecyclerObserver
import com.itsaky.androidide.handlers.LspHandler.registerLanguageServers
import com.itsaky.androidide.interfaces.DiagnosticClickListener
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.lsp.models.DiagnosticItem
import com.itsaky.androidide.models.DiagnosticGroup
import com.itsaky.androidide.models.OpenedFile
import com.itsaky.androidide.models.Range
import com.itsaky.androidide.models.SearchResult
import com.itsaky.androidide.preferences.internal.BuildPreferences
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.services.debug.DebuggerService
import com.itsaky.androidide.tasks.cancelIfActive
import com.itsaky.androidide.ui.CodeEditorView
import com.itsaky.androidide.ui.ContentTranslatingDrawerLayout
import com.itsaky.androidide.ui.SwipeRevealLayout
import com.itsaky.androidide.uidesigner.UIDesignerActivity
import com.itsaky.androidide.utils.ActionMenuUtils.createMenu
import com.itsaky.androidide.utils.ApkInstallationSessionCallback
import com.itsaky.androidide.utils.DialogUtils.newMaterialDialogBuilder
import com.itsaky.androidide.utils.InstallationResultHandler.onResult
import com.itsaky.androidide.utils.IntentUtils
import com.itsaky.androidide.utils.MemoryUsageWatcher
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.resolveAttr
import com.itsaky.androidide.viewmodel.DebuggerConnectionState
import com.itsaky.androidide.viewmodel.DebuggerViewModel
import com.itsaky.androidide.viewmodel.EditorViewModel
import com.itsaky.androidide.xml.resources.ResourceTableRegistry
import com.itsaky.androidide.xml.versions.ApiVersionsRegistry
import com.itsaky.androidide.xml.widgets.WidgetTableRegistry
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode.MAIN
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.io.File
import kotlin.math.roundToInt
import kotlin.math.roundToLong

/**
 * Base class for EditorActivity which handles most of the view related things.
 *
 * @author Akash Yadav
 */
@Suppress("MemberVisibilityCanBePrivate")
abstract class BaseEditorActivity : EdgeToEdgeIDEActivity(), TabLayout.OnTabSelectedListener,
    DiagnosticClickListener {

    protected val mLifecycleObserver = EditorActivityLifecyclerObserver()
    protected var diagnosticInfoBinding: LayoutDiagnosticInfoBinding? = null
    protected var filesTreeFragment: FileTreeFragment? = null
    protected var editorBottomSheet: BottomSheetBehavior<out View?>? = null
    protected val memoryUsageWatcher = MemoryUsageWatcher()
    protected val pidToDatasetIdxMap = MutableIntIntMap(initialCapacity = 3)

    var isDestroying = false
        protected set

    /**
     * Editor activity's [CoroutineScope] for executing tasks in the background.
     */
    protected val editorActivityScope = CoroutineScope(Dispatchers.Default)

    internal var installationCallback: ApkInstallationSessionCallback? = null

    var uiDesignerResultLauncher: ActivityResultLauncher<Intent>? = null
    val editorViewModel by viewModels<EditorViewModel>()
    val debuggerViewModel by viewModels<DebuggerViewModel>()

    internal var _binding: ActivityEditorBinding? = null
    val binding: ActivityEditorBinding
        get() = checkNotNull(_binding) { "Activity has been destroyed" }
    val content: ContentEditorBinding
        get() = binding.content

    override val subscribeToEvents: Boolean
        get() = true

    private val onBackPressedCallback: OnBackPressedCallback =
        object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                if (binding.root.isDrawerOpen(GravityCompat.START)) {
                    binding.root.closeDrawer(GravityCompat.START)
                } else if (editorBottomSheet?.state != BottomSheetBehavior.STATE_COLLAPSED) {
                    editorBottomSheet?.setState(BottomSheetBehavior.STATE_COLLAPSED)
                } else if (binding.swipeReveal.isOpen) {
                    binding.swipeReveal.close()
                } else {
                    doConfirmProjectClose()
                }
            }
        }

    private val memoryUsageListener = MemoryUsageWatcher.MemoryUsageListener { memoryUsage ->
        memoryUsage.forEachValue { proc ->
            _binding?.memUsageView?.chart?.apply {
                val dataset = (data.getDataSetByIndex(pidToDatasetIdxMap[proc.pid]) as LineDataSet?)
                    ?: run {
                        log.error("No dataset found for process: {}: {}", proc.pid, proc.pname)
                        return@forEachValue
                    }

                dataset.entries.mapIndexed { index, entry ->
                    entry.y =
                        byte2MemorySize(proc.usageHistory[index], MemoryConstants.MB).toFloat()
                }

                dataset.label = "%s - %.2fMB".format(proc.pname, dataset.entries.last().y)
                dataset.notifyDataSetChanged()
                data.notifyDataChanged()
                notifyDataSetChanged()
                invalidate()
            }
        }
    }

    private var isImeVisible = false
    private var contentCardRealHeight: Int? = null
    private val editorSurfaceContainerBackground by lazy {
        resolveAttr(R.attr.colorSurfaceDim)
    }
    private val editorLayoutCorners by lazy {
        resources.getDimensionPixelSize(R.dimen.editor_container_corners).toFloat()
    }

    private var isDebuggerStarting = false
        @UiThread set(value) {
            field = value
            onUpdateProgressBarVisibility()
        }

    private var debuggerService: DebuggerService? = null
    private var debuggerPostConnectionAction: (suspend () -> Unit)? = null
    private val debuggerServiceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName, service: IBinder) {
            debuggerService = (service as DebuggerService.Binder).getService()
            debuggerService!!.showOverlay()

            isDebuggerStarting = false
            activityScope.launch(Dispatchers.Main.immediate) {
                doSetStatus(getString(string.debugger_started))
                debuggerPostConnectionAction?.invoke()
            }
        }
        override fun onServiceDisconnected(name: ComponentName?) {
            debuggerService = null
            isDebuggerStarting = false
        }
    }

    private val debuggerServiceStopHandler = Handler(Looper.getMainLooper())
    private val debuggerServiceStopRunnable = Runnable {
        if (debuggerService != null && debuggerViewModel.connectionState.value < DebuggerConnectionState.ATTACHED) {
            unbindDebuggerService()
        }
    }

    private fun unbindDebuggerService() {
        try {
            unbindService(debuggerServiceConnection)
        } catch (e: Throwable) {
            log.error("Failed to stop debugger service", e)
        }
    }

    private fun startDebuggerAndDo(action: suspend () -> Unit) {
        activityScope.launch(Dispatchers.Main.immediate) {
            if (debuggerService != null) {
                action()
            } else {
                debuggerPostConnectionAction = action
                ensureDebuggerServiceBound()
            }
        }
    }

    fun ensureDebuggerServiceBound() {
        if (debuggerService != null) return

        if (isDebuggerStarting) {
            log.info("Debugger service is already starting, ignoring...")
            return
        }

        isDebuggerStarting = true

        val intent = Intent(this, DebuggerService::class.java)
        if (bindService(intent, debuggerServiceConnection, Context.BIND_AUTO_CREATE)) {
            postStopDebuggerServiceIfNotConnected()
            doSetStatus(getString(string.debugger_starting))
        } else {
            isDebuggerStarting = false
            log.error("Debugger service doesn't exist or the IDE is not allowed to access it.")
            doSetStatus(getString(string.debugger_starting_failed))
        }
    }

    private fun postStopDebuggerServiceIfNotConnected() {
        debuggerServiceStopHandler.removeCallbacks(debuggerServiceStopRunnable)
        debuggerServiceStopHandler.postDelayed(debuggerServiceStopRunnable, DEBUGGER_SERVICE_STOP_DELAY_MS)
    }

    private var optionsMenuInvalidator: Runnable? = null

    companion object {

        const val DEBUGGER_SERVICE_STOP_DELAY_MS: Long = 60 * 1000

        @JvmStatic
        protected val PROC_IDE = "IDE"

        @JvmStatic
        protected val PROC_GRADLE_TOOLING = "Gradle Tooling"

        @JvmStatic
        protected val PROC_GRADLE_DAEMON = "Gradle Daemon"

        @JvmStatic
        protected val log: Logger = LoggerFactory.getLogger(BaseEditorActivity::class.java)

        private const val OPTIONS_MENU_INVALIDATION_DELAY = 150L

        const val EDITOR_CONTAINER_SCALE_FACTOR = 0.87f
        const val KEY_BOTTOM_SHEET_SHOWN = "editor_bottomSheetShown"
        const val KEY_PROJECT_PATH = "saved_projectPath"
    }

    protected abstract fun provideCurrentEditor(): CodeEditorView?

    protected abstract fun provideEditorAt(index: Int): CodeEditorView?

    protected abstract fun doOpenFile(file: File, selection: Range?)

    protected abstract fun doDismissSearchProgress()

    protected abstract fun getOpenedFiles(): List<OpenedFile>
    internal abstract fun doConfirmProjectClose()
  internal abstract fun doOpenHelp()

    protected open fun preDestroy() {
        _binding = null

        optionsMenuInvalidator?.also {
            ThreadUtils.getMainHandler().removeCallbacks(it)
        }

        optionsMenuInvalidator = null

        installationCallback?.destroy()
        installationCallback = null

        if (isDestroying) {
            memoryUsageWatcher.stopWatching(true)
            memoryUsageWatcher.listener = null
            editorActivityScope.cancelIfActive("Activity is being destroyed")

            unbindDebuggerService()
        }
    }

    protected open fun postDestroy() {
        if (isDestroying) {
            Lookup.getDefault().unregisterAll()
            ApiVersionsRegistry.getInstance().clear()
            ResourceTableRegistry.getInstance().clear()
            WidgetTableRegistry.getInstance().clear()
        }
    }

    override fun bindLayout(): View {
        this._binding = ActivityEditorBinding.inflate(layoutInflater)
        this.diagnosticInfoBinding = this.content.diagnosticInfo
        return this.binding.root
    }

    override fun onApplyWindowInsets(insets: WindowInsetsCompat) {
        super.onApplyWindowInsets(insets)
        val height = contentCardRealHeight ?: return
        val imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime())

        _binding?.content?.bottomSheet?.setImeVisible(imeInsets.bottom > 0)
        _binding?.contentCard?.updateLayoutParams<ViewGroup.LayoutParams> {
            this.height = height - imeInsets.bottom
        }

        val isImeVisible = imeInsets.bottom > 0
        if (this.isImeVisible != isImeVisible) {
            this.isImeVisible = isImeVisible
            onSoftInputChanged()
        }
    }

    override fun onApplySystemBarInsets(insets: Insets) {
        super.onApplySystemBarInsets(insets)
        this._binding?.apply {
            drawerSidebar.getFragment<EditorSidebarFragment>()
                .onApplyWindowInsets(insets)

            content.apply {
                editorAppBarLayout.updatePadding(
                    top = insets.top
                )
                editorToolbar.updatePaddingRelative(
                    start = editorToolbar.paddingStart + insets.left,
                    end = editorToolbar.paddingEnd + insets.right
                )
            }
        }
    }

    @Subscribe(threadMode = MAIN)
    open fun onInstallationResult(event: InstallationResultEvent) {
        val intent = event.intent
        if (isDestroying) {
            return
        }

        val packageName = onResult(this, intent) ?: return
        val isDebugging = event.intent.getBooleanExtra(DebugAction.ID, false)
        if (!isDebugging) {
            doLaunchApp(packageName)
            return
        }

        startDebuggerAndDo {
            debuggerViewModel.debugeePackage = packageName
            withContext(Dispatchers.Main.immediate) {
                doLaunchApp(packageName)
            }
        }
    }

    private fun doLaunchApp(packageName: String) {
        if (BuildPreferences.launchAppAfterInstall) {
            IntentUtils.launchApp(this, packageName)
            return
        }

        val builder = newMaterialDialogBuilder(this)
        builder.setTitle(string.msg_action_open_title_application)
        builder.setMessage(string.msg_action_open_application)
        builder.setPositiveButton(string.yes) { dialog, _ ->
            dialog.dismiss()
            IntentUtils.launchApp(this, packageName)
        }
        builder.setNegativeButton(string.no, null)
        builder.show()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        this.optionsMenuInvalidator = Runnable { super.invalidateOptionsMenu() }

        registerLanguageServers()

        if (savedInstanceState != null && savedInstanceState.containsKey(KEY_PROJECT_PATH)) {
            savedInstanceState.getString(KEY_PROJECT_PATH)?.let { path ->
                ProjectManagerImpl.getInstance().projectPath = path
            }
        }

        onBackPressedDispatcher.addCallback(this, onBackPressedCallback)
        lifecycle.addObserver(mLifecycleObserver)

        setSupportActionBar(content.editorToolbar)

        setupDrawers()
        content.tabs.addOnTabSelectedListener(this)

        setupViews()

        setupContainers()
        setupDiagnosticInfo()

        uiDesignerResultLauncher = registerForActivityResult(
            StartActivityForResult(),
            this::handleUiDesignerResult
        )

        setupMemUsageChart()
        watchMemory()
    }

    private fun onSwipeRevealDragProgress(progress: Float) {
        _binding?.apply {
            contentCard.progress = progress
            val insetsTop = systemBarInsets?.top ?: 0
            content.editorAppBarLayout.updatePadding(
                top = (insetsTop * (1f - progress)).roundToInt()
            )
            memUsageView.chart.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                topMargin = (insetsTop * progress).roundToInt()
            }
        }
    }

    private fun setupMemUsageChart() {
        binding.memUsageView.chart.apply {
            val colorAccent = resolveAttr(R.attr.colorAccent)

            isDragEnabled = false
            description.isEnabled = false
            xAxis.axisLineColor = colorAccent
            axisRight.axisLineColor = colorAccent

            setPinchZoom(false)
            setBackgroundColor(editorSurfaceContainerBackground)
            setDrawGridBackground(true)
            setScaleEnabled(true)

            axisLeft.isEnabled = false
            axisRight.valueFormatter = object :
                IAxisValueFormatter {
                override fun getFormattedValue(value: Float, axis: AxisBase?): String {
                    return "%dMB".format(value.roundToLong())
                }
            }
        }
    }

    private fun watchMemory() {
        memoryUsageWatcher.listener = memoryUsageListener
        memoryUsageWatcher.watchProcess(Process.myPid(), PROC_IDE)
        resetMemUsageChart()
    }

    protected fun resetMemUsageChart() {
        val processes = memoryUsageWatcher.getMemoryUsages()
        val datasets = Array(processes.size) { index ->
            LineDataSet(
                List(MemoryUsageWatcher.MAX_USAGE_ENTRIES) { Entry(it.toFloat(), 0f) },
                processes[index].pname
            )
        }

        val bgColor = editorSurfaceContainerBackground
        val textColor = resolveAttr(R.attr.colorOnSurface)

        for ((index, proc) in processes.withIndex()) {
            val dataset = datasets[index]
            dataset.color = getMemUsageLineColorFor(proc)
            dataset.setDrawIcons(false)
            dataset.setDrawCircles(false)
            dataset.setDrawCircleHole(false)
            dataset.setDrawValues(false)
            dataset.formLineWidth = 1f
            dataset.formSize = 15f
            dataset.isHighlightEnabled = false
            pidToDatasetIdxMap[proc.pid] = index
        }

        binding.memUsageView.chart.setBackgroundColor(bgColor)

        binding.memUsageView.chart.apply {
            data = LineData(*datasets)
            axisRight.textColor = textColor
            axisLeft.textColor = textColor
            legend.textColor = textColor

            data.setValueTextColor(textColor)
            setBackgroundColor(bgColor)
            setGridBackgroundColor(bgColor)
            notifyDataSetChanged()
            invalidate()
        }
    }

    private fun getMemUsageLineColorFor(proc: MemoryUsageWatcher.ProcessMemoryInfo): Int {
        return when (proc.pname) {
            PROC_IDE -> Color.BLUE
            PROC_GRADLE_TOOLING -> Color.RED
            PROC_GRADLE_DAEMON -> Color.GREEN
            else -> throw IllegalArgumentException("Unknown process: $proc")
        }
    }

    override fun onPause() {
        super.onPause()
        memoryUsageWatcher.listener = null
        memoryUsageWatcher.stopWatching(false)

        this.isDestroying = isFinishing
        getFileTreeFragment()?.saveTreeState()
    }

    override fun onResume() {
        super.onResume()
        invalidateOptionsMenu()

        memoryUsageWatcher.listener = memoryUsageListener
        memoryUsageWatcher.startWatching()

        try {
            getFileTreeFragment()?.listProjectFiles()
        } catch (th: Throwable) {
            log.error("Failed to update files list", th)
            flashError(string.msg_failed_list_files)
        }
    }

    override fun onStop() {
        super.onStop()
        checkIsDestroying()
    }

    override fun onDestroy() {
        checkIsDestroying()
        preDestroy()
        super.onDestroy()
        postDestroy()
    }

    override fun onSaveInstanceState(outState: Bundle) {
        outState.putString(KEY_PROJECT_PATH, IProjectManager.getInstance().projectDirPath)
        super.onSaveInstanceState(outState)
    }

    override fun invalidateOptionsMenu() {
        val mainHandler = ThreadUtils.getMainHandler()
        optionsMenuInvalidator?.also {
            mainHandler.removeCallbacks(it)
            mainHandler.postDelayed(it, OPTIONS_MENU_INVALIDATION_DELAY)
        }
    }

    override fun onTabSelected(tab: Tab) {
        val position = tab.position
        editorViewModel.displayedFileIndex = position

        val editorView = provideEditorAt(position)!!
        editorView.onEditorSelected()

        editorViewModel.setCurrentFile(position, editorView.file)
        refreshSymbolInput(editorView)
        invalidateOptionsMenu()
    }

    override fun onTabUnselected(tab: Tab) {}

    override fun onTabReselected(tab: Tab) {
        createMenu(this, tab.view, EDITOR_FILE_TABS, true).show()
    }

    override fun onGroupClick(group: DiagnosticGroup?) {
        if (group?.file?.exists() == true && FileUtils.isUtf8(group.file)) {
            doOpenFile(group.file, null)
            hideBottomSheet()
        }
    }

    override fun onDiagnosticClick(file: File, diagnostic: DiagnosticItem) {
        doOpenFile(file, diagnostic.range)
        hideBottomSheet()
    }

    open fun handleSearchResults(map: Map<File, List<SearchResult>>?) {
        val results = map ?: emptyMap()
        setSearchResultAdapter(SearchListAdapter(results, { file ->
            doOpenFile(file, null)
            hideBottomSheet()
        }) { match ->
            doOpenFile(match.file, match)
            hideBottomSheet()
        })

        showSearchResults()
        doDismissSearchProgress()
    }

    open fun setSearchResultAdapter(adapter: SearchListAdapter) {
        content.bottomSheet.setSearchResultAdapter(adapter)
    }

    open fun setDiagnosticsAdapter(adapter: DiagnosticsAdapter) {
        content.bottomSheet.setDiagnosticsAdapter(adapter)
    }

    open fun hideBottomSheet() {
        if (editorBottomSheet?.state != BottomSheetBehavior.STATE_COLLAPSED) {
            editorBottomSheet?.state = BottomSheetBehavior.STATE_COLLAPSED
        }
    }

    open fun showSearchResults() = showBottomSheetFragment(SearchResultFragment::class.java)

    open fun showBottomSheetFragment(
        fragmentClass: Class<out Fragment>,
        sheetState: Int = BottomSheetBehavior.STATE_EXPANDED
    ) {
        val index = content.bottomSheet.pagerAdapter.findIndexOfFragmentByClass(fragmentClass)
        if (index >= 0 && index < content.bottomSheet.binding.tabs.tabCount) {
            if (editorBottomSheet?.state != sheetState) {
                editorBottomSheet?.state = sheetState
            }
            content.bottomSheet.binding.tabs.getTabAt(index)?.select()
        }
    }

    open fun handleDiagnosticsResultVisibility(errorVisible: Boolean) {
        content.bottomSheet.handleDiagnosticsResultVisibility(errorVisible)
    }

    open fun handleSearchResultVisibility(errorVisible: Boolean) {
        content.bottomSheet.handleSearchResultVisibility(errorVisible)
    }

    open fun showFirstBuildNotice() {
        newMaterialDialogBuilder(this).setPositiveButton(android.R.string.ok, null)
            .setTitle(string.title_first_build).setMessage(string.msg_first_build)
            .setCancelable(false)
            .create().show()
    }

    open fun getFileTreeFragment(): FileTreeFragment? {
        if (filesTreeFragment == null) {
            filesTreeFragment = supportFragmentManager.findFragmentByTag(
                FileTreeFragment.TAG
            ) as FileTreeFragment?
        }
        return filesTreeFragment
    }

    fun doSetStatus(text: CharSequence, @GravityInt gravity: Int = Gravity.CENTER) {
        editorViewModel.statusText = text
        editorViewModel.statusGravity = gravity
    }

    fun refreshSymbolInput() {
        provideCurrentEditor()?.also { refreshSymbolInput(it) }
    }

    fun refreshSymbolInput(editor: CodeEditorView) {
        content.bottomSheet.refreshSymbolInput(editor)
    }

    private fun checkIsDestroying() {
        if (!isDestroying && isFinishing) {
            isDestroying = true
        }
    }

    private fun handleUiDesignerResult(result: ActivityResult) {
        if (result.resultCode != RESULT_OK || result.data == null) {
            log.warn(
                "UI Designer returned invalid result: resultCode={}, data={}", result.resultCode,
                result.data
            )
            return
        }
        val generated = result.data!!.getStringExtra(UIDesignerActivity.RESULT_GENERATED_XML)
        if (TextUtils.isEmpty(generated)) {
            log.warn("UI Designer returned blank generated XML code")
            return
        }
        val view = provideCurrentEditor()
        val text = view?.editor?.text ?: run {
            log.warn("No file opened to append UI designer result")
            return
        }
        val endLine = text.lineCount - 1
        text.replace(0, 0, endLine, text.getColumnCount(endLine), generated)
    }

    private fun setupDrawers() {
        val toggle = object : ActionBarDrawerToggle(
            this,
            binding.editorDrawerLayout,
            content.editorToolbar,
            string.app_name,
            string.app_name
        ) {
            override fun onDrawerOpened(drawerView: View) {
                super.onDrawerOpened(drawerView)
                // Hide the keyboard when the drawer opens.
                closeKeyboard()
            }
        }


        binding.editorDrawerLayout.addDrawerListener(toggle)
        toggle.syncState()
        binding.apply {
            editorDrawerLayout.apply {
                childId = contentCard.id
                translationBehaviorStart = ContentTranslatingDrawerLayout.TranslationBehavior.FULL
                translationBehaviorEnd = ContentTranslatingDrawerLayout.TranslationBehavior.FULL
                setScrimColor(Color.TRANSPARENT)
            }
        }
    }

    private fun onUpdateProgressBarVisibility() {
        log.debug("onBuildStatusChanged: isInitializing: ${editorViewModel.isInitializing}, isBuildInProgress: ${editorViewModel.isBuildInProgress}")
        val visible = editorViewModel.isBuildInProgress || editorViewModel.isInitializing || isDebuggerStarting
        content.progressIndicator.visibility = if (visible) View.VISIBLE else View.GONE
        invalidateOptionsMenu()
    }

    private fun setupViews() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                debuggerViewModel.connectionState.collectLatest { state ->
                    if (state == DebuggerConnectionState.ATTACHED) {
                        ensureDebuggerServiceBound()
                    }
                    postStopDebuggerServiceIfNotConnected()
                }

                debuggerViewModel.debugeePackageFlow.collectLatest { newPackage ->
                    debuggerService?.targetPackage = newPackage
                }
            }
        }

        editorViewModel._isBuildInProgress.observe(this) { onUpdateProgressBarVisibility() }
        editorViewModel._isInitializing.observe(this) { onUpdateProgressBarVisibility() }
        editorViewModel._statusText.observe(this) {
            content.bottomSheet.setStatus(
                it.first,
                it.second
            )
        }

        editorViewModel.observeFiles(this) { files ->
            content.apply {
                if (files.isNullOrEmpty()) {
                    tabs.visibility = View.GONE
                    viewContainer.displayedChild = 1
                } else {
                    tabs.visibility = View.VISIBLE
                    viewContainer.displayedChild = 0
                }
            }

            invalidateOptionsMenu()
        }

        setupNoEditorView()
        setupBottomSheet()

        if (!app.prefManager.getBoolean(
                KEY_BOTTOM_SHEET_SHOWN
            ) && editorBottomSheet?.state != BottomSheetBehavior.STATE_EXPANDED
        ) {
            editorBottomSheet?.state = BottomSheetBehavior.STATE_EXPANDED
            ThreadUtils.runOnUiThreadDelayed({
                editorBottomSheet?.state = BottomSheetBehavior.STATE_COLLAPSED
                app.prefManager.putBoolean(KEY_BOTTOM_SHEET_SHOWN, true)
            }, 1500)
        }

        binding.contentCard.progress = 0f
        binding.swipeReveal.dragListener = object : SwipeRevealLayout.OnDragListener {
            override fun onDragStateChanged(swipeRevealLayout: SwipeRevealLayout, state: Int) {}
            override fun onDragProgress(swipeRevealLayout: SwipeRevealLayout, progress: Float) {
                onSwipeRevealDragProgress(progress)
            }
        }
    }

    private fun setupNoEditorView() {
        content.noEditorSummary.movementMethod = LinkMovementMethod()
        val sb = SpannableStringBuilder()
        val indentParent = 80
        val indentChild = 140

        fun appendHierarchicalText(textRes: Int) {
            val text = getString(textRes)
            text.split("\n").forEach { line ->
                val trimmed = line.trimStart()

                val margin = when {
                    trimmed.startsWith("-") -> indentChild
                    trimmed.startsWith("•") -> indentParent
                    else -> 0
                }

                val spannable = SpannableString("$trimmed\n")

                if (margin > 0) {
                    spannable.setSpan(
                        LeadingMarginSpan.Standard(margin, margin),
                        0, spannable.length,
                        Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }

                sb.append(spannable)
            }
        }

        appendHierarchicalText(R.string.msg_drawer_for_files)
        sb.append("\n")
        appendHierarchicalText(R.string.msg_swipe_for_output)
        sb.append("\n")
        appendHierarchicalText(R.string.msg_help_hint)

        content.noEditorSummary.text = sb
    }



    private fun appendClickableSpan(
        sb: SpannableStringBuilder,
        @StringRes textRes: Int,
        span: ClickableSpan,
    ) {
        val str = getString(textRes)
        val split = str.split("@@", limit = 3)
        if (split.size != 3) {
            // Not a valid format
            sb.append(str)
            sb.append('\n')
            return
        }
        sb.append(split[0])
        sb.append(split[1], span, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
        sb.append(split[2])
        sb.append('\n')
    }

    private fun setupBottomSheet() {
        editorBottomSheet = BottomSheetBehavior.from<View>(content.bottomSheet)
        editorBottomSheet?.addBottomSheetCallback(object : BottomSheetCallback() {
            override fun onStateChanged(bottomSheet: View, newState: Int) {
                if (newState == BottomSheetBehavior.STATE_EXPANDED) {
                    val editor = provideCurrentEditor()
                    editor?.editor?.ensureWindowsDismissed()
                }
            }

            override fun onSlide(bottomSheet: View, slideOffset: Float) {
                content.apply {
                    val editorScale = 1 - slideOffset * (1 - EDITOR_CONTAINER_SCALE_FACTOR)
                    this.bottomSheet.onSlide(slideOffset)
                    this.viewContainer.scaleX = editorScale
                    this.viewContainer.scaleY = editorScale
                }
            }
        })

        val observer: OnGlobalLayoutListener = object : OnGlobalLayoutListener {
            override fun onGlobalLayout() {
                contentCardRealHeight = binding.contentCard.height
                content.also {
                    it.realContainer.pivotX = it.realContainer.width.toFloat() / 2f
                    it.realContainer.pivotY =
                        (it.realContainer.height.toFloat() / 2f) + (systemBarInsets?.run { bottom - top }
                            ?: 0)
                    it.viewContainer.viewTreeObserver.removeOnGlobalLayoutListener(this)
                }
            }
        }

        content.apply {
            viewContainer.viewTreeObserver.addOnGlobalLayoutListener(observer)
            bottomSheet.setOffsetAnchor(editorAppBarLayout)
        }
    }

    private fun setupDiagnosticInfo() {
        val gd = GradientDrawable()
        gd.shape = GradientDrawable.RECTANGLE
        gd.setColor(-0xdededf)
        gd.setStroke(1, -0x1)
        gd.cornerRadius = 8f
        diagnosticInfoBinding?.root?.background = gd
        diagnosticInfoBinding?.root?.visibility = View.GONE
    }

    private fun setupContainers() {
        handleDiagnosticsResultVisibility(true)
        handleSearchResultVisibility(true)
    }

    private fun onSoftInputChanged() {
        if (!isDestroying) {
            invalidateOptionsMenu()
            content.bottomSheet.onSoftInputChanged()
        }
    }

    private fun showNeedHelpDialog() {
        val builder = newMaterialDialogBuilder(this)
        builder.setTitle(string.need_help)
        builder.setMessage(string.msg_need_help)
        builder.setPositiveButton(android.R.string.ok, null)
        builder.create().show()
    }

    open fun installationSessionCallback(): SessionCallback {
        return ApkInstallationSessionCallback(this).also { installationCallback = it }
    }
}




================================================
File: java/com/itsaky/androidide/activities/editor/EditorActivityKt.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities.editor

/**
 * @author Akash Yadav
 */
class EditorActivityKt : EditorHandlerActivity()

// TODO: Should we adjust to the display cutout insets?


================================================
File: java/com/itsaky/androidide/activities/editor/EditorHandlerActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities.editor

import android.annotation.SuppressLint
import android.content.Intent
import android.os.Bundle
import android.text.TextUtils
import android.view.Menu
import android.view.MenuItem
import android.view.ViewGroup.LayoutParams
import androidx.annotation.DrawableRes
import androidx.appcompat.view.menu.MenuBuilder
import androidx.collection.MutableIntObjectMap
import androidx.core.content.res.ResourcesCompat
import androidx.core.view.GravityCompat
import com.blankj.utilcode.util.ImageUtils
import com.itsaky.androidide.R.string
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem.Location.EDITOR_TOOLBAR
import com.itsaky.androidide.actions.ActionsRegistry.Companion.getInstance
import com.itsaky.androidide.actions.FillMenuParams
import com.itsaky.androidide.editor.language.treesitter.JavaLanguage
import com.itsaky.androidide.editor.language.treesitter.JsonLanguage
import com.itsaky.androidide.editor.language.treesitter.KotlinLanguage
import com.itsaky.androidide.editor.language.treesitter.LogLanguage
import com.itsaky.androidide.editor.language.treesitter.TSLanguageRegistry
import com.itsaky.androidide.editor.language.treesitter.XMLLanguage
import com.itsaky.androidide.editor.schemes.IDEColorSchemeProvider
import com.itsaky.androidide.editor.ui.IDEEditor
import com.itsaky.androidide.eventbus.events.editor.DocumentChangeEvent
import com.itsaky.androidide.eventbus.events.file.FileRenameEvent
import com.itsaky.androidide.idetooltips.IDETooltipItem
import com.itsaky.androidide.idetooltips.TooltipManager
import com.itsaky.androidide.interfaces.IEditorHandler
import com.itsaky.androidide.models.FileExtension
import com.itsaky.androidide.models.OpenedFile
import com.itsaky.androidide.models.OpenedFilesCache
import com.itsaky.androidide.models.Range
import com.itsaky.androidide.models.SaveResult
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.tasks.executeAsync
import com.itsaky.androidide.ui.CodeEditorView
import com.itsaky.androidide.utils.DialogUtils.newYesNoDialog
import com.itsaky.androidide.utils.IntentUtils.openImage
import com.itsaky.androidide.utils.UniqueNameBuilder
import com.itsaky.androidide.utils.flashSuccess
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.adfa.constants.CONTENT_KEY
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode
import java.io.File
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.collections.set

/**
 * Base class for EditorActivity. Handles logic for working with file editors.
 *
 * @author Akash Yadav
 */
open class EditorHandlerActivity : ProjectHandlerActivity(), IEditorHandler {

  protected val isOpenedFilesSaved = AtomicBoolean(false)

  override fun doOpenFile(file: File, selection: Range?) {
    openFileAndSelect(file, selection)
  }

  override fun doCloseAll(runAfter: () -> Unit) {
    closeAll(runAfter)
  }

  override fun provideCurrentEditor(): CodeEditorView? {
    return getCurrentEditor()
  }

  override fun provideEditorAt(index: Int): CodeEditorView? {
    return getEditorAtIndex(index)
  }

  override fun preDestroy() {
    super.preDestroy()
    TSLanguageRegistry.instance.destroy()
    editorViewModel.removeAllFiles()
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    mBuildEventListener.setActivity(this)
    super.onCreate(savedInstanceState)

    editorViewModel._displayedFile.observe(
      this) { this.content.editorContainer.displayedChild = it }
    editorViewModel._startDrawerOpened.observe(this) { opened ->
      this.binding.editorDrawerLayout.apply {
        if (opened) openDrawer(GravityCompat.START) else closeDrawer(GravityCompat.START)
      }
    }

    editorViewModel._filesModified.observe(this) { invalidateOptionsMenu() }
    editorViewModel._filesSaving.observe(this) { invalidateOptionsMenu() }

    editorViewModel.observeFiles(this) {
      // rewrite the cached files index if there are any opened files
      val currentFile =
        getCurrentEditor()?.editor?.file?.absolutePath
          ?: run {
            editorViewModel.writeOpenedFiles(null)
            editorViewModel.openedFilesCache = null
            return@observeFiles
          }
      getOpenedFiles().also {
        val cache = OpenedFilesCache(currentFile, it)
        editorViewModel.writeOpenedFiles(cache)
        editorViewModel.openedFilesCache = cache
      }
    }

    executeAsync {
      TSLanguageRegistry.instance.register(JavaLanguage.TS_TYPE, JavaLanguage.FACTORY)
      TSLanguageRegistry.instance.register(KotlinLanguage.TS_TYPE_KT, KotlinLanguage.FACTORY)
      TSLanguageRegistry.instance.register(KotlinLanguage.TS_TYPE_KTS, KotlinLanguage.FACTORY)
      TSLanguageRegistry.instance.register(LogLanguage.TS_TYPE, LogLanguage.FACTORY)
      TSLanguageRegistry.instance.register(JsonLanguage.TS_TYPE, JsonLanguage.FACTORY)
      TSLanguageRegistry.instance.register(XMLLanguage.TS_TYPE, XMLLanguage.FACTORY)
      IDEColorSchemeProvider.initIfNeeded()
    }
  }

  override fun onPause() {
    super.onPause()

    // if the user manually closes the project, this will be true
    // in this case, don't overwrite the already saved cache
    if (!isOpenedFilesSaved.get()) {
      saveOpenedFiles()
    }
  }

  override fun onResume() {
    super.onResume()
    isOpenedFilesSaved.set(false)
  }

  override fun saveOpenedFiles() {
    writeOpenedFilesCache(getOpenedFiles(), getCurrentEditor()?.editor?.file)
  }

  private fun writeOpenedFilesCache(openedFiles: List<OpenedFile>, selectedFile: File?) {
    if (selectedFile == null || openedFiles.isEmpty()) {
      editorViewModel.writeOpenedFiles(null)
      editorViewModel.openedFilesCache = null
      log.debug("[onPause] No opened files. Opened files cache reset to null.")
      isOpenedFilesSaved.set(true)
      return
    }

    val cache = OpenedFilesCache(selectedFile = selectedFile.absolutePath, allFiles = openedFiles)

    editorViewModel.writeOpenedFiles(cache)
    editorViewModel.openedFilesCache = if (!isDestroying) cache else null
    log.debug("[onPause] Opened files cache reset to {}", editorViewModel.openedFilesCache)
    isOpenedFilesSaved.set(true)
  }

  override fun onStart() {
    super.onStart()

    try {
      editorViewModel.getOrReadOpenedFilesCache(this::onReadOpenedFilesCache)
      editorViewModel.openedFilesCache = null
    } catch (err: Throwable) {
      log.error("Failed to reopen recently opened files", err)
    }
  }

  private fun onReadOpenedFilesCache(cache: OpenedFilesCache?) {
    cache ?: return
    cache.allFiles.forEach { file ->
      openFile(File(file.filePath), file.selection)
    }
    openFile(File(cache.selectedFile))
  }

  override fun onPrepareOptionsMenu(menu: Menu): Boolean {
    prepareOptionsMenu(menu)
    return true
  }

  @SuppressLint("RestrictedApi")
  override fun onCreateOptionsMenu(menu: Menu): Boolean {
    if (menu is MenuBuilder) {
      menu.setOptionalIconsVisible(true)
    }

    val data = createToolbarActionData()
    getInstance().fillMenu(FillMenuParams(data, EDITOR_TOOLBAR, menu))
    return true
  }

  open fun prepareOptionsMenu(menu: Menu) {
    val data = createToolbarActionData()
    val actions = getInstance().getActions(EDITOR_TOOLBAR)
    actions.forEach { (_, action) ->
      menu.findItem(action.itemId)?.let { item ->
        action.prepare(data)

        item.isVisible = action.visible
        item.isEnabled = action.enabled
        item.title = action.label

        item.icon = action.icon?.apply {
          colorFilter = action.createColorFilter(data)
          alpha = if (action.enabled) 255 else 76
        }

        var showAsAction = action.getShowAsActionFlags(data)
        if (showAsAction == -1) {
          showAsAction = if (action.icon != null) {
            MenuItem.SHOW_AS_ACTION_IF_ROOM
          } else {
            MenuItem.SHOW_AS_ACTION_NEVER
          }
        }

        if (!action.enabled) {
          showAsAction = MenuItem.SHOW_AS_ACTION_NEVER
        }

        item.setShowAsAction(showAsAction)

        action.createActionView(data)?.let { item.actionView = it }
      }
    }
    content.editorToolbar.updateMenuDisplay()
  }

  private fun createToolbarActionData(): ActionData {
    val data = ActionData.create(this)
    val currentEditor = getCurrentEditor()

    data.put(CodeEditorView::class.java, currentEditor)

    if (currentEditor != null) {
      data.put(IDEEditor::class.java, currentEditor.editor)
      data.put(File::class.java, currentEditor.file)
    }
    return data
  }

  override fun getCurrentEditor(): CodeEditorView? {
    return if (editorViewModel.getCurrentFileIndex() != -1) {
      getEditorAtIndex(editorViewModel.getCurrentFileIndex())
    } else null
  }

  override fun getEditorAtIndex(index: Int): CodeEditorView? {
    return _binding?.content?.editorContainer?.getChildAt(index) as CodeEditorView?
  }

  override fun openFileAndSelect(file: File, selection: Range?) {
    openFile(file, selection)

    getEditorForFile(file)?.editor?.also { editor ->
      editor.postInLifecycle {
        if (selection == null) {
          editor.setSelection(0, 0)
          return@postInLifecycle
        }

        editor.validateRange(selection)
        editor.setSelection(selection)
      }
    }
  }

  override fun openFile(file: File, selection: Range?): CodeEditorView? {
    val range = selection ?: Range.NONE
    if (ImageUtils.isImage(file)) {
      openImage(this, file)
      return null
    }

    val index = openFileAndGetIndex(file, range)
    val tab = content.tabs.getTabAt(index)
    if (tab != null && index >= 0 && !tab.isSelected) {
      tab.select()
    }

    editorViewModel.startDrawerOpened = false
    editorViewModel.displayedFileIndex = index

    return try {
      getEditorAtIndex(index)
    } catch (th: Throwable) {
      log.error("Unable to get editor fragment at opened file index {}", index, th)
      null
    }
  }

  override fun openFileAndGetIndex(file: File, selection: Range?): Int {
    val openedFileIndex = findIndexOfEditorByFile(file)
    if (openedFileIndex != -1) {
      return openedFileIndex
    }

    if (!file.exists()) {
      return -1
    }

    val position = editorViewModel.getOpenedFileCount()

    log.info("Opening file at index {} file:{}", position, file)

    val editor = CodeEditorView(this, file, selection!!)
    editor.layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)

    content.editorContainer.addView(editor)
    content.tabs.addTab(content.tabs.newTab())

    editorViewModel.addFile(file)
    editorViewModel.setCurrentFile(position, file)

    updateTabs()

    return position
  }

  override fun getEditorForFile(file: File): CodeEditorView? {
    for (i in 0 until editorViewModel.getOpenedFileCount()) {
      val editor = content.editorContainer.getChildAt(i) as? CodeEditorView
      if (file == editor?.file) return editor
    }
    return null
  }

  override fun findIndexOfEditorByFile(file: File?): Int {
    if (file == null) {
      log.error("Cannot find index of a null file.")
      return -1
    }

    for (i in 0 until editorViewModel.getOpenedFileCount()) {
      val opened: File = editorViewModel.getOpenedFile(i)
      if (opened == file) {
        return i
      }
    }

    return -1
  }

  override fun saveAllAsync(
    notify: Boolean,
    requestSync: Boolean,
    processResources: Boolean,
    progressConsumer: ((Int, Int) -> Unit)?,
    runAfter: (() -> Unit)?
  ) {
    editorActivityScope.launch {
      saveAll(notify, requestSync, processResources, progressConsumer)
      runAfter?.invoke()
    }
  }

  override suspend fun saveAll(
    notify: Boolean,
    requestSync: Boolean,
    processResources: Boolean,
    progressConsumer: ((Int, Int) -> Unit)?
  ): Boolean {
    val result = saveAllResult(progressConsumer)

    // don't bother to switch the context if we don't need to
    if (notify || (result.gradleSaved && requestSync)) {
      withContext(Dispatchers.Main) {
        if (notify) {
          flashSuccess(string.all_saved)
        }

        if (result.gradleSaved && requestSync) {
          editorViewModel.isSyncNeeded = true
        }
      }
    }

    if (processResources) {
      ProjectManagerImpl.getInstance().generateSources()
    }

    return result.gradleSaved
  }

  override suspend fun saveAllResult(progressConsumer: ((Int, Int) -> Unit)?): SaveResult {
    return performFileSave {
      val result = SaveResult()
      for (i in 0 until editorViewModel.getOpenedFileCount()) {
        saveResultInternal(i, result)
        progressConsumer?.invoke(i + 1, editorViewModel.getOpenedFileCount())
      }

      return@performFileSave result
    }
  }

  override suspend fun saveResult(index: Int, result: SaveResult) {
    performFileSave {
      saveResultInternal(index, result)
    }
  }

  private suspend fun saveResultInternal(
    index: Int,
    result: SaveResult
  ) : Boolean {
    if (index < 0 || index >= editorViewModel.getOpenedFileCount()) {
      return false
    }

    val frag = getEditorAtIndex(index) ?: return false
    val fileName = frag.file?.name ?: return false

    run {
      // Must be called before frag.save()
      // Otherwise, it'll always return false
      val modified = frag.isModified
      if (!frag.save()) {
        return false
      }

      val isGradle = fileName.endsWith(".gradle") || fileName.endsWith(".gradle.kts")
      val isXml: Boolean = fileName.endsWith(".xml")
      if (!result.gradleSaved) {
        result.gradleSaved = modified && isGradle
      }

      if (!result.xmlSaved) {
        result.xmlSaved = modified && isXml
      }
    }

    val hasUnsaved = hasUnsavedFiles()

    withContext(Dispatchers.Main) {

      editorViewModel.areFilesModified = hasUnsaved

      // set tab as unmodified
      val tab = content.tabs.getTabAt(index) ?: return@withContext
      if (tab.text!!.startsWith('*')) {
        tab.text = tab.text!!.substring(startIndex = 1)
      }
    }

    return true
  }

  private fun hasUnsavedFiles() = editorViewModel.getOpenedFiles().any { file ->
    getEditorForFile(file)?.isModified == true
  }

  private suspend inline fun <T : Any?> performFileSave(crossinline action: suspend () -> T) : T {
    setFilesSaving(true)
    try {
      return action()
    } finally {
      setFilesSaving(false)
    }
  }

  private suspend fun setFilesSaving(saving: Boolean) {
    withContext(Dispatchers.Main.immediate) {
      editorViewModel.areFilesSaving = saving
    }
  }

  override fun areFilesModified(): Boolean {
    return editorViewModel.areFilesModified
  }

  override fun areFilesSaving(): Boolean {
    return editorViewModel.areFilesSaving
  }

  override fun closeFile(index: Int, runAfter: () -> Unit) {
    if (index < 0 || index >= editorViewModel.getOpenedFileCount()) {
      log.error("Invalid file index. Cannot close.")
      return
    }

    val opened = editorViewModel.getOpenedFile(index)
    log.info("Closing file: {}", opened)

    val editor = getEditorAtIndex(index)
    if (editor?.isModified == true) {
      log.info("File has been modified: {}", opened)
      notifyFilesUnsaved(listOf(editor)) {
        closeFile(index, runAfter)
      }
      return
    }

    editor?.close() ?: run {
      log.error("Cannot save file before close. Editor instance is null")
    }

    editorViewModel.removeFile(index)
    content.apply {
      tabs.removeTabAt(index)
      editorContainer.removeViewAt(index)
    }

    editorViewModel.areFilesModified = hasUnsavedFiles()

    updateTabs()
    runAfter()
  }

  override fun closeOthers() {
    if (editorViewModel.getOpenedFileCount() == 0) {
      return
    }

    val unsavedFiles =
      editorViewModel.getOpenedFiles().map(::getEditorForFile)
        .filter { it != null && it.isModified }

    if (unsavedFiles.isNotEmpty()) {
      notifyFilesUnsaved(unsavedFiles) { closeOthers() }
      return
    }

    val file = editorViewModel.getCurrentFile()
    var index = 0

    // keep closing the file at index 0
    // if openedFiles[0] == file, then keep closing files at index 1
    while (editorViewModel.getOpenedFileCount() != 1) {
      val editor = getEditorAtIndex(index)

      if (editor == null) {
        log.error("Unable to save file at index {}", index)
        continue
      }

      // Index of files changes as we keep close files
      // So we compare the files instead of index
      if (file != editor.file) {
        closeFile(index)
      } else {
        index = 1
      }
    }
  }

    override fun openFAQActivity(htmlData: String) {
        val intent = Intent(this, FAQActivity::class.java)
        intent.putExtra(CONTENT_KEY, htmlData)
        startActivity(intent)
    }

    override suspend fun getTooltipData(category: String, tag: String): IDETooltipItem? {
        return withContext(Dispatchers.IO) {
          TooltipManager.getTooltip(this@EditorHandlerActivity, category, tag)
        }
    }

  override fun closeAll(runAfter: () -> Unit) {
    val count = editorViewModel.getOpenedFileCount()
    val unsavedFiles =
      editorViewModel.getOpenedFiles().map(this::getEditorForFile)
        .filter { it != null && it.isModified }

    if (unsavedFiles.isNotEmpty()) {
      // There are unsaved files
      notifyFilesUnsaved(unsavedFiles) { closeAll(runAfter) }
      return
    }

    // Files were already saved, close all files one by one
    for (i in 0 until count) {
      getEditorAtIndex(i)?.close() ?: run {
        log.error("Unable to close file at index {}", i)
      }
    }

    editorViewModel.removeAllFiles()
    content.apply {
      tabs.removeAllTabs()
      tabs.requestLayout()
      editorContainer.removeAllViews()
    }

    runAfter()
  }

  override fun getOpenedFiles() =
    editorViewModel.getOpenedFiles().mapNotNull {
      val editor = getEditorForFile(it)?.editor ?: return@mapNotNull null
      OpenedFile(it.absolutePath, editor.cursorLSPRange)
    }

  fun closeCurrentFile() {
    content.tabs.selectedTabPosition.let { index ->
      closeFile(index) {
        invalidateOptionsMenu()
      }
    }
  }

  private fun notifyFilesUnsaved(unsavedEditors: List<CodeEditorView?>, invokeAfter: Runnable) {
    if (isDestroying) {
      // Do not show unsaved files dialog if the activity is being destroyed
      // TODO Use a service to save files and to avoid file content loss
      for (editor in unsavedEditors) {
        editor?.markUnmodified()
      }
      invokeAfter.run()
      return
    }

    val mapped = unsavedEditors.mapNotNull { it?.file?.absolutePath }
    val builder =
      newYesNoDialog(
        context = this,
        title = getString(string.title_files_unsaved),
        message = getString(string.msg_files_unsaved, TextUtils.join("\n", mapped)),
        positiveClickListener = { dialog, _ ->
          dialog.dismiss()
          saveAllAsync(notify = true, runAfter = { runOnUiThread(invokeAfter) })
        }
      ) { dialog, _ ->
        dialog.dismiss()
        // Mark all the files as saved, then try to close them all
        for (editor in unsavedEditors) {
          editor?.markAsSaved()
        }
        invokeAfter.run()
      }
    builder.show()
  }

  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onFileRenamed(event: FileRenameEvent) {
    val index = findIndexOfEditorByFile(event.file)
    if (index < 0 || index >= content.tabs.tabCount) {
      return
    }

    val editor = getEditorAtIndex(index) ?: return
    editorViewModel.updateFile(index, event.newFile)
    editor.updateFile(event.newFile)

    updateTabs()
  }

  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onDocumentChange(event: DocumentChangeEvent) {
    // update content modification status
    editorViewModel.areFilesModified = true

    val index = findIndexOfEditorByFile(event.file.toFile())
    if (index == -1) {
      return
    }

    val tab = content.tabs.getTabAt(index)!!
    if (tab.text?.startsWith('*') == true) {
      return
    }

    // mark as modified
    tab.text = "*${tab.text}"
  }

  private fun updateTabs() {
    editorActivityScope.launch {
      val files = editorViewModel.getOpenedFiles()
      val dupliCount = mutableMapOf<String, Int>()
      val names = MutableIntObjectMap<Pair<String, Int>>()
      val nameBuilder = UniqueNameBuilder<File>("", File.separator)

      files.forEach {
        var count = dupliCount[it.name] ?: 0
        dupliCount[it.name] = ++count
        nameBuilder.addPath(it, it.path)
      }

      for (index in 0 until content.tabs.tabCount) {
        val file = files.getOrNull(index) ?: continue
        val count = dupliCount[file.name] ?: 0

        val isModified = getEditorAtIndex(index)?.isModified ?: false
        var name = if (count > 1) nameBuilder.getShortPath(file) else file.name
        if (isModified) {
          name = "*${name}"
        }

        names[index] = name to FileExtension.Factory.forFile(file).icon
      }

      withContext(Dispatchers.Main) {
        names.forEach { index, (name, iconId) ->
          val tab = content.tabs.getTabAt(index) ?: return@forEach
          tab.icon = ResourcesCompat.getDrawable(resources, iconId, theme)
          tab.text = name
        }
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/activities/editor/FAQActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities.editor

import androidx.core.graphics.Insets
import android.os.Bundle
import android.view.View
import android.webkit.WebViewClient
import org.adfa.constants.CONTENT_KEY
import com.itsaky.androidide.R
import com.itsaky.androidide.app.EdgeToEdgeIDEActivity
import com.itsaky.androidide.databinding.ActivityFaqBinding

class FAQActivity : EdgeToEdgeIDEActivity() {

    private var _binding: ActivityFaqBinding? = null
    private val binding: ActivityFaqBinding
        get() = checkNotNull(_binding) {
            "FAQActivity has been destroyed"
        }

    override fun bindLayout(): View {
        _binding = ActivityFaqBinding.inflate(layoutInflater)
        return binding.root
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        with(binding) {
            setSupportActionBar(toolbar)
            supportActionBar!!.setTitle(R.string.faq_activity_title)
            supportActionBar!!.setDisplayHomeAsUpEnabled(true)
            toolbar.setNavigationOnClickListener { onBackPressedDispatcher.onBackPressed() }

            val htmlContent = intent.getStringExtra(CONTENT_KEY)

//            htmlContent?.let {
//                webView.clearCache(true)
//                webView.loadDataWithBaseURL(null, it, "text/html", "UTF-8", null)
//            }
            // Enable JavaScript if required
            webView.settings.javaScriptEnabled = true

            // Set WebViewClient to handle page navigation within the WebView
            webView.webViewClient = WebViewClient()

            // Load the HTML file from the assets folder
            htmlContent?.let { webView.loadUrl(it) }
        }
    }

    override fun onApplySystemBarInsets(insets: Insets) {
        val toolbar: View = binding.toolbar
        toolbar.setPadding(
            toolbar.paddingLeft + insets.left,
            toolbar.paddingTop,
            toolbar.paddingRight + insets.right,
            toolbar.paddingBottom
        )

        val webview: View = binding.webView
        webview.setPadding(
            webview.paddingLeft + insets.left,
            webview.paddingTop,
            webview.paddingRight + insets.right,
            webview.paddingBottom
        )
    }
}


================================================
File: java/com/itsaky/androidide/activities/editor/IDELogcatReader.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.activities.editor

import android.os.Process
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.transferToStream
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import org.slf4j.LoggerFactory
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

/**
 * Reads the logs from AndroidIDE and saves it to a file in the projects directory.
 *
 * @author Akash Yadav
 */
class IDELogcatReader {

  private var job: Job? = null
  private var shouldRun = false

  companion object {

    private val log = LoggerFactory.getLogger(IDELogcatReader::class.java)
  }

  /**
   * Start reading the logs.
   */
  fun start() {
    shouldRun = true

    check(job == null) {
      "Logcat reader is already running"
    }

    job = CoroutineScope(Dispatchers.IO).launch {
      run()
    }
  }

  /**
   * Stop the log reader.
   */
  fun stop() {
    shouldRun = false
    job?.cancel("User requested cancellation")
    job = null
  }

  private fun run() {
    val date = Date()
    val dateFormat = SimpleDateFormat("yyyy-MM-dd_HH:mm:ss.SSS", Locale.US)
    val outputFile = File(Environment.ANDROIDIDE_HOME,
      "logs/AndroidIDE-LOG-${dateFormat.format(date)}.txt")

    log.debug("Creating output file: {}", outputFile)

    outputFile.parentFile!!.mkdirs()
    try {
      outputFile.createNewFile()
    } catch (e: Exception) {
      log.error("Failed to create output file for log", e)
      return
    }

    outputFile.outputStream().buffered().use { writer ->
      try {
        val process = ProcessBuilder(
          "logcat",
          "--pid=${Process.myPid()}",
          "-v",
          "threadtime"
        ).let { builder ->
          builder.redirectErrorStream(true)
          builder.start()
        }

        process.inputStream.transferToStream(writer)
        writer.flush()

        log.info("Process ended with exit code: {}", process.waitFor())
      } catch (err: Throwable) {
        log.error("Failed to read logs", err)
      }
    }
  }
}


================================================
File: java/com/itsaky/androidide/activities/editor/ProjectHandlerActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.activities.editor

import android.content.Intent
import android.os.Bundle
import android.view.Gravity
import android.view.ViewGroup.MarginLayoutParams
import android.widget.CheckBox
import androidx.activity.viewModels
import androidx.annotation.GravityInt
import androidx.appcompat.app.AlertDialog
import com.blankj.utilcode.util.SizeUtils
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.R.string
import com.itsaky.androidide.databinding.LayoutSearchProjectBinding
import com.itsaky.androidide.flashbar.Flashbar
import com.itsaky.androidide.fragments.sheets.ProgressSheet
import com.itsaky.androidide.handlers.EditorBuildEventListener
import com.itsaky.androidide.handlers.LspHandler.connectClient
import com.itsaky.androidide.handlers.LspHandler.connectDebugClient
import com.itsaky.androidide.handlers.LspHandler.destroyLanguageServers
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.lsp.IDELanguageClientImpl
import com.itsaky.androidide.lsp.java.utils.CancelChecker
import com.itsaky.androidide.preferences.internal.GeneralPreferences
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.projects.api.GradleProject
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.services.builder.GradleBuildService
import com.itsaky.androidide.services.builder.GradleBuildServiceConnnection
import com.itsaky.androidide.services.builder.gradleDistributionParams
import com.itsaky.androidide.tasks.executeAsyncProvideError
import com.itsaky.androidide.tasks.executeWithProgress
import com.itsaky.androidide.tooling.api.messages.AndroidInitializationParams
import com.itsaky.androidide.tooling.api.messages.InitializeProjectParams
import com.itsaky.androidide.tooling.api.messages.result.InitializeResult
import com.itsaky.androidide.tooling.api.messages.result.TaskExecutionResult
import com.itsaky.androidide.tooling.api.messages.result.TaskExecutionResult.Failure.PROJECT_DIRECTORY_INACCESSIBLE
import com.itsaky.androidide.tooling.api.messages.result.TaskExecutionResult.Failure.PROJECT_NOT_DIRECTORY
import com.itsaky.androidide.tooling.api.messages.result.TaskExecutionResult.Failure.PROJECT_NOT_FOUND
import com.itsaky.androidide.tooling.api.models.BuildVariantInfo
import com.itsaky.androidide.tooling.api.models.mapToSelectedVariants
import com.itsaky.androidide.ui.CodeEditorView
import com.itsaky.androidide.utils.DURATION_INDEFINITE
import com.itsaky.androidide.utils.DialogUtils.newMaterialDialogBuilder
import com.itsaky.androidide.utils.RecursiveFileSearcher
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashbarBuilder
import com.itsaky.androidide.utils.resolveAttr
import com.itsaky.androidide.utils.showOnUiThread
import com.itsaky.androidide.utils.withIcon
import com.itsaky.androidide.viewmodel.BuildVariantsViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.adfa.constants.CONTENT_KEY
import org.adfa.constants.HELP_PAGE_URL
import java.io.File
import java.util.concurrent.CompletableFuture
import java.util.regex.Pattern
import java.util.stream.Collectors

/** @author Akash Yadav */
@Suppress("MemberVisibilityCanBePrivate")
abstract class ProjectHandlerActivity : BaseEditorActivity() {

    protected val buildVariantsViewModel by viewModels<BuildVariantsViewModel>()

    protected var mSearchingProgress: ProgressSheet? = null
    protected var mFindInProjectDialog: AlertDialog? = null
    protected var syncNotificationFlashbar: Flashbar? = null

    protected var isFromSavedInstance = false
    protected var shouldInitialize = false

    protected var initializingFuture: CompletableFuture<out InitializeResult?>? = null

    val findInProjectDialog: AlertDialog
        get() {
            if (mFindInProjectDialog == null) {
                createFindInProjectDialog()
            }
            return mFindInProjectDialog!!
        }

    protected val mBuildEventListener = EditorBuildEventListener()

    private val buildServiceConnection = GradleBuildServiceConnnection()

    companion object {
        const val STATE_KEY_FROM_SAVED_INSTANACE = "ide.editor.isFromSavedInstance"
        const val STATE_KEY_SHOULD_INITIALIZE = "ide.editor.isInitializing"
    }

    abstract fun doCloseAll(runAfter: () -> Unit)

    abstract fun saveOpenedFiles()

    override fun doDismissSearchProgress() {
        if (mSearchingProgress?.isShowing == true) {
            mSearchingProgress!!.dismiss()
        }
    }

    override fun doConfirmProjectClose() {
        confirmProjectClose()
    }

    override fun doOpenHelp() {
        openHelpActivity()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        savedInstanceState?.let {
            this.shouldInitialize = it.getBoolean(STATE_KEY_SHOULD_INITIALIZE, true)
            this.isFromSavedInstance = it.getBoolean(STATE_KEY_FROM_SAVED_INSTANACE, false)
        }
            ?: run {
                this.shouldInitialize = true
                this.isFromSavedInstance = false
            }

        editorViewModel._isSyncNeeded.observe(this) { isSyncNeeded ->
            if (!isSyncNeeded) {
                // dismiss if already showing
                syncNotificationFlashbar?.dismiss()
                return@observe
            }

            if (syncNotificationFlashbar?.isShowing() == true) {
                // already shown
                return@observe
            }

            notifySyncNeeded()
        }

        startServices()
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.apply {
            putBoolean(STATE_KEY_SHOULD_INITIALIZE, !editorViewModel.isInitializing)
            putBoolean(STATE_KEY_FROM_SAVED_INSTANACE, true)
        }
    }

    override fun onPause() {
        super.onPause()
        if (isDestroying) {
            // reset these values here
            // sometimes, when the IDE closed and reopened instantly, these values prevent initialization
            // of the project
            ProjectManagerImpl.getInstance().destroy()

            editorViewModel.isInitializing = false
            editorViewModel.isBuildInProgress = false
        }
    }

    override fun preDestroy() {

        syncNotificationFlashbar?.dismiss()
        syncNotificationFlashbar = null

        if (isDestroying) {
            releaseServerListener()
            this.initializingFuture?.cancel(true)
            this.initializingFuture = null

            closeProject(false)
        }

        if (IDELanguageClientImpl.isInitialized()) {
            IDELanguageClientImpl.shutdown()
        }

        super.preDestroy()

        if (isDestroying) {

            try {
                stopLanguageServers()
            } catch (err: Exception) {
                log.error("Failed to stop editor services.")
            }

            try {
                unbindService(buildServiceConnection)
                buildServiceConnection.onConnected = {}
            } catch (err: Throwable) {
                log.error("Unable to unbind service")
            } finally {
                Lookup.getDefault().apply {

                    (lookup(BuildService.KEY_BUILD_SERVICE) as? GradleBuildService?)
                        ?.setEventListener(null)

                    unregister(BuildService.KEY_BUILD_SERVICE)
                }

                mBuildEventListener.release()
                editorViewModel.isBoundToBuildSerice = false
            }
        }
    }

    fun setStatus(status: CharSequence) {
        setStatus(status, Gravity.CENTER)
    }

    fun setStatus(status: CharSequence, @GravityInt gravity: Int) {
        doSetStatus(status, gravity)
    }

    fun appendBuildOutput(str: String) {
        content.bottomSheet.appendBuildOut(str)
    }

    fun notifySyncNeeded() {
        notifySyncNeeded { initializeProject() }
    }

    private fun notifySyncNeeded(onConfirm: () -> Unit) {
        val buildService = Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE)
        if (buildService == null || editorViewModel.isInitializing || buildService.isBuildInProgress) return

        this.syncNotificationFlashbar?.dismiss()

        this.syncNotificationFlashbar = flashbarBuilder(
            duration = DURATION_INDEFINITE,
            backgroundColor = resolveAttr(R.attr.colorSecondaryContainer),
            messageColor = resolveAttr(R.attr.colorOnSecondaryContainer)
        )
            .withIcon(
                R.drawable.ic_sync,
                colorFilter = resolveAttr(R.attr.colorOnSecondaryContainer)
            )
            .message(string.msg_sync_needed)
            .positiveActionText(string.btn_sync)
            .positiveActionTapListener {
                onConfirm()
                it.dismiss()
            }
            .negativeActionText(string.btn_ignore_changes)
            .negativeActionTapListener(Flashbar::dismiss)
            .build()

        this.syncNotificationFlashbar?.showOnUiThread()

    }

    fun startServices() {
        val service =
            Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE) as GradleBuildService?
        if (editorViewModel.isBoundToBuildSerice && service != null) {
            log.info("Reusing already started Gradle build service")
            onGradleBuildServiceConnected(service)
            return
        } else {
            log.info("Binding to Gradle build service...")
        }

        buildServiceConnection.onConnected = this::onGradleBuildServiceConnected

        if (
            bindService(
                Intent(this, GradleBuildService::class.java),
                buildServiceConnection,
                BIND_AUTO_CREATE or BIND_IMPORTANT
            )
        ) {
            log.info("Bind request for Gradle build service was successful...")
        } else {
            log.error("Gradle build service doesn't exist or the IDE is not allowed to access it.")
        }

        initLspClient()
    }

    /**
     * Initialize (sync) the project.
     *
     * @param buildVariantsProvider A function which returns the map of project paths to the selected build variants.
     *    This function is called asynchronously.
     */
    fun initializeProject(buildVariantsProvider: () -> Map<String, String>) {
        executeWithProgress { progress ->
            executeAsyncProvideError(buildVariantsProvider::invoke) { result, error ->
                com.itsaky.androidide.tasks.runOnUiThread {
                    progress.dismiss()
                }

                if (result == null || error != null) {
                    val msg = getString(string.msg_build_variants_fetch_failed)
                    flashError(msg)
                    log.error(msg, error)
                    return@executeAsyncProvideError
                }

                com.itsaky.androidide.tasks.runOnUiThread {
                    initializeProject(result)
                }
            }
        }
    }

    fun initializeProject() {
        val currentVariants = buildVariantsViewModel._buildVariants.value

        // no information about the build variants is available
        // use the default variant selections
        if (currentVariants == null) {
            log.debug(
                "No variant selection information available. Default build variants will be selected."
            )
            initializeProject(emptyMap())
            return
        }

        // variant selection information is available
        // but there are updated & unsaved variant selections
        // use the updated variant selections to initialize the project
        if (buildVariantsViewModel.updatedBuildVariants.isNotEmpty()) {
            val newSelections = currentVariants.toMutableMap()
            newSelections.putAll(buildVariantsViewModel.updatedBuildVariants)
            initializeProject {
                newSelections.mapToSelectedVariants().also {
                    log.debug("Initializing project with new build variant selections: {}", it)
                }
            }
            return
        }

        // variant selection information is available but no variant selections have been updated
        // the user might be trying to sync the project from options menu
        // initialize the project with the existing selected variants
        initializeProject {
            log.debug("Re-initializing project with existing build variant selections")
            currentVariants.mapToSelectedVariants()
        }
    }

    /**
     * Initialize (sync) the project.
     *
     * @param buildVariants A map of project paths to the selected build variants.
     */
    fun initializeProject(buildVariants: Map<String, String>) {
        val manager = ProjectManagerImpl.getInstance()
        val projectDir = File(manager.projectPath)
        if (!projectDir.exists()) {
            log.error("GradleProject directory does not exist. Cannot initialize project")
            return
        }

        val initialized = manager.projectInitialized && manager.cachedInitResult != null
        log.debug("Is project initialized: {}", initialized)
        // When returning after a configuration change between the initialization process,
        // we do not want to start another project initialization
        if (isFromSavedInstance && initialized && !shouldInitialize) {
            log.debug("Skipping init process because initialized && !wasInitializing")
            return
        }

        //noinspection ConstantConditions
        ThreadUtils.runOnUiThread { preProjectInit() }

        val buildService = Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE)
        if (buildService == null) {
            log.error("No build service found. Cannot initialize project.")
            return
        }

        if (!buildService.isToolingServerStarted()) {
            flashError(string.msg_tooling_server_unavailable)
            return
        }

        this.initializingFuture =
            if (shouldInitialize || (!isFromSavedInstance && !initialized)) {
                log.debug("Sending init request to tooling server..")
                buildService.initializeProject(createProjectInitParams(projectDir, buildVariants))
            } else {
                // The project initialization was in progress before the configuration change
                // In this case, we should not start another project initialization
                log.debug("Using cached initialize result as the project is already initialized")
                CompletableFuture.supplyAsync {
                    log.warn("GradleProject has already been initialized. Skipping initialization process.")
                    manager.cachedInitResult
                }
            }

        this.initializingFuture!!.whenCompleteAsync { result, error ->
            releaseServerListener()

            if (result == null || !result.isSuccessful || error != null) {
                if (!CancelChecker.isCancelled(error)) {
                    log.error("An error occurred initializing the project with Tooling API", error)
                }

                ThreadUtils.runOnUiThread {
                    postProjectInit(false, result?.failure)
                }
                return@whenCompleteAsync
            }

            onProjectInitialized(result)
        }
    }

    private fun createProjectInitParams(
        projectDir: File,
        buildVariants: Map<String, String>
    ): InitializeProjectParams {
        return InitializeProjectParams(
            projectDir.absolutePath,
            gradleDistributionParams,
            createAndroidParams(buildVariants)
        )
    }

    private fun createAndroidParams(buildVariants: Map<String, String>): AndroidInitializationParams {
        if (buildVariants.isEmpty()) {
            return AndroidInitializationParams.DEFAULT
        }

        return AndroidInitializationParams(buildVariants)
    }

    private fun releaseServerListener() {
        // Release reference to server listener in order to prevent memory leak
        (Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE) as? GradleBuildService?)
            ?.setServerListener(null)
    }

    fun stopLanguageServers() {
        try {
            destroyLanguageServers(isChangingConfigurations)
        } catch (err: Throwable) {
            log.error("Unable to stop editor services. Please report this issue.", err)
        }
    }

    protected fun onGradleBuildServiceConnected(service: GradleBuildService) {
        log.info("Connected to Gradle build service")

        buildServiceConnection.onConnected = null
        editorViewModel.isBoundToBuildSerice = true
        Lookup.getDefault().update(BuildService.KEY_BUILD_SERVICE, service)
        service.setEventListener(mBuildEventListener)

        if (!service.isToolingServerStarted()) {
            service.startToolingServer { pid ->
                memoryUsageWatcher.watchProcess(pid, PROC_GRADLE_TOOLING)
                resetMemUsageChart()

                service.metadata().whenComplete { metadata, err ->
                    if (metadata == null || err != null) {
                        log.error("Failed to get tooling server metadata")
                        return@whenComplete
                    }

                    if (pid != metadata.pid) {
                        log.warn(
                            "Tooling server pid mismatch. Expected: {}, Actual: {}. Replacing memory watcher...",
                            pid, metadata.pid
                        )
                        memoryUsageWatcher.watchProcess(metadata.pid, PROC_GRADLE_TOOLING)
                        resetMemUsageChart()
                    }
                }

                initializeProject()
            }
        } else {
            initializeProject()
        }
    }

    protected open fun onProjectInitialized(result: InitializeResult) {
        val manager = ProjectManagerImpl.getInstance()
        if (isFromSavedInstance && manager.projectInitialized && result == manager.cachedInitResult) {
            log.debug("Not setting up project as this a configuration change")
            return
        }

        manager.cachedInitResult = result
        editorActivityScope.launch(Dispatchers.IO) {
            manager.setupProject()
            manager.notifyProjectUpdate()
            updateBuildVariants(manager.androidBuildVariants)

            com.itsaky.androidide.tasks.runOnUiThread {
                postProjectInit(true, null)
            }
        }
    }

    protected open fun preProjectInit() {
        setStatus(getString(string.msg_initializing_project))
        editorViewModel.isInitializing = true
    }

    protected open fun postProjectInit(
        isSuccessful: Boolean,
        failure: TaskExecutionResult.Failure?
    ) {
        val manager = ProjectManagerImpl.getInstance()
        if (!isSuccessful) {
            // Get project name for error message
            val projectName = try {
                val project = manager.rootProject
                if (project != null) {
                    project.rootProject.name.takeIf { it.isNotEmpty() } ?: manager.projectDir.name
                } else {
                    manager.projectDir.name
                }
            } catch (th: Throwable) {
                manager.projectDir.name
            }

            val initFailed = if (projectName.isNotEmpty()) {
                getString(string.msg_project_initialization_failed_with_name, projectName)
            } else {
                getString(string.msg_project_initialization_failed)
            }
            setStatus(initFailed)

            val msg = when (failure) {
                PROJECT_DIRECTORY_INACCESSIBLE -> string.msg_project_dir_inaccessible
                PROJECT_NOT_DIRECTORY -> string.msg_file_is_not_dir
                PROJECT_NOT_FOUND -> string.msg_project_dir_doesnt_exist
                else -> null
            }?.let {
                "$initFailed: ${getString(it)}"
            }

            flashError(msg ?: initFailed)

            editorViewModel.isInitializing = false
            manager.projectInitialized = false
            return
        }

        initialSetup()
        setStatus(getString(string.msg_project_initialized))
        editorViewModel.isInitializing = false
        manager.projectInitialized = true

        if (mFindInProjectDialog?.isShowing == true) {
            mFindInProjectDialog!!.dismiss()
        }

        mFindInProjectDialog = null // Create the dialog again if needed
    }

    private fun updateBuildVariants(buildVariants: Map<String, BuildVariantInfo>) {
        // avoid using the 'runOnUiThread' method defined in the activity
        com.itsaky.androidide.tasks.runOnUiThread {
            buildVariantsViewModel.buildVariants = buildVariants
            buildVariantsViewModel.resetUpdatedSelections()
        }
    }

    protected open fun createFindInProjectDialog(): AlertDialog? {
        val manager = ProjectManagerImpl.getInstance()
        if (manager.rootProject == null) {
            log.warn("No root project model found. Is the project initialized?")
            flashError(getString(string.msg_project_not_initialized))
            return null
        }

        val moduleDirs =
            try {
                manager.rootProject!!.subProjects.stream().map(GradleProject::projectDir)
                    .collect(Collectors.toList())
            } catch (e: Throwable) {
                flashError(getString(string.msg_no_modules))
                emptyList()
            }

        return createFindInProjectDialog(moduleDirs)
    }

    protected open fun createFindInProjectDialog(moduleDirs: List<File>): AlertDialog? {
        val srcDirs = mutableListOf<File>()
        val binding = LayoutSearchProjectBinding.inflate(layoutInflater)
        binding.modulesContainer.removeAllViews()

        for (i in moduleDirs.indices) {
            val module = moduleDirs[i]
            val src = File(module, "src")

            if (!module.exists() || !module.isDirectory || !src.exists() || !src.isDirectory) {
                continue
            }

            val check = CheckBox(this)
            check.text = module.name
            check.isChecked = true

            val params = MarginLayoutParams(-2, -2)
            params.bottomMargin = SizeUtils.dp2px(4f)
            binding.modulesContainer.addView(check, params)
            srcDirs.add(src)
        }

        val builder = newMaterialDialogBuilder(this)
        builder.setTitle(string.menu_find_project)
        builder.setView(binding.root)
        builder.setCancelable(false)
        builder.setPositiveButton(string.menu_find) { dialog, _ ->
            val text = binding.input.editText!!.text.toString().trim()
            if (text.isEmpty()) {
                flashError(string.msg_empty_search_query)
                return@setPositiveButton
            }

            val searchDirs = mutableListOf<File>()
            for (i in 0 until binding.modulesContainer.childCount) {
                val check = binding.modulesContainer.getChildAt(i) as CheckBox
                if (check.isChecked) {
                    searchDirs.add(srcDirs[i])
                }
            }

            val extensions = binding.filter.editText!!.text.toString().trim()
            val extensionList = mutableListOf<String>()
            if (extensions.isNotEmpty()) {
                if (extensions.contains("|")) {
                    for (str in
                    extensions
                        .split(Pattern.quote("|").toRegex())
                        .dropLastWhile { it.isEmpty() }
                        .toTypedArray()) {
                        if (str.trim().isEmpty()) {
                            continue
                        }
                        extensionList.add(str)
                    }
                } else {
                    extensionList.add(extensions)
                }
            }

            if (searchDirs.isEmpty()) {
                flashError(string.msg_select_search_modules)
            } else {
                dialog.dismiss()

                getProgressSheet(string.msg_searching_project)?.apply {
                    show(supportFragmentManager, "search_in_project_progress")
                }

                RecursiveFileSearcher.searchRecursiveAsync(
                    text,
                    extensionList,
                    searchDirs
                ) { results ->
                    handleSearchResults(results)
                }
            }
        }

        builder.setNegativeButton(android.R.string.cancel) { dialog, _ -> dialog.dismiss() }
        mFindInProjectDialog = builder.create()
        return mFindInProjectDialog
    }

    private fun initialSetup() {
        val manager = ProjectManagerImpl.getInstance()
        GeneralPreferences.lastOpenedProject = manager.projectDirPath
        try {
            val project = manager.rootProject
            if (project == null) {
                log.warn("GradleProject not initialized. Skipping initial setup...")
                return
            }

            var projectName = project.rootProject.name
            if (projectName.isEmpty()) {
                projectName = manager.projectDir.name
            }

            supportActionBar!!.subtitle = projectName
        } catch (th: Throwable) {
            // ignored
        }
    }

    private fun closeProject(manualFinish: Boolean) {
        if (manualFinish) {
            // if the user is manually closing the project,
            // save the opened files cache
            // this is needed because in this case, the opened files cache will be empty
            // when onPause will be called.
            saveOpenedFiles()

            // reset the lastOpenedProject if the user explicitly chose to close the project
            GeneralPreferences.lastOpenedProject = GeneralPreferences.NO_OPENED_PROJECT
        }

        // Make sure we close files
        // This will make sure that file contents are not erased.
        doCloseAll {
            if (manualFinish) {
                finish()
            }
        }
    }

    private fun openHelpActivity() {
        val intent = Intent(this, HelpActivity::class.java)
        intent.putExtra(CONTENT_KEY, HELP_PAGE_URL)
        startActivity(intent)
    }

    private fun confirmProjectClose() {
        val builder = newMaterialDialogBuilder(this)
        builder.setTitle(string.title_confirm_project_close)
        builder.setMessage(string.msg_confirm_project_close)

        builder.setNegativeButton(string.cancel_project_text, null)

        builder.setNeutralButton(string.close_without_saving) { dialog, _ ->
            dialog.dismiss()

            editorActivityScope.launch {
                for (i in 0 until editorViewModel.getOpenedFileCount()) {
                    (content.editorContainer.getChildAt(i) as? CodeEditorView)?.editor?.markUnmodified()
                }

                withContext(Dispatchers.Main) {
                    closeProject(true)
                }
            }
        }

        builder.setPositiveButton(string.save_close_project) { dialog, _ ->
            dialog.dismiss()
            closeProject(true)
        }

        builder.show()
    }


    private fun initLspClient() {
        if (!IDELanguageClientImpl.isInitialized()) {
            IDELanguageClientImpl.initialize(this as EditorHandlerActivity)
        }
        connectClient(IDELanguageClientImpl.getInstance())
        connectDebugClient(debuggerViewModel.debugClient)
    }

    open fun getProgressSheet(msg: Int): ProgressSheet? {
        doDismissSearchProgress()

        mSearchingProgress =
            ProgressSheet().also {
                it.isCancelable = false
                it.setMessage(getString(msg))
                it.setSubMessageEnabled(false)
            }

        return mSearchingProgress
    }
}



================================================
File: java/com/itsaky/androidide/adapters/BuildVariantsAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters

import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.core.widget.addTextChangedListener
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.LayoutBuildVariantItemBinding
import com.itsaky.androidide.tooling.api.IAndroidProject
import com.itsaky.androidide.tooling.api.models.BuildVariantInfo
import com.itsaky.androidide.tooling.api.models.BuildVariantInfo.Companion.withSelection
import com.itsaky.androidide.viewmodel.BuildVariantsViewModel
import java.util.Objects

/**
 * [RecyclerView] adapter for showing the list of Android modules and their selected build variant.
 *
 * @property items
 * @author Akash Yadav
 */
class BuildVariantsAdapter(
  private val viewModel: BuildVariantsViewModel,
  private var items: List<BuildVariantInfo>
) : RecyclerView.Adapter<BuildVariantsAdapter.ViewHolder>() {

  class ViewHolder(internal val binding: LayoutBuildVariantItemBinding) :
    RecyclerView.ViewHolder(binding.root)

  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
    val binding = LayoutBuildVariantItemBinding.inflate(LayoutInflater.from(parent.context), parent,
      false)
    return ViewHolder(binding)
  }

  override fun getItemCount(): Int {
    return items.size
  }

  override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    val binding = holder.binding
    val variantInfo = items[position]

    binding.moduleName.text = variantInfo.projectPath

    binding.variantName.apply {

      val viewModel = viewModel

      setAdapter(
        ArrayAdapter(binding.root.context, R.layout.support_simple_spinner_dropdown_item,
          variantInfo.buildVariants
        )
      )

      var listSelection = variantInfo.buildVariants.indexOf(variantInfo.selectedVariant)
      if (listSelection < 0 || listSelection >= variantInfo.buildVariants.size) {
        listSelection = 0
      }

      this.listSelection = listSelection
      setText(variantInfo.selectedVariant, false)

      addTextChangedListener { editable ->
        // update the changed build variants map
        viewModel.updatedBuildVariants = viewModel.updatedBuildVariants.also { variants ->

          // the newly selected build variant
          // if this is different that the variant that was used while initializing the project,
          // then the user is notified to re-sync the project
          // else the selection is cleared
          val newSelection = editable?.toString() ?: IAndroidProject.DEFAULT_VARIANT

          if (!Objects.equals(variantInfo.selectedVariant, newSelection)) {
            variants[variantInfo.projectPath] = variantInfo.withSelection(newSelection)
          } else {
            variants.remove(variantInfo.projectPath)
          }
        }
      }
    }
  }
}


================================================
File: java/com/itsaky/androidide/adapters/ContributorsGridAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions
import com.itsaky.androidide.R
import com.itsaky.androidide.app.IDEApplication
import com.itsaky.androidide.contributors.Contributor
import com.itsaky.androidide.databinding.LayoutContributorsItemBinding

/**
 * @author Akash Yadav
 */
class ContributorsGridAdapter(
  contributors: List<Contributor>
) : RecyclerView.Adapter<ContributorsGridAdapter.ViewHolder>() {

  private val contributors = contributors.toMutableList()

  class ViewHolder(val binding: LayoutContributorsItemBinding) :
    RecyclerView.ViewHolder(binding.root)

  override fun getItemCount(): Int {
    return contributors.size
  }

  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
    return ViewHolder(
      LayoutContributorsItemBinding.inflate(LayoutInflater.from(parent.context), parent, false))
  }

  override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    val binding = holder.binding
    val contributor = contributors[position]

    if (contributor is EmptyContributor) {
      binding.root.visibility = View.INVISIBLE
      return
    }

    Glide.with(binding.root)
      .load(contributor.avatarUrl)
      .placeholder(R.drawable.ic_account)
      .transition(DrawableTransitionOptions.withCrossFade(100))
      .into(binding.root)

    binding.root.setOnClickListener {
      IDEApplication.instance.openUrl(contributor.profileUrl)
    }
  }

  object EmptyContributor : Contributor {
    override val id: Int
      get() = 0
    override val username: String
      get() = ""
    override val avatarUrl: String
      get() = ""
    override val profileUrl: String
      get() = ""
  }

  internal fun fillDiff(extras: Int) {
    val count = itemCount
    for (i in 1..extras) {
      contributors.add(EmptyContributor)
    }

    val diff = DiffUtil.calculateDiff(object : DiffUtil.Callback() {
      override fun getOldListSize(): Int {
        return count
      }

      override fun getNewListSize(): Int {
        return count + extras
      }

      override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        return newItemPosition < count && oldItemPosition == newItemPosition
      }

      override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        return areItemsTheSame(oldItemPosition, newItemPosition)
      }
    })

    diff.dispatchUpdatesTo(this)
  }
}


================================================
File: java/com/itsaky/androidide/adapters/DeleteProjectListAdapter.kt
================================================
package com.itsaky.androidide.adapters

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.databinding.DeleteProjectsItemBinding
import com.itsvks.layouteditor.ProjectFile
import java.text.SimpleDateFormat
import java.util.Locale

class DeleteProjectListAdapter(
    private var projects: List<ProjectFile>,
    private val onSelectionChange: (Boolean) -> Unit
) : RecyclerView.Adapter<DeleteProjectListAdapter.ProjectViewHolder>() {

    private val selectedProjects = mutableSetOf<ProjectFile>()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ProjectViewHolder {
        val binding =
            DeleteProjectsItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ProjectViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ProjectViewHolder, position: Int) {
        holder.bind(projects[position])
    }

    override fun getItemCount(): Int = projects.size

    fun getSelectedProjects(): List<ProjectFile> = selectedProjects.toList()

    fun updateProjects(newProjects: List<ProjectFile>) {
        projects = newProjects
        notifyDataSetChanged()
    }

    inner class ProjectViewHolder(private val binding: DeleteProjectsItemBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(project: ProjectFile) {
            binding.projectName.text = project.name
            binding.projectDate.text = formatDate(project.date ?: "")
            binding.icon.text = project.name.take(2).uppercase()

            binding.checkbox.visibility = View.VISIBLE
            binding.checkbox.isChecked = selectedProjects.contains(project)

            binding.checkbox.setOnCheckedChangeListener { _, isChecked ->
                if (isChecked) selectedProjects.add(project) else selectedProjects.remove(
                    project
                )
                onSelectionChange(selectedProjects.isNotEmpty())
            }
        }
    }

    private fun formatDate(dateString: String): String {
        return try {
            val inputFormat =
                SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy", Locale.getDefault())
            val date = inputFormat.parse(dateString)
            val day = SimpleDateFormat("d", Locale.ENGLISH).format(date).toInt()
            val suffix = when {
                day in 11..13 -> "th"
                day % 10 == 1 -> "st"
                day % 10 == 2 -> "nd"
                day % 10 == 3 -> "rd"
                else -> "th"
            }
            val outputFormat = SimpleDateFormat("d'$suffix', MMMM yyyy", Locale.getDefault())
            outputFormat.format(date)
        } catch (e: Exception) {
            dateString.take(5)
        }
    }
}



================================================
File: java/com/itsaky/androidide/adapters/DiagnosticItemAdapter.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.adapters;

import android.graphics.PorterDuff;
import android.view.LayoutInflater;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.RecyclerView;
import com.itsaky.androidide.databinding.LayoutDiagnosticItemBinding;
import com.itsaky.androidide.interfaces.DiagnosticClickListener;
import com.itsaky.androidide.lsp.models.DiagnosticItem;
import com.itsaky.androidide.lsp.models.DiagnosticSeverity;
import com.itsaky.androidide.resources.R;
import java.io.File;
import java.util.List;
import java.util.Objects;

public class DiagnosticItemAdapter extends RecyclerView.Adapter<DiagnosticItemAdapter.VH> {

  private final List<DiagnosticItem> diagnostics;
  private final File file;
  private final DiagnosticClickListener listener;

  public DiagnosticItemAdapter(
      List<DiagnosticItem> diagnostics, File file, DiagnosticClickListener listener) {
    this.diagnostics = Objects.requireNonNull(diagnostics);
    this.file = file;
    this.listener = listener;
  }

  @NonNull
  @Override
  public DiagnosticItemAdapter.VH onCreateViewHolder(@NonNull ViewGroup p1, int p2) {
    return new VH(
        LayoutDiagnosticItemBinding.inflate(LayoutInflater.from(p1.getContext()), p1, false));
  }

  @Override
  public void onBindViewHolder(DiagnosticItemAdapter.VH p1, int p2) {
    final DiagnosticItem diagnostic = diagnostics.get(p2);
    final LayoutDiagnosticItemBinding binding = p1.binding;

    binding.icon.setImageResource(getDiagnosticIconId(diagnostic));
    binding.icon.setColorFilter(
        ContextCompat.getColor(
            binding.icon.getContext(),
            diagnostic.getSeverity() == DiagnosticSeverity.ERROR
                ? R.color.diagnostic_error
                : R.color.diagnostic_warning),
        PorterDuff.Mode.SRC_ATOP);
    binding.title.setText(diagnostic.getMessage());

    binding
        .getRoot()
        .setOnClickListener(
            v -> {
              if (listener != null) {
                listener.onDiagnosticClick(file, diagnostic);
              }
            });
  }

  @Override
  public int getItemCount() {
    return diagnostics.size();
  }

  private int getDiagnosticIconId(DiagnosticItem diagnostic) {
    if (diagnostic.getSeverity() == DiagnosticSeverity.ERROR)
      return R.drawable.ic_compilation_error;
    return R.drawable.ic_info;
  }

  public static class VH extends RecyclerView.ViewHolder {
    private LayoutDiagnosticItemBinding binding;

    public VH(LayoutDiagnosticItemBinding binding) {
      super(binding.getRoot());
      this.binding = binding;
    }
  }
}



================================================
File: java/com/itsaky/androidide/adapters/DiagnosticsAdapter.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

package com.itsaky.androidide.adapters;

import android.view.LayoutInflater;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.itsaky.androidide.databinding.LayoutDiagnosticGroupBinding;
import com.itsaky.androidide.interfaces.DiagnosticClickListener;
import com.itsaky.androidide.models.DiagnosticGroup;
import java.util.List;
import java.util.Objects;

public class DiagnosticsAdapter extends RecyclerView.Adapter<DiagnosticsAdapter.VH> {

  private final List<DiagnosticGroup> diagnostics;
  private final DiagnosticClickListener listener;

  public DiagnosticsAdapter(List<DiagnosticGroup> diagnostics, DiagnosticClickListener listener) {
    this.diagnostics = Objects.requireNonNull(diagnostics);
    this.listener = listener;
  }

  @NonNull
  @Override
  public DiagnosticsAdapter.VH onCreateViewHolder(ViewGroup p1, int p2) {
    return new VH(
        LayoutDiagnosticGroupBinding.inflate(LayoutInflater.from(p1.getContext()), p1, false));
  }

  @Override
  public void onBindViewHolder(DiagnosticsAdapter.VH p1, int p2) {
    final DiagnosticGroup group = diagnostics.get(p2);
    final LayoutDiagnosticGroupBinding binding = p1.binding;

    binding.info.icon.setImageResource(group.icon);
    binding.info.title.setText(group.text);
    binding.diagnostics.setLayoutManager(new LinearLayoutManager(binding.diagnostics.getContext()));
    binding.diagnostics.setAdapter(
        new DiagnosticItemAdapter(group.diagnostics, group.file, listener));

    binding
        .info
        .getRoot()
        .setOnClickListener(
            v -> {
              if (listener != null) {
                listener.onGroupClick(group);
              }
            });
  }

  @Override
  public int getItemCount() {
    return diagnostics.size();
  }

  public class VH extends RecyclerView.ViewHolder {
    private LayoutDiagnosticGroupBinding binding;

    public VH(LayoutDiagnosticGroupBinding binding) {
      super(binding.getRoot());
      this.binding = binding;
    }
  }
}



================================================
File: java/com/itsaky/androidide/adapters/EditorBottomSheetTabAdapter.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.collection.LongSparseArray;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.viewpager2.adapter.FragmentStateAdapter;

import com.itsaky.androidide.fragments.debug.DebuggerFragment;
import com.itsaky.androidide.fragments.DiagnosticsListFragment;
import com.itsaky.androidide.fragments.SearchResultFragment;
import com.itsaky.androidide.fragments.output.AppLogFragment;
import com.itsaky.androidide.fragments.output.BuildOutputFragment;
import com.itsaky.androidide.fragments.output.IDELogFragment;
import com.itsaky.androidide.resources.R;
import java.util.ArrayList;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class EditorBottomSheetTabAdapter extends FragmentStateAdapter {

  private static final Logger LOG = LoggerFactory.getLogger(EditorBottomSheetTabAdapter.class);
  private final List<Tab> fragments;

  public EditorBottomSheetTabAdapter(@NonNull FragmentActivity fragmentActivity) {
    super(fragmentActivity);

    var index = -1;
    this.fragments = new ArrayList<>();
    this.fragments.add(
        new Tab(
            fragmentActivity.getString(R.string.build_output),
            BuildOutputFragment.class,
            ++index));
    this.fragments.add(
        new Tab(fragmentActivity.getString(R.string.app_logs), AppLogFragment.class, ++index));
    this.fragments.add(
        new Tab(fragmentActivity.getString(R.string.ide_logs), IDELogFragment.class, ++index));
    this.fragments.add(
        new Tab(
            fragmentActivity.getString(R.string.view_diags),
            DiagnosticsListFragment.class,
            ++index));
    this.fragments.add(
        new Tab(
            fragmentActivity.getString(R.string.view_search_results),
            SearchResultFragment.class,
            ++index));
    this.fragments.add(
            new Tab(
                    fragmentActivity.getString(R.string.debugger_title),
                    DebuggerFragment.class,
                    ++index));
  }

  public Fragment getFragmentAtIndex(int index) {
    return getFragmentById(getItemId(index));
  }

  @Nullable
  public Fragment getFragmentById(long itemId) {
    final var fragments = getFragments();
    if (fragments != null) {
      return fragments.get(itemId);
    }

    return null;
  }

  @Nullable
  private LongSparseArray<Fragment> getFragments() {
    try {
      final var field = FragmentStateAdapter.class.getDeclaredField("mFragments");
      field.setAccessible(true);
        //noinspection unchecked
        return (LongSparseArray<Fragment>) field.get(this);
    } catch (Throwable th) {
      LOG.error("Unable to reflect fragment list from adapter.");
    }

    return null;
  }

  @NonNull
  @Override
  public Fragment createFragment(int position) {
    try {
      final var tab = fragments.get(position);
      final var klass = Class.forName(tab.name).asSubclass(Fragment.class);
      final var constructor = klass.getDeclaredConstructor();
      constructor.setAccessible(true);
      return constructor.newInstance();
    } catch (Throwable th) {
      throw new RuntimeException("Unable to create fragment", th);
    }
  }

  @Override
  public int getItemCount() {
    return fragments.size();
  }

  public String getTitle(int position) {
    return fragments.get(position).title;
  }

  @Nullable
  public BuildOutputFragment getBuildOutputFragment() {
    return findFragmentByClass(BuildOutputFragment.class);
  }

  @Nullable
  private <T extends Fragment> T findFragmentByClass(Class<T> clazz) {
    final var name = clazz.getName();
    for (final var tab : this.fragments) {
      if (tab.name.equals(name)) {
          //noinspection unchecked
          return (T) getFragmentById(tab.itemId);
      }
    }

    return null;
  }

  @Nullable
  public AppLogFragment getLogFragment() {
    return findFragmentByClass(AppLogFragment.class);
  }

  @Nullable
  public DiagnosticsListFragment getDiagnosticsFragment() {
    return findFragmentByClass(DiagnosticsListFragment.class);
  }

  @Nullable
  public SearchResultFragment getSearchResultFragment() {
    return findFragmentByClass(SearchResultFragment.class);
  }

  public <T extends Fragment> int findIndexOfFragmentByClass(@NonNull Class<T> tClass) {
    final var name = tClass.getName();
    for (int i = 0; i < this.fragments.size(); i++) {
      final var tab = this.fragments.get(i);
      if (tab.name.equals(name)) {
        return i;
      }
    }

    return -1;
  }

  static class Tab {

    final String title;
    final String name;
    final long itemId;

    public Tab(String title, @NonNull Class<? extends Fragment> fragment, long id) {
      this.title = title;
      this.name = fragment.getName();
      this.itemId = id;
    }
  }
}



================================================
File: java/com/itsaky/androidide/adapters/FilterableRecyclerViewAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters

import android.annotation.SuppressLint
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.DiffUtil.Callback
import androidx.recyclerview.widget.DiffUtil.DiffResult
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Filterable [RecyclerView.Adapter].
 *
 * @author Akash Yadav
 */
abstract class FilterableRecyclerViewAdapter<V : RecyclerView.ViewHolder, D>(val items: List<D>) :
  RecyclerView.Adapter<V>() {

  protected var filtered: List<D> = mutableListOf<D>().apply { addAll(items) }
  private var filterJob: Job? = null

  /**
   * Filter the list with the given query.
   *
   * @param query The query.
   */
  @SuppressLint("NotifyDataSetChanged")
  fun filter(query: String?) {
    filterJob?.cancel(CancellationException("A new query has been submitted for filtering"))

    val items = this.items
    filterJob = CoroutineScope(Dispatchers.Default).launch {
      val (filtered, result) = doFilter(query?.trim(), items)

      withContext(Dispatchers.Main) {
        val adapter = this@FilterableRecyclerViewAdapter
        if (result == null) {
          adapter.filtered = adapter.items
          notifyDataSetChanged()
          return@withContext
        }

        adapter.filtered = filtered
        result.dispatchUpdatesTo(adapter)
      }
    }
  }

  private fun doFilter(
    query: String?,
    items: List<D>,
  ): Pair<List<D>, DiffResult?> {
    if (query.isNullOrBlank()) {
      return items to null
    }

    val filtered = items.filter {
      onFilter(it, query)
    }

    val result =
      DiffUtil.calculateDiff(
        object : Callback() {
          override fun getOldListSize(): Int {
            return items.size
          }

          override fun getNewListSize(): Int {
            return filtered.size
          }

          override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
            return items[oldItemPosition] == filtered[newItemPosition]
          }

          override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
            return items[oldItemPosition] == filtered[newItemPosition]
          }
        }
      )

    return filtered to result
  }

  /** Get the list item at given index. */
  fun getItem(index: Int): D {
    return filtered[index]
  }

  override fun getItemCount(): Int {
    return filtered.size
  }

  /** Get the query candidate for the given list item. */
  abstract fun getQueryCandidate(item: D): String

  /** Called on every item when filtering the data. */
  protected open fun onFilter(item: D, query: String): Boolean {
    return getQueryCandidate(item).contains(query, ignoreCase = true)
  }
}



================================================
File: java/com/itsaky/androidide/adapters/MainActionsListAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.databinding.LayoutMainActionItemBinding
import com.itsaky.androidide.models.MainScreenAction
import com.itsaky.androidide.utils.AndroidUtils

/**
 * Adapter for the actions available on the main screen.
 *
 * @author Akash Yadav
 */
class MainActionsListAdapter
@JvmOverloads
constructor(val actions: List<MainScreenAction> = emptyList()) :
    RecyclerView.Adapter<MainActionsListAdapter.VH>() {
    inner class VH(val binding: LayoutMainActionItemBinding) : RecyclerView.ViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        VH(LayoutMainActionItemBinding.inflate(LayoutInflater.from(parent.context), parent, false))

    override fun getItemCount(): Int = actions.size

    fun getAction(index: Int) = actions[index]

    override fun onBindViewHolder(holder: VH, position: Int) {
        val action = getAction(index = position)
        val binding = holder.binding
        val button = binding.root

        binding.root.apply {
            val originalText = context.getString(action.text)
            text = originalText
            setIconResource(action.icon)
            setOnClickListener {
                action.onClick?.invoke(action, it)
            }
            setOnLongClickListener {
                action.onLongClick?.invoke(action, it)
                true
            }
            action.view = button
        }
    }
}



================================================
File: java/com/itsaky/androidide/adapters/OptionsSheetAdapter.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/

package com.itsaky.androidide.adapters;

import android.view.LayoutInflater;
import android.view.ViewGroup;
import androidx.recyclerview.widget.RecyclerView;
import com.itsaky.androidide.databinding.LayoutOptionssheetItemBinding;
import com.itsaky.androidide.models.SheetOption;
import java.util.List;

public class OptionsSheetAdapter extends RecyclerView.Adapter<OptionsSheetAdapter.VH> {

  private OnOptionsClickListener listener;
  private List<SheetOption> options;

  public OptionsSheetAdapter(List<SheetOption> options, OnOptionsClickListener listener) {
    this.options = options;
    this.listener = listener;
  }

  @Override
  public OptionsSheetAdapter.VH onCreateViewHolder(ViewGroup p1, int p2) {
    return new VH(
        LayoutOptionssheetItemBinding.inflate(LayoutInflater.from(p1.getContext()), p1, false));
  }

  @Override
  public void onBindViewHolder(OptionsSheetAdapter.VH p1, int p2) {
    final LayoutOptionssheetItemBinding binding = p1.binding;
    final SheetOption option = options.get(p2);

    binding.text.setText(option.title);
    binding.icon.setImageDrawable(option.icon);

    binding
        .getRoot()
        .setOnClickListener(
            v -> {
              if (listener != null) listener.onOptionClick(option);
            });
  }

  @Override
  public int getItemCount() {
    return options.size();
  }

  public class VH extends RecyclerView.ViewHolder {
    private LayoutOptionssheetItemBinding binding;

    public VH(LayoutOptionssheetItemBinding binding) {
      super(binding.getRoot());
      this.binding = binding;
    }
  }

  public static interface OnOptionsClickListener {
    public void onOptionClick(SheetOption option);
  }
}



================================================
File: java/com/itsaky/androidide/adapters/RecentProjectsAdapter.kt
================================================
package com.itsaky.androidide.adapters

import android.content.Context
import android.text.Editable
import android.text.TextWatcher

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.WindowManager
import android.view.animation.AnimationUtils
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.PopupMenu
import androidx.appcompat.widget.TooltipCompat
import androidx.recyclerview.widget.RecyclerView
import com.blankj.utilcode.util.FileUtils
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.android.material.textfield.TextInputLayout
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.SavedRecentProjectItemBinding
import com.itsaky.androidide.tasks.executeAsync
import com.itsaky.androidide.utils.FlashType
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashMessage
import com.itsaky.androidide.utils.flashSuccess
import com.itsvks.layouteditor.ProjectFile
import com.itsvks.layouteditor.databinding.TextinputlayoutBinding
import com.itsvks.layouteditor.utils.FileUtil
import java.io.File
import java.text.SimpleDateFormat
import java.util.Locale

class RecentProjectsAdapter(
    private var projects: List<ProjectFile>,
    private val onProjectClick: (File) -> Unit,
    private val onOpenFileFromFolderClick: () -> Unit,
    private val onRemoveProjectClick: (ProjectFile) -> Unit,
    private val onFileRenamed: (RenamedFile) -> Unit,
) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {

    private companion object {
        const val VIEW_TYPE_PROJECT = 0
        const val VIEW_TYPE_OPEN_FOLDER = 1
    }

    override fun getItemCount(): Int = projects.size + if (projects.isNotEmpty()) 1 else 0

    override fun getItemViewType(position: Int): Int =
        if (position < projects.size) VIEW_TYPE_PROJECT else VIEW_TYPE_OPEN_FOLDER

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        return when (viewType) {
            VIEW_TYPE_PROJECT -> {
                val binding = SavedRecentProjectItemBinding.inflate(inflater, parent, false)
                ProjectViewHolder(binding)
            }

            else -> {
                val view =
                    inflater.inflate(R.layout.saved_project_open_folder_layout, parent, false)
                OpenFolderViewHolder(view)
            }
        }
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        when (holder) {
            is ProjectViewHolder -> holder.bind(projects[position])
            is OpenFolderViewHolder -> holder.bind()
        }
    }

    fun updateProjects(newProjects: List<ProjectFile>) {
        projects = newProjects
        notifyDataSetChanged()
    }

    inner class ProjectViewHolder(private val binding: SavedRecentProjectItemBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(project: ProjectFile) {
            binding.projectName.text = project.name
            binding.projectDate.text = formatDate(project.date ?: "")
            binding.icon.text = project.name
                .split(" ")
                .mapNotNull { it.firstOrNull()?.uppercaseChar() }
                .take(2)
                .joinToString("")

            TooltipCompat.setTooltipText(
                binding.menu,
                binding.root.context.getString(R.string.options)
            )
            TooltipCompat.setTooltipText(binding.root, project.name)
            binding.root.animation =
                AnimationUtils.loadAnimation(binding.root.context, R.anim.project_list_animation)

            binding.root.setOnClickListener {
                onProjectClick(File(project.path))
            }
            binding.menu.setOnClickListener {
                showPopupMenu(it, adapterPosition)
            }
        }

        private fun formatDate(dateString: String): String {
            return try {
                val inputFormat =
                    SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy", Locale.getDefault())
                val date = inputFormat.parse(dateString)
                val day = SimpleDateFormat("d", Locale.ENGLISH).format(date).toInt()
                val suffix = when {
                    day in 11..13 -> "th"
                    day % 10 == 1 -> "st"
                    day % 10 == 2 -> "nd"
                    day % 10 == 3 -> "rd"
                    else -> "th"
                }
                SimpleDateFormat("d'$suffix', MMMM yyyy", Locale.getDefault()).format(date)
            } catch (e: Exception) {
                dateString.take(5)
            }
        }
    }

    inner class OpenFolderViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        fun bind() {
            itemView.visibility = if (projects.isEmpty()) View.GONE else View.VISIBLE
            itemView.setOnClickListener { onOpenFileFromFolderClick() }
        }
    }

    private fun showPopupMenu(view: View, position: Int) {
        PopupMenu(view.context, view).apply {
            inflate(R.menu.menu_recent_projects)
            setOnMenuItemClickListener { item ->
                when (item.itemId) {
                    R.id.menu_delete -> {
                        showDeleteDialog(view.context, position)
                        true
                    }

                    R.id.menu_rename -> {
                        promptRenameProject(view, position)
                        true
                    }

                    else -> false
                }
            }
            show()
        }
    }

    private fun showDeleteDialog(context: Context, position: Int) {
        val project = projects[position]
        MaterialAlertDialogBuilder(context)
            .setTitle(R.string.delete_project)
            .setMessage(R.string.msg_delete_project)
            .setNegativeButton(R.string.no) { dialog, _ -> dialog.dismiss() }
            .setPositiveButton(R.string.yes) { _, _ ->
                onRemoveProjectClick(project)
                executeAsync({ FileUtils.delete(project.path) }) {
                    val deleted = it ?: false
                    if (!deleted) {
                        return@executeAsync
                    }
                }
            }
            .show()
    }

    private fun promptRenameProject(view: View, position: Int) {
        val context = view.context
        val project = projects[position]
        val oldName = projects[position].name
        val builder = MaterialAlertDialogBuilder(context).setTitle(R.string.rename_project)

        val binding = TextinputlayoutBinding.inflate(LayoutInflater.from(context))
        binding.textinputEdittext.setText(project.name)
        binding.textinputLayout.hint = context.getString(R.string.msg_new_project_name)
        val padding = (16 * context.resources.displayMetrics.density).toInt()
        builder.setView(binding.root, padding, padding, padding, padding)

        builder.setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
        builder.setPositiveButton(R.string.rename) { _, _ ->
            val newName = binding.textinputEdittext.text.toString()
            val newPath = project.path.substringBeforeLast("/") + "/" + newName
            try {
                project.rename(newPath)
                flashSuccess(R.string.renamed)
                onFileRenamed(RenamedFile(oldName, newName, newPath))
                notifyItemChanged(position)
            } catch (e: Exception) {
                flashError(R.string.rename_failed)
            }
        }

        val dialog = builder.create()
        dialog.window?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)
        dialog.show()

        binding.textinputEdittext.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
            override fun afterTextChanged(s: Editable?) {
                validateProjectName(binding.textinputLayout, s.toString(), project.name, dialog)
            }
        })

        validateProjectName(
            binding.textinputLayout,
            binding.textinputEdittext.text.toString(),
            project.name,
            dialog
        )
    }

    private fun validateProjectName(
        inputLayout: TextInputLayout, newName: String, currentName: String, dialog: AlertDialog
    ) {
        val positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
        when {
            newName.isEmpty() -> {
                inputLayout.error = dialog.context.getString(R.string.msg_cannnot_empty)
                positiveButton.isEnabled = false
            }

            else -> {
                inputLayout.error = null
                positiveButton.isEnabled = true
            }
        }
    }

    data class RenamedFile(val oldName: String, val newName: String, val newPath: String)
}



================================================
File: java/com/itsaky/androidide/adapters/RunTasksListAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.adapters.RunTasksListAdapter.VH
import com.itsaky.androidide.databinding.LayoutRunTaskItemBinding
import com.itsaky.androidide.models.Checkable
import com.itsaky.androidide.tooling.api.models.GradleTask
import com.itsaky.androidide.utils.AndroidUtils

/**
 * Adapter for showing tasks list in [RunTaskDialogFragment]
 * [com.itsaky.androidide.fragments.RunTasksDialogFragment].
 *
 * @author Akash Yadav
 */
class RunTasksListAdapter
@JvmOverloads
constructor(
  tasks: List<Checkable<GradleTask>>,
  val onCheckChanged: (Checkable<GradleTask>) -> Unit = {}
) : FilterableRecyclerViewAdapter<VH, Checkable<GradleTask>>(tasks) {

  data class VH(val binding: LayoutRunTaskItemBinding) : RecyclerView.ViewHolder(binding.root)

  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
    return VH(LayoutRunTaskItemBinding.inflate(LayoutInflater.from(parent.context), parent, false))
  }

  override fun onBindViewHolder(holder: VH, position: Int) {
    val binding = holder.binding
    val data = getItem(position)
    val task = data.data

    binding.check.isChecked = data.isChecked
    binding.taskPath.text = task.path
    binding.taskDesc.text = task.description

    binding.root.setOnClickListener {
      data.isChecked = !data.isChecked
      binding.check.isChecked = data.isChecked
      onCheckChanged(data)
    }
  }

  override fun getQueryCandidate(item: Checkable<GradleTask>): String {
    return item.data.path
  }
}



================================================
File: java/com/itsaky/androidide/adapters/SearchListAdapter.kt
================================================
/**
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with AndroidIDE. If not,
 * see <https:></https:>//www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.adapters

import android.graphics.PorterDuff.Mode.SRC_ATOP
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView.Adapter
import androidx.recyclerview.widget.RecyclerView.ViewHolder
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.adapters.SearchListAdapter.VH
import com.itsaky.androidide.databinding.LayoutSearchResultGroupBinding
import com.itsaky.androidide.databinding.LayoutSearchResultItemBinding
import com.itsaky.androidide.models.FileExtension
import com.itsaky.androidide.models.SearchResult
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import com.itsaky.androidide.syntax.highlighters.JavaHighlighter
import com.itsaky.androidide.utils.resolveAttr
import java.io.File
import java.util.concurrent.CompletableFuture

class SearchListAdapter(
  private val results: Map<File, List<SearchResult>?>,
  private val onFileClick: (File) -> Unit,
  private val onMatchClick: (SearchResult) -> Unit,
  private val keys: List<File>
) : Adapter<VH>() {

  constructor(
    results: Map<File, List<SearchResult>?>,
    onFileClick: (File) -> Unit,
    onMatchClick: (SearchResult) -> Unit
  ) : this(results, onFileClick, onMatchClick, results.keys.toList())

  override fun onCreateViewHolder(p1: ViewGroup, p2: Int): VH {
    return VH(LayoutSearchResultGroupBinding.inflate(LayoutInflater.from(p1.context)))
  }

  override fun onBindViewHolder(p1: VH, p2: Int) {
    val binding = p1.binding
    val file = keys[p2]
    val matches = results[file] ?: listOf()
    val color = binding.icon.context.resolveAttr(R.attr.colorPrimary)
    binding.title.text = file.name
    binding.icon.setImageResource(FileExtension.Factory.forFile(file).icon)
    binding.icon.setColorFilter(color, SRC_ATOP)
    binding.items.layoutManager = LinearLayoutManager(binding.items.context)
    binding.items.adapter = ChildAdapter(matches)
    binding.root.setOnClickListener { onFileClick(file) }
  }

  override fun getItemCount(): Int {
    return results.size
  }

  inner class ChildAdapter(val matches: List<SearchResult>) : Adapter<ChildVH>() {

    override fun onCreateViewHolder(p1: ViewGroup, p2: Int): ChildVH {
      return ChildVH(LayoutSearchResultItemBinding.inflate(LayoutInflater.from(p1.context)))
    }

    override fun onBindViewHolder(p1: ChildVH, p2: Int) {
      val match = matches[p2]
      val binding = p1.binding
      CompletableFuture.runAsync {
        try {
          val scheme = SchemeAndroidIDE.newInstance(binding.text.context)
          val sb = JavaHighlighter().highlight(scheme, match.line, match.match)
          ThreadUtils.runOnUiThread { binding.text.text = sb }
        } catch (e: Exception) {
          ThreadUtils.runOnUiThread { binding.text.text = match.match }
        }
      }
      binding.root.setOnClickListener { onMatchClick(match) }
    }

    override fun getItemCount(): Int {
      return matches.size
    }
  }

  class VH(val binding: LayoutSearchResultGroupBinding) : ViewHolder(binding.root)
  class ChildVH(val binding: LayoutSearchResultItemBinding) : ViewHolder(binding.root)
}



================================================
File: java/com/itsaky/androidide/adapters/SymbolInputAdapter.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.adapters;

import static com.itsaky.androidide.utils.ContextUtilsKt.resolveAttr;

import android.annotation.SuppressLint;
import android.view.LayoutInflater;
import android.view.ViewGroup;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.widget.TooltipCompat;
import androidx.recyclerview.widget.RecyclerView;
import com.itsaky.androidide.R;
import com.itsaky.androidide.databinding.LayoutSymbolItemBinding;
import com.itsaky.androidide.editor.ui.IDEEditor;
import com.itsaky.androidide.models.Symbol;
import io.github.rosemoe.sora.widget.SelectionMovement;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class SymbolInputAdapter extends RecyclerView.Adapter<SymbolInputAdapter.VH> {

  private static final List<Character> pairs;

  static {
    pairs = new ArrayList<>();
    pairs.add('}');
    pairs.add(')');
    pairs.add(']');
    pairs.add('"');
    pairs.add('\'');
    pairs.add('>');
  }

  private IDEEditor editor;
  private final List<Symbol> symbols;

  public SymbolInputAdapter(IDEEditor editor) {
    this(editor, null);
  }

  public SymbolInputAdapter(IDEEditor editor, List<Symbol> symbols) {
    this.editor = editor;
    this.symbols = new ArrayList<>();
    this.updateItems(symbols);
  }

  private void updateItems(List<Symbol> symbols) {
    if (symbols == null) {
      return;
    }

    this.symbols.clear();
    this.symbols.addAll(symbols);
    this.symbols.removeIf(Objects::isNull);
  }

  @SuppressLint("NotifyDataSetChanged")
  public void refresh(IDEEditor editor, List<Symbol> newSymbols) {
    this.editor = Objects.requireNonNull(editor);

    if (this.symbols.equals(newSymbols)) {
      // no need to update symbols
      return;
    }

    updateItems(newSymbols);
    notifyDataSetChanged();
  }

  @NonNull
  @Override
  public VH onCreateViewHolder(@NonNull ViewGroup parent, int itemType) {
    return new VH(
        LayoutSymbolItemBinding.inflate(LayoutInflater.from(parent.getContext()), parent, false));
  }

  @Override
  public void onBindViewHolder(@NonNull VH holder, int position) {
    final Symbol symbol = symbols.get(position);
    holder.binding.symbol.setText(symbol.getLabel());
    holder.binding.symbol.setTextColor(
            resolveAttr(holder.binding.symbol.getContext(), R.attr.colorOnSurface));

    String description = symbol.getDescription();

    if (!description.isEmpty()) {
      TooltipCompat.setTooltipText(holder.binding.symbol, description);
    }

    holder.binding.symbol.setOnClickListener(view ->
            insertSymbol(symbol.getCommit(), symbol.getOffset())
    );

    holder.binding.symbol.setOnLongClickListener(view -> {
      if (!description.isEmpty()) {
        Toast.makeText(view.getContext(), description, Toast.LENGTH_SHORT).show();
      }
      return true;
    });
  }

  @Override
  public int getItemCount() {
    return symbols.size();
  }

  void insertSymbol(String text, int selectionOffset) {
    if (selectionOffset < 0 || selectionOffset > text.length()) {
      return;
    }

    final var controller = editor.getSnippetController();
    if ("\t".equals(text) && controller.isInSnippet()) {
      controller.shiftToNextTabStop();
      return;
    }

    if ("\t".equals(text)) {
      editor.indentOrCommitTab();
      return;
    }

    var cur = editor.getText().getCursor();
    if (cur.isSelected()) {
      editor
          .getText()
          .delete(cur.getLeftLine(), cur.getLeftColumn(), cur.getRightLine(), cur.getRightColumn());
      editor.notifyIMEExternalCursorChange();
    }

    if (cur.getLeftColumn() < editor.getText().getColumnCount(cur.getLeftLine())
        && text.length() == 1
        && text.charAt(0) == editor.getText().charAt(cur.getLeftLine(), cur.getLeftColumn())
        && pairs.contains(text.charAt(0))) {
      editor.moveSelection(SelectionMovement.RIGHT);
    } else {
      editor.commitText(text);
      if (selectionOffset != text.length()) {
        editor.setSelection(
            cur.getRightLine(), cur.getRightColumn() - (text.length() - selectionOffset));
      }
    }
  }

  public static class VH extends RecyclerView.ViewHolder {

    LayoutSymbolItemBinding binding;

    public VH(LayoutSymbolItemBinding binding) {
      super(binding.getRoot());
      this.binding = binding;
    }
  }
}



================================================
File: java/com/itsaky/androidide/adapters/TemplateListAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.RecyclerView
import com.blankj.utilcode.util.ConvertUtils
import com.google.android.material.shape.CornerFamily
import com.itsaky.androidide.adapters.TemplateListAdapter.ViewHolder
import com.itsaky.androidide.databinding.LayoutTemplateListItemBinding
import com.itsaky.androidide.templates.Template
import com.itsaky.androidide.utils.AndroidUtils

/**
 * [RecyclerView.Adapter] for showing templates in a [RecyclerView].
 *
 * @author Akash Yadav
 */
class TemplateListAdapter(
  templates: List<Template<*>>,
  private val onClick: ((Template<*>, ViewHolder) -> Unit)? = null
) : RecyclerView.Adapter<ViewHolder>() {

  private val templates = templates.toMutableList()

  class ViewHolder(internal val binding: LayoutTemplateListItemBinding) :
    RecyclerView.ViewHolder(binding.root)

  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
    return ViewHolder(LayoutTemplateListItemBinding.inflate(
      LayoutInflater.from(parent.context),
      parent,
      false
    ))
  }

  override fun getItemCount(): Int {
    return templates.size
  }

  override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    holder.binding.apply {
      val template = templates[position]
      if (template == Template.EMPTY) {
        root.visibility = View.INVISIBLE
        return@apply
      }
      templateName.text = templateName.context.getString(template.templateName)
      templateIcon.setImageResource(template.thumb)
      templateIcon.shapeAppearanceModel =
        templateIcon.shapeAppearanceModel.toBuilder()
          .setAllCorners(CornerFamily.ROUNDED, ConvertUtils.dp2px(8f).toFloat())
          .build()

      root.setOnClickListener {
        onClick?.invoke(template, holder)
      }
    }
  }

  internal fun fillDiff(extras: Int) {
    val count = itemCount
    for (i in 1..extras) {
      templates.add(Template.EMPTY)
    }

    val diff = DiffUtil.calculateDiff(object : DiffUtil.Callback() {
      override fun getOldListSize(): Int {
        return count
      }

      override fun getNewListSize(): Int {
        return count + extras
      }

      override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        return newItemPosition < count && oldItemPosition == newItemPosition
      }

      override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        return areItemsTheSame(oldItemPosition, newItemPosition)
      }
    })

    diff.dispatchUpdatesTo(this)
  }
}



================================================
File: java/com/itsaky/androidide/adapters/TemplateWidgetsListAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters

import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.LinearLayout
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.adapters.TemplateWidgetsListAdapter.WidgetViewHolder
import com.itsaky.androidide.databinding.LayoutTemplateWidgetlistItemBinding
import com.itsaky.androidide.templates.ITemplateWidgetViewProvider
import com.itsaky.androidide.templates.Widget

/**
 * A [RecyclerView.Adapter] that is used to show the widgets from templates.
 *
 * @author Akash Yadav
 */
class TemplateWidgetsListAdapter(private val widgets: List<Widget<*>>) :
  RecyclerView.Adapter<WidgetViewHolder>() {

  class WidgetViewHolder(
    internal val binding: LayoutTemplateWidgetlistItemBinding
  ) : RecyclerView.ViewHolder(binding.root)

  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int
  ): WidgetViewHolder {
    return WidgetViewHolder(LayoutTemplateWidgetlistItemBinding.inflate(
      LayoutInflater.from(parent.context), parent, false))
  }

  override fun getItemCount(): Int {
    return widgets.size
  }

  override fun onBindViewHolder(holder: WidgetViewHolder, position: Int) {
    holder.binding.apply {
      val viewProvider = ITemplateWidgetViewProvider.getInstance()
      val widget = widgets[position]
      val view = viewProvider.createView(root.context, widget)

      root.removeAllViews()
      root.addView(view,
        LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
          ViewGroup.LayoutParams.WRAP_CONTENT))
    }
  }
}


================================================
File: java/com/itsaky/androidide/adapters/onboarding/DefaultOnboardingItemAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters.onboarding

import android.content.res.ColorStateList
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.databinding.LayoutOnboardingItemBinding
import com.itsaky.androidide.models.OnboardingItem

/**
 * Default implmentation of [RecyclerView.Adapter] for showing [OnboardingItem]s.
 *
 * @author Akash Yadav
 */
open class DefaultOnboardingItemAdapter<T : OnboardingItem>(
  protected val items: List<T>,
  protected val onItemClickListener: OnItemClickListener<T>? = null,
  protected val onItemLongClickListener: OnItemLongClickListener<T>? = null
) : RecyclerView.Adapter<DefaultOnboardingItemAdapter.ViewHolder>() {

  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
    return ViewHolder(
      LayoutOnboardingItemBinding.inflate(LayoutInflater.from(parent.context), parent, false))
  }

  override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    doBindViewHolder(holder, position, getItem(position), holder.binding)
  }

  protected open fun doBindViewHolder(
    holder: ViewHolder,
    position: Int,
    item: T,
    binding: LayoutOnboardingItemBinding
  ) {
    binding.content.title.text = item.title

    if (item.description.isNotBlank()) {
      binding.content.description.text = item.description
    } else {
      binding.content.description.visibility = View.INVISIBLE
    }

    if (item.icon != 0) {
      binding.content.icon.setImageResource(item.icon)
      if (item.iconTint != 0) {
        binding.content.icon.supportImageTintList = ColorStateList.valueOf(item.iconTint)
      }
    } else {
      binding.content.icon.visibility = View.INVISIBLE
    }

    binding.root.isClickable = item.isClickable
    binding.root.isFocusable = item.isClickable

    if (item.isClickable && onItemClickListener != null) {
      binding.root.setOnClickListener { onItemClickListener.onClick(item, position, binding) }
    }

    if (item.isLongClickable && onItemLongClickListener != null) {
      binding.root.setOnLongClickListener { onItemLongClickListener.onLongClick(item, position, binding) }
    }
  }

  override fun getItemCount(): Int {
    return items.size
  }

  fun getItem(index: Int): T {
    return items[index]
  }

  class ViewHolder(val binding: LayoutOnboardingItemBinding) :
    RecyclerView.ViewHolder(binding.root)

  fun interface OnItemClickListener<T : OnboardingItem> {

    fun onClick(item: T, position: Int, binding: LayoutOnboardingItemBinding)
  }

  fun interface OnItemLongClickListener<T : OnboardingItem> {

    fun onLongClick(item: T, position: Int, binding: LayoutOnboardingItemBinding): Boolean
  }
}


================================================
File: java/com/itsaky/androidide/adapters/onboarding/OnboardingPermissionsAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.adapters.onboarding

import android.content.res.ColorStateList
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.blankj.utilcode.util.SizeUtils
import com.google.android.material.button.MaterialButton
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.LayoutOnboardingPermissionItemBinding
import com.itsaky.androidide.models.OnboardingPermissionItem

/**
 * @author Akash Yadav
 */
class OnboardingPermissionsAdapter(private val permissions: List<OnboardingPermissionItem>,
  private val requestPermission: (String) -> Unit) :
  RecyclerView.Adapter<OnboardingPermissionsAdapter.ViewHolder>() {

  class ViewHolder(val binding: LayoutOnboardingPermissionItemBinding) :
    RecyclerView.ViewHolder(binding.root)

  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
    return ViewHolder(
      LayoutOnboardingPermissionItemBinding.inflate(LayoutInflater.from(parent.context), parent,
        false))
  }

  override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    val binding = holder.binding
    val permission = permissions[position]

    binding.infoContent.apply {
      title.setText(permission.title)
      description.setText(permission.description)
    }

    binding.grantButton.setOnClickListener {
      requestPermission(permission.permission)
    }

    if (permission.isGranted) {
      binding.grantButton.apply {
        isEnabled = false
        text = ""
        icon = ContextCompat.getDrawable(binding.root.context, R.drawable.ic_ok)
        iconTint = ColorStateList.valueOf(
          ContextCompat.getColor(binding.root.context, R.color.green_500))
        iconGravity = MaterialButton.ICON_GRAVITY_TEXT_TOP
        iconPadding = 0
        iconSize = SizeUtils.dp2px(28f)
      }
    }
  }

  override fun getItemCount(): Int {
    return permissions.size
  }
}


================================================
File: java/com/itsaky/androidide/adapters/viewholders/FileTreeViewHolder.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/

package com.itsaky.androidide.adapters.viewholders;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.LinearLayout;
import androidx.transition.ChangeImageTransform;
import androidx.transition.TransitionManager;
import com.blankj.utilcode.util.SizeUtils;
import com.itsaky.androidide.databinding.LayoutFiletreeItemBinding;
import com.itsaky.androidide.models.FileExtension;
import com.itsaky.androidide.resources.R;
import com.unnamed.b.atv.model.TreeNode;
import java.io.File;

public class FileTreeViewHolder extends TreeNode.BaseNodeViewHolder<File> {

  private LayoutFiletreeItemBinding binding;

  public FileTreeViewHolder(Context context) {
    super(context);
  }

  @Override
  public View createNodeView(TreeNode node, File file) {
    this.binding = LayoutFiletreeItemBinding.inflate(LayoutInflater.from(context));

    final var dp15 = SizeUtils.dp2px(15);
    final var icon = getIconForFile(file);
    final var chevron = binding.filetreeChevron;
    binding.filetreeName.setText(file.getName());
    binding.filetreeIcon.setImageResource(icon);

    final var root = applyPadding(node, binding, dp15);

    if (file.isDirectory()) {
      chevron.setVisibility(View.VISIBLE);
      updateChevronIcon(node.isExpanded());
    } else {
      chevron.setVisibility(View.INVISIBLE);
    }

    return root;
  }

  private void updateChevronIcon(boolean expanded) {
    final int chevronIcon;
    if (expanded) {
      chevronIcon = R.drawable.ic_chevron_down;
    } else {
      chevronIcon = R.drawable.ic_chevron_right;
    }

    TransitionManager.beginDelayedTransition(binding.getRoot(), new ChangeImageTransform());
    binding.filetreeChevron.setImageResource(chevronIcon);
  }

  protected LinearLayout applyPadding(
      final TreeNode node, final LayoutFiletreeItemBinding binding, final int padding) {
    final var root = binding.getRoot();
    root.setPaddingRelative(
        root.getPaddingLeft() + (padding * (node.getLevel() - 1)),
        root.getPaddingTop(),
        root.getPaddingRight(),
        root.getPaddingBottom());
    return root;
  }

  protected int getIconForFile(final File file) {
    return FileExtension.Factory.forFile(file).getIcon();
  }

  public void updateChevron(boolean expanded) {
    setLoading(false);
    updateChevronIcon(expanded);
  }

  public void setLoading(boolean loading) {
    final int viewIndex;
    if (loading) {
      viewIndex = 1;
    } else {
      viewIndex = 0;
    }

    binding.chevronLoadingSwitcher.setDisplayedChild(viewIndex);
  }
}



================================================
File: java/com/itsaky/androidide/app/EdgeToEdgeIDEActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.app

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Configuration
import android.graphics.Rect
import android.os.Build
import android.os.Bundle
import android.os.PersistableBundle
import android.view.View
import android.view.WindowInsets
import android.view.WindowManager
import android.view.inputmethod.InputMethodManager
import androidx.annotation.CallSuper
import androidx.core.graphics.Insets
import androidx.core.view.OnApplyWindowInsetsListener
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.doOnAttach
import com.itsaky.androidide.utils.EdgeToEdgeUtils
import com.itsaky.androidide.utils.getSystemBarInsets
import org.slf4j.LoggerFactory

/**
 * Same as IDEActivity but DecorFitsSystemWindows is set to false
 * Useful for creating immersive edge-to-edge experiences.
 *
 * @author Smooth E
 * @author Akash Yadav
 */
abstract class EdgeToEdgeIDEActivity : IDEActivity() {

    /**
     * Whether edge-to-edge should be applied to the activity.
     */
    protected open var edgeToEdgeEnabled = true

    /**
     * Whether the decor view padding should be updated to match the system bars in landscape orientation.
     */
    protected open var eteUpdateDecorViewPaddingInLandscape = true

    /**
     * Style for the status bar.
     */
    protected open val statusBarStyle = EdgeToEdgeUtils.DEFAULT_STATUS_BAR_STYLE!!

    /**
     * Style for the navigation bar.
     */
    protected open val navigationBarStyle = EdgeToEdgeUtils.DEFAULT_NAVIGATION_BAR_STYLE!!

    /**
     * Original padding of the window's decor view.
     */
    protected open var decorViewPadding: Rect? = null

    /**
     * Last window insets.
     */
    protected open var systemBarInsets: Insets? = null

    override var enableSystemBarTheming: Boolean
        get() = false
        set(@Suppress("UNUSED_PARAMETER") value) {
            throw UnsupportedOperationException("Use edgeToEdgeEnabled and systemBarStyles instead")
        }

    private val log = LoggerFactory.getLogger(EdgeToEdgeIDEActivity::class.java)

    @SuppressLint("WrongConstant")
    private val onApplyWindowInsetsListener = OnApplyWindowInsetsListener { view, insets ->
        onApplyWindowInsets(insets)
        if (!eteUpdateDecorViewPaddingInLandscape ||
            view.resources.configuration.orientation != Configuration.ORIENTATION_LANDSCAPE
        ) {
            decorViewPadding?.also { p ->
                // when switching from landscape to portrait, restore the original padding
                view.setPadding(p.left, p.top, p.right, p.bottom)
            }
            return@OnApplyWindowInsetsListener insets
        }

        if (decorViewPadding == null) {
            Rect().apply {
                left = view.paddingLeft
                top = view.paddingTop
                right = view.paddingRight
                bottom = view.paddingBottom
            }.also { paddings ->
                decorViewPadding = paddings
            }
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val systemBarInsets = insets.getInsets(WindowInsets.Type.systemBars())
            view.setPadding(
                systemBarInsets.left,
                0,
                systemBarInsets.right,
                systemBarInsets.bottom
            )
        } else {
            @Suppress("DEPRECATION")
            view.setPadding(
                insets.stableInsetLeft,
                0,
                insets.stableInsetRight,
                insets.stableInsetBottom
            )
        }

        insets
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        applyEdgeToEdge()
        super.onCreate(savedInstanceState)
    }

    override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) {
        applyEdgeToEdge()
        super.onCreate(savedInstanceState, persistentState)
    }

    @SuppressLint("RestrictedApi")
    private fun applyEdgeToEdge() {
        this.window!!.apply {
            addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)
            @Suppress("DEPRECATION")
            clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)
        }

        EdgeToEdgeUtils.applyEdgeToEdge(this, this.statusBarStyle, this.navigationBarStyle)

        ViewCompat.setOnApplyWindowInsetsListener(
            this.window.decorView,
            this.onApplyWindowInsetsListener
        )

        this.window.decorView.doOnAttach { onApplySystemBarInsets(getSystemBarInsets(it)) }
    }

    /**
     * Called when the window insets change.
     *
     * @param insets The window insets. These insets are not expected to be consumed.
     */
    @CallSuper
    protected open fun onApplyWindowInsets(insets: WindowInsetsCompat) {
        this.systemBarInsets = getSystemBarInsets(insets)
    }

    /**
     * Called with the system bar insets when the decor view is attached to the window.
     */
    protected open fun onApplySystemBarInsets(insets: Insets) {}

    fun closeKeyboard() {
        // Get the current focused view; if none, create a new one so that we have a valid window token
        val view = currentFocus ?: View(this)
        // Retrieve the input method manager service
        val inputMethodManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        // Request to hide the keyboard from the window
        inputMethodManager.hideSoftInputFromWindow(view.windowToken, 0)
    }
}



================================================
File: java/com/itsaky/androidide/app/IDEActivity.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.app

abstract class IDEActivity : BaseIDEActivity() {

  val app: IDEApplication
    get() = application as IDEApplication
}



================================================
File: java/com/itsaky/androidide/app/IDEActivityDelegate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.app

import androidx.lifecycle.DefaultLifecycleObserver

/**
 * Delegate for [IDEActivity].
 *
 * @author Akash Yadav
 */
interface IDEActivityDelegate : DefaultLifecycleObserver {
}


================================================
File: java/com/itsaky/androidide/app/IDEApplication.kt
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

package com.itsaky.androidide.app

import android.content.Context
import android.content.Intent
import android.hardware.display.DisplayManager
import android.net.Uri
import android.os.StrictMode
import android.util.Log
import android.view.Display
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.os.LocaleListCompat
import androidx.lifecycle.Observer
import androidx.work.Operation
import androidx.work.WorkManager
import com.blankj.utilcode.util.ThrowableUtils.getFullStackTrace
import com.google.android.material.color.DynamicColors
import com.itsaky.androidide.BuildConfig
import com.itsaky.androidide.activities.CrashHandlerActivity
import com.itsaky.androidide.activities.SecondaryScreen
import com.itsaky.androidide.activities.editor.IDELogcatReader
import com.itsaky.androidide.buildinfo.BuildInfo
import com.itsaky.androidide.editor.schemes.IDEColorSchemeProvider
import com.itsaky.androidide.eventbus.events.preferences.PreferenceChangeEvent
import com.itsaky.androidide.events.AppEventsIndex
import com.itsaky.androidide.events.EditorEventsIndex
import com.itsaky.androidide.events.LspApiEventsIndex
import com.itsaky.androidide.events.LspJavaEventsIndex
import com.itsaky.androidide.events.ProjectsApiEventsIndex



import com.itsaky.androidide.preferences.internal.DevOpsPreferences
import com.itsaky.androidide.preferences.internal.GeneralPreferences
import com.itsaky.androidide.preferences.internal.StatPreferences
import com.itsaky.androidide.resources.localization.LocaleProvider
import com.itsaky.androidide.stats.StatUploadWorker
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import com.itsaky.androidide.treesitter.TreeSitter
import com.itsaky.androidide.ui.themes.IDETheme
import com.itsaky.androidide.ui.themes.IThemeManager
import com.itsaky.androidide.utils.RecyclableObjectPool
import com.itsaky.androidide.utils.VMUtils
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.isTestMode
import com.termux.app.TermuxApplication
import com.termux.shared.logger.Logger
import com.termux.shared.reflection.ReflectionUtils
import io.github.rosemoe.sora.widget.schemes.EditorColorScheme
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import org.greenrobot.eventbus.EventBus
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode
import org.slf4j.LoggerFactory
import java.lang.Thread.UncaughtExceptionHandler
import kotlin.system.exitProcess

class IDEApplication : TermuxApplication() {

    private var uncaughtExceptionHandler: UncaughtExceptionHandler? = null
    private var ideLogcatReader: IDELogcatReader? = null

    private val applicationScope = CoroutineScope(SupervisorJob())

    init {
        if (!VMUtils.isJvm() && !isTestMode()) {
            try {
                TreeSitter.loadLibrary()
            } catch (e: UnsatisfiedLinkError) {
                Log.w("IDEApplication", "TreeSitter native library not available: ${e.message}")
            }
        }

        RecyclableObjectPool.DEBUG = BuildConfig.DEBUG
    }

  
    @OptIn(DelicateCoroutinesApi::class)
    override fun onCreate() {
        instance = this
        uncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler()
        Thread.setDefaultUncaughtExceptionHandler { thread, th -> handleCrash(thread, th) }

        super.onCreate()

        if (BuildConfig.DEBUG) {
            val builder = StrictMode.VmPolicy.Builder()
            StrictMode.setVmPolicy(builder.build())
            //TODO JMT
//            StrictMode.setVmPolicy(
//                StrictMode.VmPolicy.Builder(StrictMode.getVmPolicy()).penaltyLog().detectAll()
//                    .build()
//            )
            if (DevOpsPreferences.dumpLogs) {
                startLogcatReader()
            }

            checkForSecondDisplay()


        }

        EventBus.builder().addIndex(AppEventsIndex()).addIndex(EditorEventsIndex())
            .addIndex(ProjectsApiEventsIndex()).addIndex(LspApiEventsIndex())
            .addIndex(LspJavaEventsIndex()).installDefaultEventBus(true)

        EventBus.getDefault().register(this)

        AppCompatDelegate.setDefaultNightMode(GeneralPreferences.uiMode)

        if (IThemeManager.getInstance().getCurrentTheme() == IDETheme.MATERIAL_YOU) {
            DynamicColors.applyToActivitiesIfAvailable(this)
        }

        EditorColorScheme.setDefault(SchemeAndroidIDE.newInstance(null))

        ReflectionUtils.bypassHiddenAPIReflectionRestrictions()
        GlobalScope.launch {
            IDEColorSchemeProvider.init()
        }



        //Tooltip database access is now handled by direct SQLite queries
    }

    private fun handleCrash(thread: Thread, th: Throwable) {
        writeException(th)

        try {
            val intent = Intent()
            intent.action = CrashHandlerActivity.REPORT_ACTION
            intent.putExtra(CrashHandlerActivity.TRACE_KEY, getFullStackTrace(th))
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            startActivity(intent)
            if (uncaughtExceptionHandler != null) {
                uncaughtExceptionHandler!!.uncaughtException(thread, th)
            }

            exitProcess(1)
        } catch (error: Throwable) {
            log.error("Unable to show crash handler activity", error)
        }
    }

    fun showChangelog() {
        val intent = Intent(Intent.ACTION_VIEW)
        var version = BuildInfo.VERSION_NAME_SIMPLE
        if (!version.startsWith('v')) {
            version = "v${version}"
        }
        intent.data = Uri.parse("${BuildInfo.REPO_URL}/releases/tag/${version}")
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        try {
            startActivity(intent)
        } catch (th: Throwable) {
            log.error("Unable to start activity to show changelog", th)
            flashError("Unable to start activity")
        }
    }

    fun reportStatsIfNecessary() {

//        if (!StatPreferences.statOptIn) {
//            log.info("Stat collection is disabled.")
//            return
//        }
//
//        val constraints =
//            Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build()
//        val request =
//            PeriodicWorkRequestBuilder<StatUploadWorker>(Duration.ofHours(24)).setInputData(
//                AndroidIDEStats.statData.toInputData()
//            ).setConstraints(constraints)
//                .addTag(StatUploadWorker.WORKER_WORK_NAME).build()
//
//        val workManager = WorkManager.getInstance(this)
//
//        log.info("reportStatsIfNecessary: Enqueuing StatUploadWorker...")
//        val operation = workManager.enqueueUniquePeriodicWork(
//            StatUploadWorker.WORKER_WORK_NAME,
//            ExistingPeriodicWorkPolicy.UPDATE, request
//        )
//
//        operation.state.observeForever(object : Observer<Operation.State> {
//            override fun onChanged(value: Operation.State) {
//                operation.state.removeObserver(this)
//                log.debug("reportStatsIfNecessary: WorkManager enqueue result: {}", value)
//            }
//        })
    }

    private fun startLogcatReader() {
        if (ideLogcatReader != null) {
            // already started
            return
        }

        log.info("Starting logcat reader...")
        ideLogcatReader = IDELogcatReader().also { it.start() }
    }

    private fun stopLogcatReader() {
        log.info("Stopping logcat reader...")
        ideLogcatReader?.stop()
        ideLogcatReader = null
    }

    @Subscribe(threadMode = ThreadMode.MAIN)
    fun onPrefChanged(event: PreferenceChangeEvent) {
        val enabled = event.value as? Boolean?
        if (event.key == StatPreferences.STAT_OPT_IN) {
            if (enabled == true) {
                reportStatsIfNecessary()
            } else {
                cancelStatUploadWorker()
            }
        } else if (event.key == DevOpsPreferences.KEY_DEVOPTS_DEBUGGING_DUMPLOGS) {
            if (enabled == true) {
                startLogcatReader()
            } else {
                stopLogcatReader()
            }
        } else if (event.key == GeneralPreferences.UI_MODE && GeneralPreferences.uiMode != AppCompatDelegate.getDefaultNightMode()) {
            AppCompatDelegate.setDefaultNightMode(GeneralPreferences.uiMode)
        } else if (event.key == GeneralPreferences.SELECTED_LOCALE) {

            // Use empty locale list if the locale has been reset to 'System Default'
            val selectedLocale = GeneralPreferences.selectedLocale
            val localeListCompat = selectedLocale?.let {
                LocaleListCompat.create(LocaleProvider.getLocale(selectedLocale))
            } ?: LocaleListCompat.getEmptyLocaleList()

            AppCompatDelegate.setApplicationLocales(localeListCompat)
        }
    }

    private fun cancelStatUploadWorker() {
        log.info("Opted-out of stat collection. Cancelling StatUploadWorker if enqueued...")
        val operation = WorkManager.getInstance(this)
            .cancelUniqueWork(StatUploadWorker.WORKER_WORK_NAME)
        operation.state.observeForever(object : Observer<Operation.State> {
            override fun onChanged(value: Operation.State) {
                operation.state.removeObserver(this)
                log.info("StatUploadWorker: Cancellation result state: {}", value)
            }
        })
    }

    private fun checkForSecondDisplay() {
        val displayManager = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
        val displays = displayManager.displays
        var secondDisplay: Display? = null
        for (display in displays) {
            if (display.displayId != Display.DEFAULT_DISPLAY) {
                // This is a secondary display
                secondDisplay = display
            }
        }
        if (secondDisplay != null) {
            val presentation = SecondaryScreen(this, secondDisplay!!)
            presentation.show()
        }
    }

    companion object {

        private val log = LoggerFactory.getLogger(IDEApplication::class.java)

        @JvmStatic
        lateinit var instance: IDEApplication
            private set
    }

}



================================================
File: java/com/itsaky/androidide/app/LlmInferenceEngine.kt
================================================
package com.itsaky.androidide.app

import android.content.res.AssetManager

/**
 * A singleton object to manage the lifecycle and interaction with the native
 * llama.cpp inference engine.
 */
object LlmInferenceEngine {

    // This init block is executed when the object is first accessed.
    // It loads the native shared library (.so file) into memory.
    // The name "android-ide-llm" must match the library name defined in CMakeLists.txt.
    init {
        System.loadLibrary("android-ide-llm")
    }

    /**
     * Initializes the LLM model from a file in the app's assets.
     * This is a potentially long-running operation and should be called from a background thread.
     *
     * @param assetManager The Android AssetManager instance, needed to access assets from native code.
     * @param modelPath The path to the GGUF model file within the assets directory.
     * @return A native pointer (as a Long) to the loaded model context. This pointer must be
     *         passed to other native functions. Returns 0 on failure.
     */
    external fun initModel(assetManager: AssetManager, modelPath: String): Long

    /**
     * Runs inference on the loaded model.
     * This is a computationally intensive and blocking operation that MUST be called
     * from a background thread.
     *
     * @param prompt The input text prompt for the model.
     * @param contextPtr The native pointer to the model context, obtained from initModel().
     * @return The generated text completion as a String.
     */
    external fun runInference(prompt: String, contextPtr: Long): String

    /**
     * Releases the native memory allocated for the model context.
     * This must be called when the model is no longer needed to prevent memory leaks.
     *
     * @param contextPtr The native pointer to the model context to be released.
     */
    external fun releaseModel(contextPtr: Long)
}


================================================
File: java/com/itsaky/androidide/app/configuration/IDEBuildConfigProviderImpl.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.app.configuration

import android.os.Build
import com.google.auto.service.AutoService
import com.itsaky.androidide.BuildConfig
import com.itsaky.androidide.app.BaseApplication

/**
 * @author Akash Yadav
 */
@AutoService(IDEBuildConfigProvider::class)
@Suppress("UNUSED")
open class IDEBuildConfigProviderImpl : IDEBuildConfigProvider {

  override val cpuAbiName: String by lazy {
    val applicationInfo = BaseApplication.getBaseInstance().applicationInfo!!

    // transform to valid ABI names
    return@lazy when (val abi = applicationInfo.nativeLibraryDir!!.substringAfterLast('/')) {
      "arm64" -> BuildConfig.ABI_ARM64_V8A
      "arm" -> BuildConfig.ABI_ARMEABI_V7A
      else -> abi
    }
  }

  override val cpuArch: CpuArch
    get() = CpuArch.forAbi(cpuAbiName)!!

  override val deviceArch: CpuArch
    get() = CpuArch.forAbi(Build.SUPPORTED_ABIS[0])!!

  override val supportedAbis: Array<String> by lazy {
    arrayOf(BuildConfig.ABI_ARM64_V8A, BuildConfig.ABI_ARMEABI_V7A, BuildConfig.ABI_X86_64)
  }
}


================================================
File: java/com/itsaky/androidide/app/configuration/JdkDistributionProviderImpl.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.app.configuration

import com.google.auto.service.AutoService
import com.itsaky.androidide.models.JdkDistribution
import com.itsaky.androidide.preferences.internal.BuildPreferences
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.JdkUtils
import org.slf4j.LoggerFactory
import java.io.File

/**
 * @author Akash Yadav
 */
@AutoService(IJdkDistributionProvider::class)
class JdkDistributionProviderImpl : IJdkDistributionProvider {

  companion object {

    private val log = LoggerFactory.getLogger(JdkDistributionProviderImpl::class.java)
  }

  private var _installedDistributions: List<JdkDistribution>? = null

  override val installedDistributions: List<JdkDistribution>
    get() = _installedDistributions ?: emptyList()

  override fun loadDistributions() {
    _installedDistributions = doLoadDistributions()
  }

    private fun doLoadDistributions(): List<JdkDistribution> {
        return JdkUtils.findJavaInstallations().also { distributions ->
            if(distributions.isEmpty()) {
                return emptyList()
            }

            val selectedJavaHome = findDefaultDistribution(distributions)?.javaHome?.let { File(it) }
                ?: distributions.first().javaHome.let { File(it) }

            log.debug("Setting Environment.JAVA_HOME to {}", selectedJavaHome.absolutePath)
            Environment.JAVA_HOME = selectedJavaHome
            Environment.JAVA = selectedJavaHome.resolve("bin/java")
        }
    }

  private fun findDefaultDistribution(distributions: List<JdkDistribution>): JdkDistribution? {
    return distributions.find {
      it.javaVersion.startsWith(IJdkDistributionProvider.DEFAULT_JAVA_VERSION)
    }
  }

  private fun isValidJavaHome(javaHome: File): Boolean {
    val javaExec = javaHome.resolve("bin/java")
    return javaHome.exists() && javaExec.exists() && javaExec.isFile && javaExec.canExecute()
  }
}


================================================
File: java/com/itsaky/androidide/contributors/Contributor.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.contributors

/**
 * A contributor.
 *
 * @author Akash Yadav
 */
interface Contributor {

  /**
   * Unique integer ID.
   */
  val id: Int

  /**
   * Unique username.
   */
  val username: String

  /**
   * URL for the contributor's avatar.
   */
  val avatarUrl: String

  /**
   * URL for the contributor's profile.
   */
  val profileUrl: String
}


================================================
File: java/com/itsaky/androidide/contributors/Contributors.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.contributors

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import retrofit2.Call
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

/**
 * @author Akash Yadav
 */
internal object Contributors {

  private val log = LoggerFactory.getLogger(Contributors::class.java)

  @JvmStatic
  suspend inline fun <reified Service, reified Model : Contributor> getAllContributors(
    baseUrl: String,
    crossinline action: (Service) -> Call<List<Model>>
  ): List<Model> {
    val retrofit = Retrofit.Builder()
      .baseUrl(baseUrl)
      .addConverterFactory(GsonConverterFactory.create())
      .build()

    val service = retrofit.create(Service::class.java)
    return withContext(Dispatchers.IO) {
      try {
        val response = action(service).execute()
        if (!response.isSuccessful) {
          log.error(
            "Failed to get contributors list [${Model::class.java.name}], request unsuccessful",
            response.errorBody()?.string() ?: "(empty error response)"
          )
          return@withContext emptyList()
        }

        return@withContext response.body() ?: run {
          log.error("Response body is null")
          emptyList()
        }
      } catch (err: Throwable) {
        err.printStackTrace()
        emptyList()
      }
    }
  }
}


================================================
File: java/com/itsaky/androidide/contributors/CrowdinTranslator.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.contributors

import com.google.gson.annotations.SerializedName
import retrofit2.Call
import retrofit2.http.GET

private interface CrowdinTranslatorsService {

  @GET(CrowdinTranslators.CROWDIN_CONTRIBUTORS_JSON)
  fun getAllTranslators(): Call<List<CrowdinTranslator>>
}

object CrowdinTranslators {

  internal const val CROWDIN_CONTRIBUTORS_JSON = "crowdin-contributors.json"

  /**
   * Get all Crowdin translators.
   */
  suspend fun getAllTranslators(): List<CrowdinTranslator> {
    return Contributors.getAllContributors<CrowdinTranslatorsService, CrowdinTranslator>(
      "${GITHUB_RAW_API_REPO_BRANCH_URL}/",
      CrowdinTranslatorsService::getAllTranslators
    )
  }
}

/**
 * A Crowdin translator.
 *
 * @author Akash Yadav
 */
data class CrowdinTranslator(
  @SerializedName("id") private val _id: String,
  @SerializedName("username") override val username: String,
  @SerializedName("picture") override val avatarUrl: String,
) : Contributor {

  override val id: Int
    get() = _id.toInt()

  override val profileUrl: String
    get() = "${CROWDIN_PROFILE_BASE_URL}/$username"

  companion object {

    const val CROWDIN_PROFILE_BASE_URL = "https://crowdin.com/profile"
  }
}


================================================
File: java/com/itsaky/androidide/contributors/GitHubContributors.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.contributors

import com.google.gson.annotations.SerializedName
import retrofit2.Call
import retrofit2.http.GET

/**
 * @author Akash Yadav
 */
interface GitHubContributorsService {

  @GET("contributors")
  fun getAllContributors(): Call<List<GitHubContributor>>
}

object GitHubContributors {

  /**
   * Get all GitHub contributors.
   */
  suspend fun getAllContributors(): List<GitHubContributor> {
    return Contributors.getAllContributors<GitHubContributorsService, GitHubContributor>(
      "${GITHUB_API_REPO_URL}/",
      GitHubContributorsService::getAllContributors
    )
  }
}

/**
 * A GitHub contributor.
 */
data class GitHubContributor(
  @SerializedName("id") override val id: Int,
  @SerializedName("login") override val username: String,
  @SerializedName("avatar_url") override val avatarUrl: String,
  @SerializedName("html_url") override val profileUrl: String
) : Contributor


================================================
File: java/com/itsaky/androidide/contributors/common.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.contributors

import com.itsaky.androidide.buildinfo.BuildInfo

const val GITHUB_API_BASE_URL = "https://api.github.com"
const val GITHUB_API_REPOS_URL = "${GITHUB_API_BASE_URL}/repos"
const val GITHUB_API_REPO_URL = "${GITHUB_API_REPOS_URL}/${BuildInfo.REPO_OWNER}/${BuildInfo.REPO_NAME}"

const val GITHUB_RAW_API_BASE_URL = "https://raw.githubusercontent.com"
const val GITHUB_RAW_API_REPO_URL = "${GITHUB_RAW_API_BASE_URL}/${BuildInfo.REPO_OWNER}/${BuildInfo.REPO_NAME}"
const val GITHUB_RAW_API_REPO_BRANCH_URL = "${GITHUB_RAW_API_REPO_URL}/dev"


================================================
File: java/com/itsaky/androidide/events/FileTree.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.events

import com.itsaky.androidide.eventbus.events.Event
import com.itsaky.androidide.models.SheetOption
import com.unnamed.b.atv.model.TreeNode

internal data class FileContextMenuItemClickEvent(val option: SheetOption) : Event()

data class ExpandTreeNodeRequestEvent(val node: TreeNode) : Event()
data class CollapseTreeNodeRequestEvent(val node: TreeNode, val includeSubnodes: Boolean) : Event()

class ListProjectFilesRequestEvent : Event()



================================================
File: java/com/itsaky/androidide/events/InstallationResultEvent.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.events

import android.content.Intent

/**
 * Event posted by [com.itsaky.androidide.services.InstallationResultReceiver] when an event is
 * received.
 *
 * @author Akash Yadav
 */
data class InstallationResultEvent(val intent: Intent)



================================================
File: java/com/itsaky/androidide/fragments/BasePreferenceFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.os.Bundle
import androidx.preference.PreferenceFragmentCompat
import com.itsaky.androidide.R.xml

abstract class BasePreferenceFragment : PreferenceFragmentCompat() {

  override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
    setPreferencesFromResource(xml.ide_prefs, rootKey)
  }
}



================================================
File: java/com/itsaky/androidide/fragments/CrashReportFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.fragments

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.blankj.utilcode.util.ClipboardUtils
import com.itsaky.androidide.buildinfo.BuildInfo
import com.itsaky.androidide.databinding.LayoutCrashReportBinding
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.BuildInfoUtils

class CrashReportFragment : Fragment() {

  private var binding: LayoutCrashReportBinding? = null
  private var closeAppOnClick = true

  companion object {

    const val KEY_TITLE = "crash_title"
    const val KEY_MESSAGE = "crash_message"
    const val KEY_TRACE = "crash_trace"
    const val KEY_CLOSE_APP_ON_CLICK = "close_on_app_click"

    @JvmStatic
    fun newInstance(trace: String): CrashReportFragment {
      return newInstance(null, null, trace, true)
    }

    @JvmStatic
    fun newInstance(
      title: String?,
      message: String?,
      trace: String,
      closeAppOnClick: Boolean
    ): CrashReportFragment {
      val frag = CrashReportFragment()
      val args = Bundle().apply {
        putString(KEY_TRACE, trace)
        putBoolean(KEY_CLOSE_APP_ON_CLICK, closeAppOnClick)
        title?.let { putString(KEY_TITLE, it) }
        message?.let { putString(KEY_MESSAGE, it) }
      }
      frag.arguments = args
      return frag
    }
  }

  override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View {
    return LayoutCrashReportBinding.inflate(inflater, container, false).also { binding = it }.root
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    val args = requireArguments()
    closeAppOnClick = args.getBoolean(KEY_CLOSE_APP_ON_CLICK)
    var title: String? = getString(R.string.msg_ide_crashed)
    var message: String? = getString(R.string.msg_report_crash)
    if (args.containsKey(KEY_TITLE)) {
      title = args.getString(KEY_TITLE)
    }

    if (args.containsKey(KEY_MESSAGE)) {
      message = args.getString(KEY_MESSAGE)
    }

    val trace: String = if (args.containsKey(KEY_TRACE)) {
      buildReportText(args.getString(KEY_TRACE))
    } else {
      "No stack strace was provided for the report"
    }

    binding!!.apply {
      crashTitle.text = title
      crashSubtitle.text = message
      logText.text = trace

      val report: String = trace
      closeButton.setOnClickListener {
        if (closeAppOnClick) {
          requireActivity().finishAffinity()
        } else {
          requireActivity().finish()
        }
      }

      reportButton.setOnClickListener { reportTrace(report) }
    }
  }

  private fun reportTrace(report: String) {
    ClipboardUtils.copyText("AndroidIDE CrashLog", report)
    val url = BuildInfo.REPO_URL + "/issues"
    val intent = Intent()
    intent.action = Intent.ACTION_VIEW
    intent.data = Uri.parse(url)
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    startActivity(intent)
  }

  private fun buildReportText(trace: String?): String {
    return """
AndroidIDE Crash Report
${BuildInfoUtils.getBuildInfoHeader()}

Stacktrace:
$trace
    """
  }

  override fun onDestroyView() {
    super.onDestroyView()
    binding = null
  }
}


================================================
File: java/com/itsaky/androidide/fragments/DeleteProjectFragment.kt
================================================
package com.itsaky.androidide.fragments

import android.os.Bundle

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.fragment.app.activityViewModels
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.itsaky.androidide.R
import com.itsaky.androidide.activities.MainActivity
import com.itsaky.androidide.adapters.DeleteProjectListAdapter
import com.itsaky.androidide.databinding.FragmentDeleteProjectBinding
import com.itsaky.androidide.ui.CustomDividerItemDecoration
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import com.itsaky.androidide.viewmodel.MainViewModel
import com.itsaky.androidide.viewmodel.RecentProjectsViewModel

import java.io.File

class DeleteProjectFragment : BaseFragment() {

    private var _binding: FragmentDeleteProjectBinding? = null
    private val binding get() = _binding!!

    private val recentProjectsViewModel: RecentProjectsViewModel by activityViewModels()
    private val mainViewModel: MainViewModel by activityViewModels()
    private var adapter: DeleteProjectListAdapter? = null

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentDeleteProjectBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupRecyclerView()
        observeProjects()
        setupClickListeners()
    }

    private fun setupRecyclerView() = with(binding) {
        listProjects.layoutManager = LinearLayoutManager(requireContext())
        listProjects.addItemDecoration(
            CustomDividerItemDecoration(requireContext(), R.drawable.custom_list_divider)
        )
    }

    private fun observeProjects() {
        recentProjectsViewModel.projects.observe(viewLifecycleOwner) { projects ->
            if (adapter == null) {
                // Create adapter and pass a callback to update delete button state on selection change
                adapter = DeleteProjectListAdapter(projects) { enableBtn ->
                    binding.delete.isEnabled = enableBtn
                }
                binding.listProjects.adapter = adapter
            } else {
                adapter?.updateProjects(projects)
            }
            binding.recentProjectsTxt.isVisible = projects.isNotEmpty()
            binding.noProjectsView.isVisible = projects.isEmpty()

            // Change button text and state based on whether projects exist
            if (projects.isEmpty()) {
                binding.delete.text = getString(R.string.new_project)
                binding.delete.isEnabled = true
            } else {
                binding.delete.text = getString(R.string.delete_project)
                binding.delete.isEnabled = adapter?.getSelectedProjects()?.isNotEmpty() ?: false
            }
        }
    }


    private fun setupClickListeners() {
        binding.delete.setOnClickListener {
            // If no projects exist, navigate to the create project screen.
            val projects = recentProjectsViewModel.projects.value
            if (projects.isNullOrEmpty()) {
                mainViewModel.setScreen(MainViewModel.SCREEN_TEMPLATE_LIST)
            } else {
                showDeleteDialog()
            }
        }
        binding.exitButton.setOnClickListener { mainViewModel.setScreen(MainViewModel.SCREEN_MAIN) }
    }

    private fun deleteProject(root: File) {
        (requireActivity() as MainActivity).deleteProject(root)
    }

    private fun showDeleteDialog() {
        MaterialAlertDialogBuilder(requireContext())
            .setTitle(com.itsvks.layouteditor.R.string.delete_project)
            .setMessage(R.string.msg_delete_selected_project)
            .setNegativeButton(com.itsvks.layouteditor.R.string.no) { dialog, _ -> dialog.dismiss() }
            .setPositiveButton(com.itsvks.layouteditor.R.string.yes) { _, _ ->
                try {
                    adapter?.getSelectedProjects().let { locations ->
                        locations?.forEach {
                            deleteProject(File(it.path))
                        }
                        val names = locations?.map { it.name }
                        if (names != null) {
                            recentProjectsViewModel.deleteSelectedProjects(names)
                        }
                        flashSuccess(R.string.deleted)
                    }
                } catch (e: Exception) {
                    flashError(R.string.delete_failed)
                }
            }
            .show()
    }

    override fun onResume() {
        super.onResume()
        recentProjectsViewModel.loadProjects()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}



================================================
File: java/com/itsaky/androidide/fragments/DiagnosticsListFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.fragments

import android.os.Bundle
import android.view.View
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.R
import com.itsaky.androidide.adapters.DiagnosticsAdapter

class DiagnosticsListFragment : RecyclerViewFragment<DiagnosticsAdapter>() {

  override fun onCreateAdapter(): RecyclerView.Adapter<*> {
    return DiagnosticsAdapter(ArrayList(), null)
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    emptyStateViewModel.emptyMessage.value = getString(R.string.msg_emptyview_diagnostics)
  }
}


================================================
File: java/com/itsaky/androidide/fragments/EmptyStateFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.viewModels
import androidx.viewbinding.ViewBinding
import com.itsaky.androidide.databinding.FragmentEmptyStateBinding
import com.itsaky.androidide.viewmodel.EmptyStateFragmentViewModel

/**
 * A fragment that shows a message when there is no data to show in the subclass fragment.
 *
 * @author Akash Yadav
 */
abstract class EmptyStateFragment<T : ViewBinding> : FragmentWithBinding<T> {

  constructor(layout: Int, bind: (View) -> T) : super(layout, bind)
  constructor(inflate: (LayoutInflater, ViewGroup?, Boolean) -> T) : super(inflate)

  protected var emptyStateBinding: FragmentEmptyStateBinding? = null
    private set

  protected val emptyStateViewModel by viewModels<EmptyStateFragmentViewModel>()

  internal var isEmpty: Boolean
    get() = emptyStateViewModel.isEmpty.value ?: false
    set(value) {
      emptyStateViewModel.isEmpty.value = value
    }

  override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
    savedInstanceState: Bundle?): View {

    return FragmentEmptyStateBinding.inflate(inflater, container, false).also { emptyStateBinding ->
      this.emptyStateBinding = emptyStateBinding

      // add the main fragment view
      emptyStateBinding.root.addView(
        super.onCreateView(inflater, emptyStateBinding.root, savedInstanceState)
      )
    }.root
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    emptyStateViewModel.isEmpty.observe(viewLifecycleOwner) { isEmpty ->
      emptyStateBinding?.apply {
        root.displayedChild = if (isEmpty) 0 else 1
      }
    }

    emptyStateViewModel.emptyMessage.observe(viewLifecycleOwner) { message ->
      emptyStateBinding?.emptyView?.message = message
    }
  }

  override fun onDestroyView() {
    this.emptyStateBinding = null
    super.onDestroyView()
  }
}


================================================
File: java/com/itsaky/androidide/fragments/IDEPreferencesFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.preference.PreferenceCategory
import androidx.preference.PreferenceGroup
import com.google.android.material.transition.MaterialSharedAxis
import com.itsaky.androidide.preferences.IPreference
import com.itsaky.androidide.preferences.IPreferenceGroup
import com.itsaky.androidide.preferences.IPreferenceScreen

class IDEPreferencesFragment : BasePreferenceFragment() {

  private var children: List<IPreference> = emptyList()

  override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View {
    enterTransition = MaterialSharedAxis(MaterialSharedAxis.X, true)
    reenterTransition = MaterialSharedAxis(MaterialSharedAxis.X, false)
    exitTransition = MaterialSharedAxis(MaterialSharedAxis.X, true)
    return super.onCreateView(inflater, container, savedInstanceState)
  }

  override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
    super.onCreatePreferences(savedInstanceState, rootKey)

    if (context == null) {
      return
    }

    @Suppress("DEPRECATION")
    this.children = arguments?.getParcelableArrayList(EXTRA_CHILDREN) ?: emptyList()

    preferenceScreen.removeAll()
    addChildren(this.children, preferenceScreen)
  }

  private fun addChildren(children: List<IPreference>, pref: PreferenceGroup) {
    for (child in children) {
      val preference = child.onCreateView(requireContext())
      if (child is IPreferenceScreen) {
        preference.fragment = IDEPreferencesFragment::class.java.name
        preference.extras.putParcelableArrayList(EXTRA_CHILDREN, ArrayList(child.children))
        pref.addPreference(preference)
        continue
      }

      if (child is IPreferenceGroup) {
        pref.addPreference(preference as PreferenceCategory)
        addChildren(child.children, preference)
        continue
      }

      pref.addPreference(preference)
    }
  }

  companion object {
    const val EXTRA_CHILDREN = "ide.preferences.fragment.children"
  }
}



================================================
File: java/com/itsaky/androidide/fragments/IDETooltipWebViewFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.annotation.SuppressLint
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.webkit.WebChromeClient
import android.webkit.WebResourceRequest
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.activity.OnBackPressedCallback
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import com.itsaky.androidide.R
import java.net.URL


class IDETooltipWebviewFragment : Fragment() {
    private lateinit var webView: WebView
    private lateinit var website : String

    //This warning is unnecessary because we control the content
    @SuppressLint("SetJavaScriptEnabled")
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        super.onCreateView(inflater, container, savedInstanceState)
        Log.d(Companion.TAG, "IDETooltipWebviewFragment\\\\onCreateView called")
        // Handle back press using OnBackPressedCallback
        requireActivity().onBackPressedDispatcher.addCallback(
            viewLifecycleOwner,
            object : OnBackPressedCallback(true) {
                override fun handleOnBackPressed() {
                    if (webView.canGoBack()) {
                        webView.goBack()
                    } else {
                        activity?.runOnUiThread {
                            webView.clearHistory()
                            webView.loadUrl("about:blank")
                            webView.destroy()
                        }
                        parentFragmentManager.popBackStack()
                        isEnabled =
                            false // Disable this callback to let the default back press behavior occur
                    }
                }
            })

        website = arguments?.getString(/* key = */ MainFragment.KEY_TOOLTIP_URL).toString()

        // Inflate the layout for this fragment
        val view = inflater.inflate(R.layout.fragment_idetooltipwebview, container, false)

        // Initialize the WebView
        webView = view.findViewById(R.id.IDETooltipWebView)

        // Set a WebViewClient to handle loading pages
        webView.webViewClient = object : WebViewClient() {
            override fun shouldOverrideUrlLoading(view: WebView, request: WebResourceRequest): Boolean {
                // Allow loading of local assets files
                if (request.url.toString().startsWith("file:///android_asset/")) {
                    view.loadUrl(request.url.toString())
                    return true
                }
                return super.shouldOverrideUrlLoading(view, request)
            }
        }

        // Set up WebChromeClient to support JavaScript
//        webView.webChromeClient = WebChromeClient()
        webView.settings.allowFileAccessFromFileURLs
        webView.settings.allowFileAccess
        webView.settings.allowUniversalAccessFromFileURLs
        webView.scrollBarStyle = WebView.SCROLLBARS_OUTSIDE_OVERLAY
        webView.scrollBarDefaultDelayBeforeFade = 1000


        // Enable JavaScript if needed
        webView.settings.javaScriptEnabled = true

        // Load the HTML file from the assets folder
        webView.loadUrl(website)
        return view
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        Log.d(Companion.TAG, "IDETooltipWebViewFragment\\\\onViewCreated called")
    }

    override fun onDestroyView() {
        super.onDestroyView()
        // Clean up the WebView in Fragment
        if(webView.isVisible) {
            webView.clearHistory()
            webView.loadUrl("about:blank")
            webView.destroy()
        }

    }

    companion object {
        private const val TAG = "IDETooltipWebViewFragment"
    }


}



================================================
File: java/com/itsaky/androidide/fragments/MainFragment.kt
================================================
package com.itsaky.androidide.fragments

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.activity.result.ActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.text.HtmlCompat
import androidx.fragment.app.viewModels
import com.google.android.material.progressindicator.LinearProgressIndicator
import com.itsaky.androidide.BuildConfig
import com.itsaky.androidide.R
import com.itsaky.androidide.activities.MainActivity
import com.itsaky.androidide.activities.PreferencesActivity
import com.itsaky.androidide.activities.TerminalActivity
import com.itsaky.androidide.activities.editor.HelpActivity
import com.itsaky.androidide.adapters.MainActionsListAdapter
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.app.BaseIDEActivity
import com.itsaky.androidide.common.databinding.LayoutDialogProgressBinding
import com.itsaky.androidide.databinding.FragmentMainBinding
import com.itsaky.androidide.idetooltips.IDETooltipItem
import com.itsaky.androidide.idetooltips.TooltipManager
import com.itsaky.androidide.models.MainScreenAction
import com.itsaky.androidide.preferences.databinding.LayoutDialogTextInputBinding
import com.itsaky.androidide.preferences.internal.GITHUB_PAT
import com.itsaky.androidide.resources.R.string
import com.itsaky.androidide.tasks.runOnUiThread
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.TooltipUtils
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import com.itsaky.androidide.viewmodel.MainViewModel
import com.termux.shared.termux.TermuxConstants.TERMUX_APP.TERMUX_ACTIVITY
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.adfa.constants.CONTENT_KEY
import org.adfa.constants.CONTENT_TITLE_KEY
import org.eclipse.jgit.api.CloneCommand
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.lib.ProgressMonitor
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider
import org.slf4j.LoggerFactory
import java.io.File
import java.util.concurrent.CancellationException

class MainFragment : BaseFragment() {

    private val viewModel by viewModels<MainViewModel>(
        ownerProducer = { requireActivity() })
    private var binding: FragmentMainBinding? = null

    private data class CloneRequest(val url: String, val targetDir: File)

    private var currentCloneRequest: CloneRequest? = null

    companion object {

        private val log = LoggerFactory.getLogger(MainFragment::class.java)
        const val KEY_TOOLTIP_URL = "tooltip_url"
    }

    private val shareActivityResultLauncher = registerForActivityResult<Intent, ActivityResult>(
        ActivityResultContracts.StartActivityForResult()
    ) { //ACTION_SEND always returns RESULT_CANCELLED, ignore it
        // There are no request codes
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = FragmentMainBinding.inflate(inflater, container, false)
        return binding!!.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val actions = MainScreenAction.mainScreen().also { actions ->
            val onClick = { action: MainScreenAction, _: View ->
                when (action.id) {
                    MainScreenAction.ACTION_CREATE_PROJECT -> showCreateProject()
                    MainScreenAction.ACTION_OPEN_PROJECT -> showViewSavedProjects()
                    MainScreenAction.ACTION_DELETE_PROJECT -> pickDirectoryForDeletion()
                    MainScreenAction.ACTION_CLONE_REPO -> cloneGitRepo()
                    MainScreenAction.ACTION_OPEN_TERMINAL -> startActivity(
                        Intent(requireActivity(), TerminalActivity::class.java)
                    )

                    MainScreenAction.ACTION_PREFERENCES -> gotoPreferences()

                    MainScreenAction.ACTION_DOCS -> BaseApplication.getBaseInstance().openDocs()
                }
            }
            val onLongClick = { action: MainScreenAction, _: View ->
                performOptionsMenuClick(action)
                true
            }

            actions.forEach { action ->
                action.onClick = onClick
                action.onLongClick = onLongClick

                if (action.id == MainScreenAction.ACTION_OPEN_TERMINAL) {
                    action.onLongClick = { _: MainScreenAction, _: View ->
                        val intent = Intent(requireActivity(), TerminalActivity::class.java).apply {
                            putExtra(TERMUX_ACTIVITY.EXTRA_FAILSAFE_SESSION, true)
                        }
                        startActivity(intent)
                        true
                    }
                }
            }
        }

        binding!!.actions.adapter = MainActionsListAdapter(actions)
        binding!!.greetingText.setOnClickListener {
            TooltipUtils.showWebPage(
                requireContext(),
                "file:///android_asset/idetooltips/getstarted_top.html"
            )
        }

        binding!!.floatingActionButton?.setOnClickListener {
            performFeedbackAction()
        }
    }

    // this method will handle the onclick options click
    private fun performOptionsMenuClick(action: MainScreenAction) {
        val view = action.view
        val tag = action.id.toString()
        CoroutineScope(Dispatchers.IO).launch {
            val item =
                TooltipManager.getTooltip(context = requireContext(), category = "ide", tag = tag)
            withContext((Dispatchers.Main)) {
                (context?.let {
                    TooltipManager.showIDETooltip(
                        it,
                        view!!,
                        0,
                        IDETooltipItem(
                            tooltipCategory = "ide",
                            tooltipTag = item?.tooltipTag ?: "",
                            detail = item?.detail ?: "",
                            summary = item?.summary ?: "",
                            buttons = item?.buttons ?: arrayListOf(),
                        ),
                        { context, url, title ->
                            val intent = Intent(context, HelpActivity::class.java).apply {
                                putExtra(CONTENT_KEY, url)
                                putExtra(CONTENT_TITLE_KEY, title)
                            }
                            context.startActivity(intent)

                        }
                    )
                })
            }
        }
    }

    private fun performFeedbackAction() {
        val builder = context?.let { DialogUtils.newMaterialDialogBuilder(it) }
        builder?.let { builder ->
            builder.setTitle("Alert!")
                .setMessage(
                    HtmlCompat.fromHtml(
                        getString(R.string.email_feedback_warning_prompt),
                        HtmlCompat.FROM_HTML_MODE_COMPACT
                    )
                )
                .setNegativeButton(android.R.string.cancel) { dialog, _ -> dialog.dismiss() }
                .setPositiveButton(android.R.string.ok) { dialog, _ ->
                    run {
                        val stackTrace =
                            Exception().stackTrace.asList().toString().replace(",", "\n")
                        val feedbackMessage = getString(
                            R.string.feedback_message,
                            BuildConfig.VERSION_NAME,
                            stackTrace
                        )

                        val feedbackEmail = getString(R.string.feedback_email)
                        val currentScreen = getCurrentScreenName()

                        try {
                            val feedbackIntent = Intent(Intent.ACTION_SENDTO).apply {
                                data = Uri.parse("mailto:")
                                putExtra(Intent.EXTRA_EMAIL, arrayOf(feedbackEmail))

                                val subject = String.format(
                                    resources.getString(R.string.feedback_subject),
                                    currentScreen
                                )
                                putExtra(Intent.EXTRA_SUBJECT, subject)
                                putExtra(Intent.EXTRA_TEXT, feedbackMessage)
                            }

                            shareActivityResultLauncher.launch(
                                Intent.createChooser(feedbackIntent, "Send Feedback")
                            )
                        } catch (e: Exception) {
                            try {
                                val fallbackIntent = Intent(Intent.ACTION_SEND).apply {
                                    type = "message/rfc822"
                                    putExtra(Intent.EXTRA_EMAIL, arrayOf(feedbackEmail))

                                    val subject = String.format(
                                        resources.getString(R.string.feedback_subject),
                                        currentScreen
                                    )
                                    putExtra(Intent.EXTRA_SUBJECT, subject)
                                    putExtra(Intent.EXTRA_TEXT, feedbackMessage)
                                }
                                shareActivityResultLauncher.launch(
                                    Intent.createChooser(
                                        fallbackIntent,
                                        getString(R.string.send_feedback)
                                    )
                                )
                            } catch (e2: Exception) {
                                requireActivity().flashError(R.string.no_email_apps)
                            }
                        }
                        dialog.dismiss()
                    }
                }
                .create()
                .show()
        }
    }

    private fun getCurrentScreenName(): String {
        val activity = requireActivity()
        return activity.javaClass.simpleName.replace("Activity", "")
    }

    override fun onDestroyView() {
        super.onDestroyView()
        binding = null
    }

    private fun pickDirectory() {
        pickDirectory(this::openProject)
    }

    private fun pickDirectoryForDeletion() {
        viewModel.setScreen(MainViewModel.SCREEN_DELETE_PROJECTS)
    }

    private fun showCreateProject() {
        viewModel.setScreen(MainViewModel.SCREEN_TEMPLATE_LIST)
    }

    private fun showViewSavedProjects() {
        viewModel.setScreen(MainViewModel.SCREEN_SAVED_PROJECTS)
    }

    fun openProject(root: File) {
        (requireActivity() as MainActivity).openProject(root)
    }

    private fun cloneGitRepo() {
        val builder = DialogUtils.newMaterialDialogBuilder(requireContext())
        val binding = LayoutDialogTextInputBinding.inflate(layoutInflater)
        binding.name.setHint(string.git_clone_repo_url)

        builder.setView(binding.root)
        builder.setTitle(string.git_clone_repo)
        builder.setCancelable(true)
        builder.setPositiveButton(string.git_clone) { dialog, _ ->
            dialog.dismiss()
            val url = binding.name.editText?.text?.toString()
            doClone(url)
        }
        builder.setNegativeButton(android.R.string.cancel, null)
        builder.show()
    }

    private fun doClone(repo: String?) {
        if (repo.isNullOrBlank()) {
            log.warn("Unable to clone repo. Invalid repo URL : {}'", repo)
            return
        }

        var url = repo.trim()
        if (!url.endsWith(".git")) {
            url += ".git"
        }

        val builder = DialogUtils.newMaterialDialogBuilder(requireContext())
        val binding = LayoutDialogProgressBinding.inflate(layoutInflater)

        binding.message.visibility = View.VISIBLE

        builder.setTitle(string.git_clone_in_progress)
        builder.setMessage(url)
        builder.setView(binding.root)
        builder.setCancelable(false)

        val prefs = BaseApplication.getBaseInstance().prefManager
        val repoName = url.substringAfterLast('/').substringBeforeLast(".git")
        val targetDir = File(Environment.PROJECTS_DIR, repoName)
        currentCloneRequest = CloneRequest(url, targetDir)
        if (targetDir.exists()) {
            showCloneDirExistsError(targetDir)
            return
        }

        val progress = GitCloneProgressMonitor(binding.progress, binding.message)
        val coroutineScope =
            (activity as? BaseIDEActivity?)?.activityScope ?: viewLifecycleScope

        var getDialog: Function0<AlertDialog?>? = null

        val cloneJob = coroutineScope.launch(Dispatchers.IO) {

            val git = try {
                val cmd: CloneCommand = Git.cloneRepository()
                cmd
                    .setURI(url)
                    .setDirectory(targetDir)
                    .setProgressMonitor(progress)
                val token = prefs.getString(GITHUB_PAT, "")
                if (!token.isNullOrBlank()) {
                    cmd.setCredentialsProvider(
                        UsernamePasswordCredentialsProvider(
                            "<token>",
                            token
                        )
                    )
                }
                cmd.call()
            } catch (err: Throwable) {
                if (!progress.isCancelled) {
                    err.printStackTrace()
                    withContext(Dispatchers.Main) {
                        getDialog?.invoke()?.also { if (it.isShowing) it.dismiss() }
                        showCloneError(err)
                    }
                }
                null
            }

            try {
                git?.close()
            } finally {
                val success = git != null
                withContext(Dispatchers.Main) {
                    getDialog?.invoke()?.also { dialog ->
                        if (dialog.isShowing) dialog.dismiss()
                        if (success) flashSuccess(string.git_clone_success)
                    }
                }
            }
        }

        builder.setPositiveButton(android.R.string.cancel) { iface, _ ->
            iface.dismiss()
            progress.cancel()
            cloneJob.cancel(CancellationException("Cancelled by user"))
        }

        val dialog = builder.show()
        getDialog = { dialog }
    }

    private fun showCloneDirExistsError(targetDir: File) {
        val builder = context?.let { DialogUtils.newMaterialDialogBuilder(it) }
        builder?.setTitle(string.title_warning)
        builder?.setMessage(
            getString(
                R.string.git_clone_dir_exists_detailed,
                targetDir.absolutePath
            )
        )
        builder?.setPositiveButton(R.string.delete_and_clone) { _, _ ->
            val progressBuilder = DialogUtils.newMaterialDialogBuilder(requireContext())
            val progressBinding = LayoutDialogProgressBinding.inflate(layoutInflater)

            progressBinding.message.visibility = View.VISIBLE
            progressBinding.message.text = getString(R.string.deleting_directory)

            progressBuilder.setTitle(R.string.please_wait)
            progressBuilder.setView(progressBinding.root)
            progressBuilder.setCancelable(false)

            val progressDialog = progressBuilder.show()

            val coroutineScope =
                (activity as? BaseIDEActivity?)?.activityScope ?: viewLifecycleScope
            coroutineScope.launch(Dispatchers.IO) {
                try {
                    targetDir.deleteRecursively()
                    withContext(Dispatchers.Main) {
                        progressDialog.dismiss()
                        proceedWithClone()
                    }
                } catch (e: Exception) {
                    withContext(Dispatchers.Main) {
                        progressDialog.dismiss()
                        val errorBuilder = DialogUtils.newMaterialDialogBuilder(requireContext())
                        errorBuilder.setTitle(R.string.error)
                        errorBuilder.setMessage(
                            getString(
                                R.string.error_deleting_directory,
                                e.localizedMessage
                            )
                        )
                        errorBuilder.setPositiveButton(android.R.string.ok, null)
                        errorBuilder.show()
                    }
                }
            }
        }
        builder?.setNeutralButton(R.string.choose_different_location) { dlg, _ ->
            dlg.dismiss()
            showChooseAlternativeCloneLocation(targetDir)
        }
        builder?.setNegativeButton(android.R.string.cancel) { dlg, _ -> dlg.dismiss() }
        builder?.show()
    }

    private fun proceedWithClone() {
        val request = currentCloneRequest ?: return
        val url = request.url
        val targetDir = request.targetDir

        val builder = DialogUtils.newMaterialDialogBuilder(requireContext())
        val binding = LayoutDialogProgressBinding.inflate(layoutInflater)

        binding.message.visibility = View.VISIBLE

        builder.setTitle(string.git_clone_in_progress)
        builder.setMessage(url)
        builder.setView(binding.root)
        builder.setCancelable(false)

        val prefs = BaseApplication.getBaseInstance().prefManager
        val progress = GitCloneProgressMonitor(binding.progress, binding.message)
        val coroutineScope =
            (activity as? BaseIDEActivity?)?.activityScope ?: viewLifecycleScope

        var getDialog: Function0<AlertDialog?>? = null

        val cloneJob = coroutineScope.launch(Dispatchers.IO) {
            val git = try {
                val cmd: CloneCommand = Git.cloneRepository()
                cmd
                    .setURI(url)
                    .setDirectory(targetDir)
                    .setProgressMonitor(progress)
                val token = prefs.getString(GITHUB_PAT, "")
                if (!token.isNullOrBlank()) {
                    cmd.setCredentialsProvider(
                        UsernamePasswordCredentialsProvider(
                            "<token>",
                            token
                        )
                    )
                }
                cmd.call()
            } catch (err: Throwable) {
                if (!progress.isCancelled) {
                    err.printStackTrace()
                    withContext(Dispatchers.Main) {
                        getDialog?.invoke()?.also { if (it.isShowing) it.dismiss() }
                        showCloneError(err)
                    }
                }
                null
            }

            try {
                git?.close()
            } finally {
                val success = git != null
                withContext(Dispatchers.Main) {
                    getDialog?.invoke()?.also { dialog ->
                        if (dialog.isShowing) dialog.dismiss()
                        if (success) flashSuccess(string.git_clone_success)
                    }
                }
            }
        }

        builder.setPositiveButton(android.R.string.cancel) { iface, _ ->
            iface.dismiss()
            progress.cancel()
            cloneJob.cancel(CancellationException("Cancelled by user"))
        }

        val dialog = builder.show()
        getDialog = { dialog }
    }

    private fun showChooseAlternativeCloneLocation(originalDir: File) {
        val cloneRequest = currentCloneRequest ?: return

        val builder = DialogUtils.newMaterialDialogBuilder(requireContext())
        val binding = LayoutDialogTextInputBinding.inflate(layoutInflater)

        binding.name.setHint(string.new_directory_name)
        binding.name.editText?.setText(originalDir.name + "_new")

        builder.setView(binding.root)
        builder.setTitle(string.choose_different_location)
        builder.setCancelable(true)
        builder.setPositiveButton(string.git_clone) { dialog, _ ->
            dialog.dismiss()
            val newDirName = binding.name.editText?.text?.toString()
            if (!newDirName.isNullOrBlank()) {
                val newTargetDir = File(originalDir.parentFile, newDirName)

                currentCloneRequest = CloneRequest(cloneRequest.url, newTargetDir)

                proceedWithClone()
            }
        }
        builder.setNegativeButton(android.R.string.cancel, null)
        builder.show()
    }

    private fun showCloneError(error: Throwable?) {
        if (error == null) {
            flashError(string.git_clone_failed)
            return
        }
        val builder = DialogUtils.newMaterialDialogBuilder(requireContext())
        builder.setTitle(string.git_clone_failed)
        builder.setMessage(error.localizedMessage)
        builder.setPositiveButton(android.R.string.ok, null)
        builder.show()
    }

    private fun gotoPreferences() {
        startActivity(Intent(requireActivity(), PreferencesActivity::class.java))
    }

    // TODO(itsaky) : Improve this implementation
    class GitCloneProgressMonitor(
        val progress: LinearProgressIndicator,
        val message: TextView
    ) : ProgressMonitor {

        private var cancelled = false

        fun cancel() {
            cancelled = true
        }

        override fun start(totalTasks: Int) {
            runOnUiThread { progress.max = totalTasks }
        }

        override fun beginTask(title: String?, totalWork: Int) {
            runOnUiThread { message.text = title }
        }

        override fun update(completed: Int) {
            runOnUiThread { progress.progress = completed }
        }

        override fun showDuration(enabled: Boolean) {
            // no-op
        }

        override fun endTask() {}

        override fun isCancelled(): Boolean {
            return cancelled || Thread.currentThread().isInterrupted
        }
    }
}



================================================
File: java/com/itsaky/androidide/fragments/RecentProjectsFragment.kt
================================================
package com.itsaky.androidide.fragments

import android.os.Bundle
import android.text.SpannableStringBuilder

import android.text.style.ClickableSpan

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.activityViewModels
import androidx.recyclerview.widget.LinearLayoutManager
import com.itsaky.androidide.R


import com.itsaky.androidide.activities.MainActivity
import com.itsaky.androidide.adapters.RecentProjectsAdapter
import com.itsaky.androidide.databinding.FragmentSavedProjectsBinding
import com.itsaky.androidide.ui.CustomDividerItemDecoration
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.viewmodel.MainViewModel
import com.itsaky.androidide.viewmodel.RecentProjectsViewModel
import java.io.File

class RecentProjectsFragment : BaseFragment() {

    private var _binding: FragmentSavedProjectsBinding? = null
    private val binding get() = _binding!!

    private val viewModel: RecentProjectsViewModel by activityViewModels()
    private val mainViewModel: MainViewModel by activityViewModels()
    private lateinit var adapter: RecentProjectsAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        _binding = FragmentSavedProjectsBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupRecyclerView()
        setupObservers()
        setupClickListeners()
    }

    private fun setupRecyclerView() {
        binding.listProjects.layoutManager = LinearLayoutManager(requireContext())
        binding.listProjects.addItemDecoration(
            CustomDividerItemDecoration(requireContext(), R.drawable.custom_list_divider)
        )
    }

    private fun setupObservers() {
        // Lambda to handle directory picking: insert the project and open it.
        val handleDirectoryPick: (File) -> Unit = { file ->
            viewModel.insertProjectFromFolder(
                name = file.name, location = file.absolutePath
            )
            openProject(file)
        }

        viewModel.projects.observe(viewLifecycleOwner) { projects ->
            if (::adapter.isInitialized) {
                adapter.updateProjects(projects)
            } else {
                adapter = RecentProjectsAdapter(
                    projects,
                    onProjectClick = { openProject(it) },
                    onOpenFileFromFolderClick = {
                        pickDirectory {
                            if (isValidProjectDirectory(it)) {
                                handleDirectoryPick(it)
                            } else {
                                flashError(
                                    msg = requireContext().getString(
                                        R.string.project_directory_invalid,
                                        it.name
                                    )
                                )
                            }
                        }
                    },
                    onRemoveProjectClick = { project ->
                        viewModel.deleteProject(project.name)
                    },
                    onFileRenamed = {
                        viewModel.updateProject(it.oldName, it.newName, it.newPath)
                    },
                )
                binding.listProjects.adapter = adapter
            }

            val isEmpty = projects.isEmpty()
            binding.recentProjectsTxt.visibility = if (isEmpty) View.GONE else View.VISIBLE
            binding.noProjectsView.visibility = if (isEmpty) View.VISIBLE else View.GONE

            // Build the clickable spannable text.
            val sb = SpannableStringBuilder()
            val filesSpan: ClickableSpan = object : ClickableSpan() {
                override fun onClick(widget: View) {
                    pickDirectory {
                        if (isValidProjectDirectory(it)) {
                            handleDirectoryPick(it)
                        } else {
                            flashError(
                                requireContext().getString(
                                    R.string.project_directory_invalid,
                                    it.name
                                )
                            )
                        }
                    }
                }
            }
            appendClickableSpan(sb, R.string.msg_create_new_from_recent, filesSpan)
            binding.tvCreateNewProject.text = sb

            // Also set a click listener on the TextView itself.
            binding.tvCreateNewProject.setOnClickListener {
                pickDirectory {
                    if (isValidProjectDirectory(it)) {
                        handleDirectoryPick(it)
                    } else {
                        flashError(
                            requireContext().getString(
                                R.string.project_directory_invalid,
                                it.name
                            )
                        )
                    }
                }
            }
        }
    }

    fun isValidProjectDirectory(selectedDir: File): Boolean {
        val appFolder = File(selectedDir, "app")
        val buildGradleFile = File(appFolder, "build.gradle")
        val buildGradleKtsFile = File(appFolder, "build.gradle.kts")
        return appFolder.exists() && appFolder.isDirectory &&
                (buildGradleFile.exists() || buildGradleKtsFile.exists())
    }

    private fun setupClickListeners() {
        binding.newProjectButton.setOnClickListener {
            mainViewModel.setScreen(MainViewModel.SCREEN_TEMPLATE_LIST)
        }
        binding.exitButton.setOnClickListener {
            mainViewModel.setScreen(MainViewModel.SCREEN_MAIN)
        }
    }

    private fun openProject(root: File) {
        (requireActivity() as MainActivity).openProject(root)
    }

    private fun deleteProject(root: File) {
        (requireActivity() as MainActivity).deleteProject(root)
    }


    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onResume() {
        super.onResume()
        viewModel.loadProjects()
    }
}



================================================
File: java/com/itsaky/androidide/fragments/RecyclerViewFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.os.Bundle
import android.view.View
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.recyclerview.widget.RecyclerView.LayoutManager
import com.itsaky.androidide.databinding.FragmentRecyclerviewBinding

/**
 * A fragment which shows a [RecyclerView].
 *
 * @author Akash Yadav
 */
abstract class RecyclerViewFragment<A : RecyclerView.Adapter<*>> :
  EmptyStateFragment<FragmentRecyclerviewBinding>(FragmentRecyclerviewBinding::inflate) {

  private var unsavedAdapter: A? = null

  /**
   * Creates the adapter for the [RecyclerView].
   */
  protected abstract fun onCreateAdapter(): RecyclerView.Adapter<*>

  /**
   * Creates the layout manager for the [RecyclerView].
   */
  protected open fun onCreateLayoutManager(): LayoutManager {
    return LinearLayoutManager(requireContext())
  }

  /**
   * Sets up the recycler view in the fragment.
   */
  protected open fun onSetupRecyclerView() {
    binding.root.apply {
      layoutManager = onCreateLayoutManager()
      adapter = unsavedAdapter ?: onCreateAdapter()
    }
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    onSetupRecyclerView()

    unsavedAdapter = null

    checkIsEmpty()
  }

  override fun onDestroyView() {
    super.onDestroyView()
    unsavedAdapter = null
  }

  /**
   * Set the adapter for the [RecyclerView].
   */
  fun setAdapter(adapter: A) {
    _binding?.root?.let { list -> list.adapter = adapter } ?: run { unsavedAdapter = adapter }
    checkIsEmpty()
  }

  private fun checkIsEmpty() {
    emptyStateViewModel.isEmpty.value = _binding?.root?.adapter?.itemCount == 0
  }
}


================================================
File: java/com/itsaky/androidide/fragments/RunTasksDialogFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.app.Dialog
import android.graphics.Color
import android.os.Build
import android.os.Bundle
import android.text.Editable
import android.util.DisplayMetrics
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewGroup.MarginLayoutParams
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat.Type.navigationBars
import androidx.core.view.WindowInsetsCompat.Type.statusBars
import androidx.core.view.updateLayoutParams
import androidx.core.view.updateMargins
import androidx.core.view.updatePadding
import androidx.fragment.app.viewModels
import androidx.transition.TransitionManager
import com.blankj.utilcode.util.ThreadUtils
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.google.android.material.transition.MaterialSharedAxis
import com.itsaky.androidide.R.string
import com.itsaky.androidide.adapters.RunTasksListAdapter
import com.itsaky.androidide.databinding.LayoutRunTaskBinding
import com.itsaky.androidide.databinding.LayoutRunTaskDialogBinding
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.models.Checkable
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.projects.api.GradleProject
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.tasks.executeAsync
import com.itsaky.androidide.tooling.api.models.GradleTask
import com.itsaky.androidide.utils.SingleTextWatcher
import com.itsaky.androidide.utils.doOnApplyWindowInsets
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashInfo
import com.itsaky.androidide.utils.updateSystemBarColors
import com.itsaky.androidide.viewmodel.RunTasksViewModel
import org.slf4j.LoggerFactory

/**
 * A bottom sheet dialog fragment to show UI which allows the users to select and execute Gradle
 * tasks from the initialized project.
 *
 * @author Akash Yadav
 */
class RunTasksDialogFragment : BottomSheetDialogFragment() {

  private lateinit var binding: LayoutRunTaskDialogBinding
  private lateinit var run: LayoutRunTaskBinding
  private val viewModel: RunTasksViewModel by viewModels()

  companion object {
    private val log = LoggerFactory.getLogger(RunTasksDialogFragment::class.java)

    private const val CHILD_LOADING = 0
    private const val CHILD_TASKS = 1
    private const val CHILD_CONFIRMATION = 2
    private const val CHILD_PROJECT_NOT_INITIALIZED = 3

    // The minimum amount of time (in milliseconds) the adapter should wait after the query is
    // changed before starting any further filter request.
    // A too less value here will result in UI lags
    private const val SEARCH_DELAY = 500L
  }

  override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
    val dialog = object : BottomSheetDialog(requireContext(), theme) {
      override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        findViewById<View>(com.google.android.material.R.id.container)?.apply {
          doOnApplyWindowInsets { view, insets, _, margins ->
            insets.getInsets(statusBars() or navigationBars()).apply {
              view.updateLayoutParams<MarginLayoutParams> { updateMargins(top = margins.top + top) }
              run.tasks.apply {
                updatePadding(bottom = bottom)
                clipToPadding = false
                clipChildren = false
              }
            }
          }
        }
      }
    }
    dialog.behavior.peekHeight = (getWindowHeight() * 0.7).toInt()
    return dialog
  }

  override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View {
    this.binding = LayoutRunTaskDialogBinding.inflate(inflater, container, false)
    this.run = this.binding.run
    return binding.root
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    viewModel.observeDisplayedChild(viewLifecycleOwner) {
      val transition =
        MaterialSharedAxis(MaterialSharedAxis.X, it > this.binding.flipper.displayedChild)
      TransitionManager.beginDelayedTransition(this.binding.root, transition)
      this.binding.flipper.displayedChild = it
    }

    viewModel.observeQuery(viewLifecycleOwner) {
      val adapter = run.tasks.adapter as? RunTasksListAdapter? ?: return@observeQuery
      adapter.filter(it)
    }

    run.searchInput.editText?.addTextChangedListener(
      object : SingleTextWatcher() {
        val searchRunner = Runnable {
          viewModel.query = run.searchInput.editText?.text?.toString() ?: ""
        }
        override fun afterTextChanged(s: Editable?) {
          ThreadUtils.getMainHandler().removeCallbacks(searchRunner)
          ThreadUtils.runOnUiThreadDelayed(searchRunner, SEARCH_DELAY)
        }
      }
    )

    binding.exec.setOnClickListener {
      if (viewModel.selected.isEmpty()) {
        requireActivity().flashInfo(getString(string.msg_err_select_tasks))
        return@setOnClickListener
      }

      if (viewModel.displayedChild == CHILD_TASKS) {
        binding.confirm.msg.text =
          getString(R.string.msg_tasks_to_run, viewModel.getSelectedTaskPaths())
        viewModel.displayedChild = CHILD_CONFIRMATION
        return@setOnClickListener
      }

      if (viewModel.displayedChild == CHILD_CONFIRMATION) {
        val buildService =
          Lookup.getDefault().lookup(BuildService.KEY_BUILD_SERVICE)
            ?: run {
              log.error("Cannot find build service")
              return@setOnClickListener
            }

        if (!buildService.isToolingServerStarted()) {
          flashError(R.string.msg_tooling_server_unavailable)
          return@setOnClickListener
        }

        val toRun = viewModel.selected.toTypedArray()
        buildService.executeTasks(*toRun)
        dismiss()
      }
    }

    binding.confirm.cancel.setOnClickListener { viewModel.displayedChild = CHILD_TASKS }

    viewModel.displayedChild = CHILD_LOADING

    executeAsync({
      val project = IProjectManager.getInstance().rootProject
        ?: return@executeAsync emptyList<Checkable<GradleTask>>()

      return@executeAsync project.subProjects
        .flatMap<GradleProject, GradleTask> { it.tasks }
        .map<GradleTask, Checkable<GradleTask>> {
          Checkable<GradleTask>(false, it)
        }
    }) { tasks ->
      viewModel.tasks = tasks ?: emptyList()
      viewModel.displayedChild =
        if (viewModel.tasks.isNotEmpty()) CHILD_TASKS else CHILD_PROJECT_NOT_INITIALIZED

      val onCheckChanged = { item: Checkable<GradleTask> ->
        if (item.isChecked) {
          viewModel.select(item.data.path)
        } else {
          viewModel.deselect(item.data.path)
        }
      }

      run.tasks.adapter = RunTasksListAdapter(viewModel.tasks, onCheckChanged)
    }
  }

  private fun getWindowHeight(): Int {
    val height = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
      activity?.windowManager?.currentWindowMetrics?.bounds?.height()!!
    } else {
      val displayMetrics = DisplayMetrics()
      activity?.windowManager?.defaultDisplay?.getMetrics(displayMetrics)
      displayMetrics.heightPixels
    }
    return height
  }
}



================================================
File: java/com/itsaky/androidide/fragments/SearchResultFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.fragments

import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.adapters.SearchListAdapter

class SearchResultFragment : RecyclerViewFragment<SearchListAdapter>() {

  override fun onCreateAdapter(): RecyclerView.Adapter<*> {
    val noOp: (Any) -> Unit = {}
    return SearchListAdapter(emptyMap(), noOp, noOp)
  }
}


================================================
File: java/com/itsaky/androidide/fragments/TemplateDetailsFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.os.Bundle
import android.view.View
import androidx.core.view.isVisible
import androidx.fragment.app.activityViewModels
import androidx.fragment.app.viewModels
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.transition.TransitionManager
import com.itsaky.androidide.R
import com.itsaky.androidide.R.string
import com.itsaky.androidide.activities.MainActivity
import com.itsaky.androidide.adapters.TemplateWidgetsListAdapter
import com.itsaky.androidide.databinding.FragmentTemplateDetailsBinding
import com.itsaky.androidide.roomData.recentproject.RecentProject
import com.itsaky.androidide.tasks.executeAsyncProvideError
import com.itsaky.androidide.templates.ProjectTemplateRecipeResult
import com.itsaky.androidide.templates.StringParameter
import com.itsaky.androidide.templates.Template
import com.itsaky.androidide.templates.impl.ConstraintVerifier
import com.itsaky.androidide.utils.TemplateRecipeExecutor
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import com.itsaky.androidide.viewmodel.MainViewModel
import com.itsaky.androidide.viewmodel.RecentProjectsViewModel
import org.slf4j.LoggerFactory
import java.util.Date

/**
 * A fragment which shows a wizard-like interface for creating templates.
 *
 * @author Akash Yadav
 */
class TemplateDetailsFragment :
    FragmentWithBinding<FragmentTemplateDetailsBinding>(
        R.layout.fragment_template_details, FragmentTemplateDetailsBinding::bind
    ) {

    private val viewModel by viewModels<MainViewModel>(
        ownerProducer = { requireActivity() })

    private val recentProjectsViewModel: RecentProjectsViewModel by activityViewModels()


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewModel.template.observe(viewLifecycleOwner) {
            binding.widgets.adapter = null
            viewModel.postTransition(viewLifecycleOwner) { bindWithTemplate(it) }
        }

        viewModel.creatingProject.observe(viewLifecycleOwner) {
            TransitionManager.beginDelayedTransition(binding.root)
            binding.finish.isEnabled = !it
            binding.previous.isEnabled = !it
        }

        binding.previous.setOnClickListener {
            viewModel.setScreen(MainViewModel.SCREEN_TEMPLATE_LIST)
        }

        binding.finish.setOnClickListener {
            viewModel.creatingProject.value = true
            val template = viewModel.template.value ?: run {
                viewModel.setScreen(MainViewModel.SCREEN_MAIN)
                return@setOnClickListener
            }

            val isValid = template.parameters.fold(true) { isValid, param ->
                if (param is StringParameter) {
                    return@fold isValid && ConstraintVerifier.isValid(
                        param.value,
                        param.constraints
                    )
                } else isValid
            }

            if (!isValid) {
                viewModel.creatingProject.value = false
                flashError(string.msg_invalid_project_details)
                return@setOnClickListener
            }

            viewModel.creatingProject.value = true
            executeAsyncProvideError({
                template.recipe.execute(TemplateRecipeExecutor())
            }) { result, err ->

                viewModel.creatingProject.value = false
                if (result == null || err != null || result !is ProjectTemplateRecipeResult) {
                    err?.printStackTrace()
                    if (err != null) {
                        flashError(err.cause?.message ?: err.message)
                    } else {
                        flashError(string.project_creation_failed)
                    }
                    return@executeAsyncProvideError
                }

                viewModel.setScreen(MainViewModel.SCREEN_MAIN)
                flashSuccess(string.project_created_successfully)

                recentProjectsViewModel.insertProject(
                    RecentProject(
                        location = result.data.projectDir.path,
                        name = result.data.name,
                        createdAt = Date().toString()
                    )
                )

                viewModel.postTransition(viewLifecycleOwner) {
                    // open the project
                    (requireActivity() as MainActivity).openProject(result.data.projectDir)
                }
            }
        }

        binding.widgets.layoutManager = LinearLayoutManager(requireContext())
    }

    private fun bindWithTemplate(template: Template<*>?) {
        template ?: return

        binding.widgets.adapter = TemplateWidgetsListAdapter(template.widgets)
        binding.title.setText(template.templateName)
    }
}


================================================
File: java/com/itsaky/androidide/fragments/TemplateListFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments

import android.os.Bundle
import android.view.View
import android.view.ViewTreeObserver.OnGlobalLayoutListener
import androidx.fragment.app.viewModels
import com.google.android.flexbox.FlexDirection
import com.google.android.flexbox.FlexboxLayoutManager
import com.google.android.flexbox.JustifyContent
import com.itsaky.androidide.R
import com.itsaky.androidide.adapters.TemplateListAdapter
import com.itsaky.androidide.databinding.FragmentTemplateListBinding
import com.itsaky.androidide.templates.ITemplateProvider
import com.itsaky.androidide.templates.ProjectTemplate
import com.itsaky.androidide.utils.FlexboxUtils
import com.itsaky.androidide.viewmodel.MainViewModel
import org.slf4j.LoggerFactory

/**
 * A fragment to show the list of available templates.
 *
 * @author Akash Yadav
 */
class TemplateListFragment :
  FragmentWithBinding<FragmentTemplateListBinding>(R.layout.fragment_template_list,
    FragmentTemplateListBinding::bind) {

  private var adapter: TemplateListAdapter? = null
  private var layoutManager: FlexboxLayoutManager? = null

  private lateinit var globalLayoutListener: OnGlobalLayoutListener

  private val viewModel by viewModels<MainViewModel>(ownerProducer = { requireActivity() })

  companion object {

    private val log = LoggerFactory.getLogger(TemplateListFragment::class.java)
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    layoutManager = FlexboxLayoutManager(requireContext(), FlexDirection.ROW)
    layoutManager!!.justifyContent = JustifyContent.SPACE_EVENLY

    binding.list.layoutManager = layoutManager

    // This makes sure that the items are evenly distributed in the list
    // and the last row is always aligned to the start
    globalLayoutListener = FlexboxUtils.createGlobalLayoutListenerToDistributeFlexboxItemsEvenly(
      { adapter }, { layoutManager }) { adapter, diff ->
      adapter.fillDiff(diff)
    }

    binding.list.viewTreeObserver.addOnGlobalLayoutListener(globalLayoutListener)

    binding.exitButton.setOnClickListener {
      viewModel.setScreen(MainViewModel.SCREEN_MAIN)
    }

    viewModel.currentScreen.observe(viewLifecycleOwner) { current ->
      if (current == MainViewModel.SCREEN_TEMPLATE_DETAILS) {
        return@observe
      }

      reloadTemplates()
    }
  }

  override fun onDestroyView() {
    binding.list.viewTreeObserver.removeOnGlobalLayoutListener(globalLayoutListener)
    super.onDestroyView()
  }

  private fun reloadTemplates() {
    _binding ?: return

    log.debug("Reloading templates...")

    // Show only project templates
    // reloading the tempaltes also makes sure that the resources are
    // released from template parameter widgets
    val templates = ITemplateProvider.getInstance(reload = true).getTemplates()
      .filterIsInstance<ProjectTemplate>()

    adapter = TemplateListAdapter(templates) { template, _ ->
      viewModel.template.value = template
      viewModel.setScreen(MainViewModel.SCREEN_TEMPLATE_DETAILS)
    }

    binding.list.adapter = adapter
  }
}



================================================
File: java/com/itsaky/androidide/fragments/.DS_Store
================================================
[Non-text file]


================================================
File: java/com/itsaky/androidide/fragments/debug/CallStackFragment.kt
================================================
package com.itsaky.androidide.fragments.debug

import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.activityViewModels
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.DebuggerCallstackItemBinding
import com.itsaky.androidide.fragments.RecyclerViewFragment
import com.itsaky.androidide.viewmodel.DebuggerViewModel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * @author Akash Yadav
 */
class CallStackFragment : RecyclerViewFragment<CallStackAdapter>() {

    private val viewHolder by activityViewModels<DebuggerViewModel>()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewHolder.observeLatestAllFrames(
            notifyOn = Dispatchers.Main
        ) {
            setAdapter(onCreateAdapter())
        }

        viewHolder.observeLatestSelectedFrame(
            notifyOn = Dispatchers.Main
        ) { _, index ->
            (_binding?.root?.adapter as? CallStackAdapter?)?.apply {
                val currentSelected = selectedFrameIndex
                selectedFrameIndex = index
                notifyItemChanged(currentSelected)
                notifyItemChanged(index)
            }
        }
    }

    override fun onCreateAdapter() = CallStackAdapter(viewLifecycleScope, viewHolder.allFrames.value) { newPosition ->
        viewLifecycleScope.launch {
            viewHolder.setSelectedFrameIndex(newPosition)
        }
    }
}

class CallStackAdapter(
    private val coroutineScope: CoroutineScope,
    private val frames: List<ResolvableStackFrame>,
    private val onItemClickListener: ((Int) -> Unit)? = null
) : RecyclerView.Adapter<CallStackAdapter.VH>() {

    var selectedFrameIndex: Int = 0

    class VH(
        val binding: DebuggerCallstackItemBinding
    ) : RecyclerView.ViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
        val inflater = LayoutInflater.from(parent.context)
        val binding = DebuggerCallstackItemBinding.inflate(inflater, parent, false)
        return VH(binding)
    }

    override fun getItemCount() = frames.size

    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: VH, position: Int) {
        val binding = holder.binding
        val frame = frames[position]

        if (!frame.isResolved) {
            binding.source.text = binding.root.context.getString(R.string.debugger_status_resolving)
        }

        coroutineScope.launch {
            val descriptor = frame.resolve()
            withContext(Dispatchers.Main) {
                if (descriptor == null) {
                    binding.label.text = "<error>"
                    return@withContext
                }

                binding.source.text = "${descriptor.sourceFile}:${descriptor.lineNumber}"
                binding.label.text = descriptor.displayText()
                binding.indicator.visibility = if (position == selectedFrameIndex) View.VISIBLE else View.INVISIBLE

                binding.root.setOnClickListener {
                    onItemClickListener?.invoke(position)
                }
            }
        }
    }
}


================================================
File: java/com/itsaky/androidide/fragments/debug/DebuggerFragment.kt
================================================
package com.itsaky.androidide.fragments.debug

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.viewpager2.adapter.FragmentStateAdapter
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.tabs.TabLayoutMediator
import com.itsaky.androidide.R
import com.itsaky.androidide.activities.editor.BaseEditorActivity
import com.itsaky.androidide.databinding.FragmentDebuggerBinding
import com.itsaky.androidide.fragments.EmptyStateFragment
import com.itsaky.androidide.lsp.debug.model.ThreadDescriptor
import com.itsaky.androidide.lsp.debug.model.ThreadState
import com.itsaky.androidide.viewmodel.DebuggerConnectionState
import com.itsaky.androidide.viewmodel.DebuggerViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * @author Akash Yadav
 */
class DebuggerFragment :
    EmptyStateFragment<FragmentDebuggerBinding>(FragmentDebuggerBinding::inflate) {

    private lateinit var tabs: Array<Pair<String, Fragment>>
    private val viewModel by activityViewModels<DebuggerViewModel>()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        tabs = Array(2) { position ->
            when (position) {
                0 -> getString(R.string.debugger_variables) to VariableListFragment()
                1 -> getString(R.string.debugger_call_stack) to CallStackFragment()
                else -> throw IllegalStateException("Unknown position: $position")
            }
        }

        emptyStateViewModel.emptyMessage.value = getString(R.string.debugger_state_not_connected)
        emptyStateViewModel.isEmpty.observe(viewLifecycleOwner) { isEmpty ->
            if (isEmpty) {
                binding.threadLayoutSelector.spinnerText.clearListSelection()
            }
        }

        viewModel.observeConnectionState(
            notifyOn = Dispatchers.Main
        ) { state ->
            val message = when (state) {
                // not connected to a VM
                DebuggerConnectionState.DETACHED -> getString(R.string.debugger_state_not_connected)

                // connected, but not suspended
                DebuggerConnectionState.ATTACHED -> {
                    viewModel.debugClient.clientOrNull?.let { client ->
                        getString(R.string.debugger_state_connected, client.name, client.version)
                    }
                }

                // ----
                // No need to show any message for below states
                // the debugger UI will show the active threads, variables and call stack when the
                // VM is in one of these states

                // suspended, but not due to a breakpoint hit or step event
                DebuggerConnectionState.SUSPENDED -> null
                // suspended due to a breakpoint hit or step event
                DebuggerConnectionState.AWAITING_BREAKPOINT -> null
            }

            emptyStateViewModel.isEmpty.value = message != null
            emptyStateViewModel.emptyMessage.value = message

            if (state == DebuggerConnectionState.ATTACHED) {
                (activity as? BaseEditorActivity?)
                    ?.showBottomSheetFragment(
                        fragmentClass = DebuggerFragment::class.java,
                        sheetState = BottomSheetBehavior.STATE_HALF_EXPANDED
                    )
            }
        }

        viewModel.observeLatestThreads(
            notifyOn = Dispatchers.IO
        ) { threads ->
            coroutineScope {
                val descriptors = threads.map { thread ->
                    async {
                        thread.resolve()
                    }
                }.awaitAll()

                withContext(Dispatchers.Main) {
                    emptyStateViewModel.isEmpty.value = descriptors.isEmpty()
                    binding.threadLayoutSelector.spinnerText.setAdapter(
                        ThreadSelectorListAdapter(
                            requireContext(),
                            descriptors
                        )
                    )
                }
            }
        }

        viewModel.observeLatestSelectedThread(
            notifyOn = Dispatchers.IO
        ) { thread, index ->
            if (index < 0) {
                return@observeLatestSelectedThread
            }

            val descriptor = thread!!.resolve()
            withContext(Dispatchers.Main) {
                this@DebuggerFragment.context?.also { context ->
                    binding.threadLayoutSelector.spinnerText.apply {
                        listSelection = index
                        setText(
                            descriptor?.displayText()
                                ?: context.getString(R.string.debugger_thread_resolution_failure),
                            false
                        )
                    }
                }
            }
        }

        binding.threadLayoutSelector.spinnerText.setOnItemClickListener { _, _, index, _ ->
            viewLifecycleScope.launch {
                viewModel.setSelectedThreadIndex(index)
            }
        }

        viewLifecycleScope.launch {
            viewModel.setThreads(emptyList())
        }

        val mediator = TabLayoutMediator(binding.tabs, binding.pager) { tab, position ->
            tab.text = tabs[position].first
        }

        binding.pager.adapter = DebuggerPagerAdapter(this, tabs.map { it.second })
        mediator.attach()
    }
}

class DebuggerPagerAdapter(
    fragment: DebuggerFragment, private val fragments: List<Fragment>
) : FragmentStateAdapter(fragment) {
    override fun getItemCount(): Int = fragments.size
    override fun createFragment(position: Int): Fragment = fragments[position]
}

class ThreadSelectorListAdapter(
    context: Context, items: List<ThreadDescriptor?>
) : ArrayAdapter<ThreadDescriptor?>(context, android.R.layout.simple_dropdown_item_1line, items) {

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        val inflater = LayoutInflater.from(this.context)
        val view = (convertView ?: inflater.inflate(
            android.R.layout.simple_dropdown_item_1line, parent, false
        )) as TextView

        val item = getItem(position)
        if (item == null) {
            view.text = context.getString(R.string.debugger_thread_resolution_failure)
            return view
        }

        val isEnabled = item.state != ThreadState.UNKNOWN && item.state != ThreadState.ZOMBIE

        view.isEnabled = isEnabled
        view.text = item.displayText()
        view.alpha = if (isEnabled) 1f else 0.5f
        return view
    }
}




================================================
File: java/com/itsaky/androidide/fragments/debug/DisplayableUtils.kt
================================================
package com.itsaky.androidide.fragments.debug

import com.itsaky.androidide.lsp.debug.model.StackFrameDescriptor
import com.itsaky.androidide.lsp.debug.model.ThreadDescriptor

fun ThreadDescriptor.displayText(): String =
    "'${name}'@${id} in group '${group}': ${state.name}"

fun StackFrameDescriptor.displayText(): String =
    "${method}${methodSignature}"


================================================
File: java/com/itsaky/androidide/fragments/debug/Resolvable.kt
================================================
package com.itsaky.androidide.fragments.debug

import com.itsaky.androidide.lsp.debug.model.StackFrame
import com.itsaky.androidide.lsp.debug.model.StackFrameDescriptor
import com.itsaky.androidide.lsp.debug.model.ThreadDescriptor
import com.itsaky.androidide.lsp.debug.model.ThreadInfo
import com.itsaky.androidide.lsp.debug.model.Value
import com.itsaky.androidide.lsp.debug.model.Variable
import com.itsaky.androidide.lsp.debug.model.VariableDescriptor
import com.itsaky.androidide.lsp.debug.model.VariableKind
import com.itsaky.androidide.lsp.java.utils.completedOrNull
import com.itsaky.androidide.lsp.java.utils.getValue
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.withContext
import org.slf4j.Logger
import org.slf4j.LoggerFactory

interface Resolvable<T> {

    /**
     * Whether the value is resolved.
     */
    val isResolved: Boolean

    /**
     * Get the resolved value, or throw an exception if the value is not resolved.
     */
    val resolved: T

    /**
     * Resolve the value.
     */
    suspend fun resolve(): T?
}

abstract class AbstractResolvable<T> : Resolvable<T> {

    private val _deferred = CompletableDeferred<T>()

    val deferred: Deferred<T>
        get() = _deferred

    @OptIn(ExperimentalCoroutinesApi::class)
    override val isResolved: Boolean
        get() = deferred.completedOrNull != null

    companion object {
        @JvmStatic
        protected val logger: Logger = LoggerFactory.getLogger(AbstractResolvable::class.java)
        private val resolutionDispatcher = Dispatchers.IO
    }

    @OptIn(ExperimentalCoroutinesApi::class)
    final override suspend fun resolve(): T? {
        deferred.completedOrNull?.also { completed ->
            // already resolved
            return completed
        }

        val result = withContext(resolutionDispatcher) {
            try {
                doResolve()?.also(_deferred::complete)
            } catch (err: Throwable) {
                logger.error("Resolution failure", err)
                _deferred.completeExceptionally(err)
                null
            }
        }

        return result
    }

    protected suspend fun <T> withContext(action: suspend CoroutineScope.() -> T): T =
        withContext(resolutionDispatcher, action)

    protected abstract suspend fun doResolve(): T
}

/**
 * Get the resolved value, or return `null` if the value is not resolved.
 */
val <T> Resolvable<T>.resolvedOrNull: T?
    get() = if (isResolved) resolved else null

/**
 * Get the resolved value, or return [default value][default] if the value is not resolved.
 *
 * @param default The default value to return if the value is not resolved.
 */
fun <T> Resolvable<T>.resolvedOr(default: T): T? = if (isResolved) resolved else default

/**
 * A [variable][Variable] that is eagerly resolved.
 *
 * @author Akash Yadav
 */
@OptIn(ExperimentalCoroutinesApi::class)
class ResolvableVariable<T : Value> private constructor(
    private val delegate: Variable<T>,
) : AbstractResolvable<VariableDescriptor>(), Variable<T> by delegate, Resolvable<VariableDescriptor> {

    internal val deferredValue = CompletableDeferred<T?>()

    /**
     * Whether the variable is resolved.
     */
    override val isResolved: Boolean
        get() = super.isResolved && deferredValue.completedOrNull != null

    override val resolved: VariableDescriptor
        get() = checkNotNull(deferred.completedOrNull) {
            "Variable is not resolved"
        }

    fun resolvedName() = deferred.completedOrNull?.name ?: ""

    fun resolvedTypeName() = deferred.completedOrNull?.typeName ?: ""

    fun resolvedValue() = deferredValue.getValue(
        defaultValue = null,
    )

    fun resolvedKind(): VariableKind = deferred.completedOrNull?.kind ?: VariableKind.UNKNOWN

    companion object {

        private val logger = LoggerFactory.getLogger(ResolvableVariable::class.java)

        /**
         * Create a new eagerly-resolved variable delegating to [delegate].
         *
         * @param delegate The delegate variable.
         * @return The new eagerly-resolved variable.
         */
        fun <T : Value> create(delegate: Variable<T>): ResolvableVariable<T> {
            if (delegate is ResolvableVariable<T>) {
                return delegate
            }

            return ResolvableVariable(delegate)
        }
    }

    /**
     * Resolve the variable state.
     */
    override suspend fun doResolve(): VariableDescriptor {
        // NOTE:
        // Care must be taken to only resolve values which are absolutely needed
        // to render the UI. Resolution of values which are not immediately required must be deferred.

        val descriptor = delegate.descriptor()
        val value = delegate.value()
        deferredValue.complete(value)
        return descriptor
    }

    override suspend fun objectMembers(): Set<ResolvableVariable<*>> = withContext {
        delegate.objectMembers()
            .map { variable ->
                // members of an eagerly-resolved variable are also eagerly-resolved
                create(variable)
            }.toSet()
    }
}

/**
 * @author Akash Yadav
 */
@OptIn(ExperimentalCoroutinesApi::class)
class ResolvableStackFrame private constructor(
    private val delegate: StackFrame,
) : AbstractResolvable<StackFrameDescriptor>(), StackFrame by delegate, Resolvable<StackFrameDescriptor> {

    override val resolved: StackFrameDescriptor
        get() = checkNotNull(deferred.completedOrNull) {
            "Stack frame is not resolved"
        }

    companion object {

        /**
         * Create a new eagerly-resolved stack frame delegating to [delegate].
         */
        fun create(delegate: StackFrame): ResolvableStackFrame {
            if (delegate is ResolvableStackFrame) {
                return delegate
            }

            return ResolvableStackFrame(delegate)
        }
    }

    override suspend fun doResolve(): StackFrameDescriptor {
        return delegate.descriptor()
    }

    override suspend fun getVariables(): List<ResolvableVariable<*>> =
        delegate.getVariables().map { variable -> ResolvableVariable.create(variable) }
}

@OptIn(ExperimentalCoroutinesApi::class)
class ResolvableThreadInfo private constructor(
    private val delegate: ThreadInfo,
) : AbstractResolvable<ThreadDescriptor>(), ThreadInfo by delegate, Resolvable<ThreadDescriptor> {

    override val resolved: ThreadDescriptor
        get() = checkNotNull(deferred.completedOrNull) {
            "Thread is not resolved"
        }

    companion object {

        /**
         * Create a new eagerly-resolved thread info delegating to [delegate].
         */
        fun create(delegate: ThreadInfo): ResolvableThreadInfo {
            if (delegate is ResolvableThreadInfo) {
                return delegate
            }

            return ResolvableThreadInfo(delegate)
        }
    }

    override suspend fun doResolve(): ThreadDescriptor {
        return delegate.descriptor()
    }

    override suspend fun getFrames(): List<ResolvableStackFrame> =
        delegate.getFrames().map { frame -> ResolvableStackFrame.create(frame) }
}



================================================
File: java/com/itsaky/androidide/fragments/debug/VariableIcon.kt
================================================
package com.itsaky.androidide.fragments.debug

import android.content.res.Resources
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.ColorFilter
import android.graphics.Paint
import android.graphics.PixelFormat
import android.graphics.drawable.Drawable
import androidx.core.graphics.withTranslation

/**
 * @author Akash Yadav
 */
class CircleCharDrawable(
    private val char: Char,
    private val circle: Boolean
) :
    Drawable() {
    private val mPaint = Paint().apply {
        isAntiAlias = true
        color = Color.TRANSPARENT
    }

    private val mTextPaint = Paint().apply {
        color = -0x1
        isAntiAlias = true
        textSize = Resources.getSystem()
            .displayMetrics.density * 14
        textAlign = Paint.Align.CENTER
    }

    override fun draw(canvas: Canvas) {
        val width = bounds.right.toFloat()
        val height = bounds.bottom.toFloat()
        if (circle) {
            canvas.drawCircle(width / 2, height / 2, width / 2, mPaint)
        } else {
            canvas.drawRect(0f, 0f, width, height, mPaint)
        }
        canvas.withTranslation(width / 2f, height / 2f) {
            val textCenter = -(mTextPaint.descent() + mTextPaint.ascent()) / 2f
            drawText(char.toString(), 0f, textCenter, mTextPaint)
        }
    }

    override fun setAlpha(p1: Int) {
        mPaint.alpha = p1
        mTextPaint.alpha = p1
    }

    override fun setColorFilter(colorFilter: ColorFilter?) {
        mTextPaint.colorFilter = colorFilter
    }

    @Deprecated(
        "Deprecated in Java",
        ReplaceWith("PixelFormat.OPAQUE", "android.graphics.PixelFormat")
    )
    override fun getOpacity(): Int {
        return PixelFormat.OPAQUE
    }
}


================================================
File: java/com/itsaky/androidide/fragments/debug/VariableListBinder.kt
================================================
package com.itsaky.androidide.fragments.debug

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import com.itsaky.androidide.databinding.DebuggerSetVariableValueBinding
import com.itsaky.androidide.databinding.DebuggerVariableItemBinding
import com.itsaky.androidide.lsp.debug.model.VariableDescriptor
import com.itsaky.androidide.lsp.debug.model.VariableKind
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.DialogUtils
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.isSystemInDarkMode
import com.itsaky.androidide.viewmodel.DebuggerViewModel
import io.github.dingyi222666.view.treeview.TreeNode
import io.github.dingyi222666.view.treeview.TreeNodeEventListener
import io.github.dingyi222666.view.treeview.TreeView
import io.github.dingyi222666.view.treeview.TreeViewBinder
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory

class VariableListBinder(
    private val coroutineScope: CoroutineScope,
    private val viewModel: DebuggerViewModel
) : TreeViewBinder<ResolvableVariable<*>>() {

    private var treeIndent = 0

    companion object {
        private val logger = LoggerFactory.getLogger(VariableListBinder::class.java)
    }

    override fun createView(parent: ViewGroup, viewType: Int): View {
        val inflater = LayoutInflater.from(parent.context)
        val binding = DebuggerVariableItemBinding.inflate(inflater, parent, false)
        return binding.root
    }

    override fun getItemViewType(node: TreeNode<ResolvableVariable<*>>): Int = 0

    override fun bindView(
        holder: TreeView.ViewHolder,
        node: TreeNode<ResolvableVariable<*>>,
        listener: TreeNodeEventListener<ResolvableVariable<*>>
    ) {
        val binding = DebuggerVariableItemBinding.bind(holder.itemView)
        val context = binding.root.context

        if (treeIndent == 0) {
            treeIndent = context.resources.getDimensionPixelSize(
                R.dimen.content_padding_double
            )
        }

        binding.apply {
            root.setPaddingRelative(
                /* start = */ node.depth * treeIndent,
                /* top = */ root.paddingTop,
                /* end = */ root.paddingEnd,
                /* bottom = */ root.paddingBottom
            )

            chevron.rotation = if (node.isExpanded) 90f else 0f
        }

        if (node.data?.isResolved != true) {
            binding.label.text = context.getString(R.string.debugger_status_resolving)
        }

        val data = node.data ?: run {
            logger.error("No data set to node: {}", node)
            return
        }

        coroutineScope.launch(Dispatchers.IO) {
            val descriptor = data.resolve()
            val strValue = data.resolvedValue()?.toString()
                ?: context.getString(R.string.debugger_value_unavailable)

            withContext(Dispatchers.Main) {
                binding.apply {
                    if (descriptor == null) {
                        logger.error("Unable to resolve node: {}", data)
                        label.text = context.getString(R.string.debugger_value_error)
                        return@apply
                    }

                    val ic = descriptor.icon(context)?.let { ContextCompat.getDrawable(context, it) }

                    // noinspection SetTextI18n
                    label.text =
                        "${descriptor.name}: ${descriptor.typeName} = $strValue"
                    icon.setImageDrawable(ic ?: CircleCharDrawable(descriptor.kind.name.first(), true))

                    chevron.visibility = if (descriptor.kind == VariableKind.PRIMITIVE) View.INVISIBLE else View.VISIBLE

                    showSetValueDialogOnLongClick(binding, data, descriptor, strValue)
                }
            }
        }
    }

    private fun showSetValueDialogOnLongClick(
        binding: DebuggerVariableItemBinding,
        variable: ResolvableVariable<*>,
        descriptor: VariableDescriptor,
        currentValue: String
    ) {
        val context = binding.root.context
        binding.root.setOnLongClickListener {
            if (!descriptor.isMutable) {
                // variable is immutable
                flashError(context.getString(R.string.debugger_error_immutable_variable, descriptor.name))
                return@setOnLongClickListener false
            }

            val labelText = binding.label.text?.toString()

            if (labelText.isNullOrBlank()) return@setOnLongClickListener false

            val hasValidValue = currentValue.isNotBlank() &&
                    currentValue != context.getString(R.string.debugger_value_unavailable) &&
                    currentValue != context.getString(R.string.debugger_value_error) &&
                    currentValue != context.getString(R.string.debugger_value_null)

            if (!hasValidValue) return@setOnLongClickListener false

            showSetValueDialog(context, variable, descriptor, currentValue)
            true
        }
    }

    private fun showSetValueDialog(
        context: Context,
        variable: ResolvableVariable<*>,
        descriptor: VariableDescriptor,
        currentValue: String
    ) {
        val title = context.getString(
            R.string.debugger_variable_dialog_title,
            descriptor.name,
            descriptor.typeName
        )

        val inflater = LayoutInflater.from(context)
        val binding = DebuggerSetVariableValueBinding.inflate(inflater)
        binding.input.setText(currentValue)
        if (currentValue.isNotEmpty()) {
            binding.input.selectAll()
        }

        DialogUtils.newMaterialDialogBuilder(context)
            .setTitle(title)
            .setView(binding.root)
            .setPositiveButton(context.getString(R.string.debugger_dialog_button_set), null)
            .setNegativeButton(context.getString(android.R.string.cancel), null)
            .setCancelable(true)
            .create()
            .apply {
                setOnShowListener { dialog ->
                    getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
                        val inputLayout = binding.inputLayout
                        val input = binding.input
                        val newValue = input.text?.toString()?.takeIf(String::isNotBlank) ?: run {
                            binding.inputLayout.error = context.getString(R.string.debugger_variable_value_invalid)
                            return@setOnClickListener
                        }

                        coroutineScope.launch(Dispatchers.IO) {
                            val isSet = variable.setValue(newValue)
                            withContext(Dispatchers.Main) {
                                if (isSet) {
                                    inputLayout.error = null
                                    dialog.dismiss()
                                    viewModel.refreshState()
                                } else {
                                    inputLayout.error =
                                        context.getString(R.string.debugger_variable_value_invalid)
                                }
                            }
                        }
                    }
                }
            }
            .show()
    }
}

private fun VariableDescriptor.icon(context: Context): Int? = when (kind) {
    VariableKind.PRIMITIVE -> R.drawable.ic_db_primitive
    VariableKind.REFERENCE -> R.drawable.ic_dbg_value
    VariableKind.ARRAYLIKE -> when (context.isSystemInDarkMode()) {
        true -> R.drawable.ic_db_array_dark
        false -> R.drawable.ic_db_array
    }
    else -> null
}


================================================
File: java/com/itsaky/androidide/fragments/debug/VariableListFragment.kt
================================================
package com.itsaky.androidide.fragments.debug

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import com.itsaky.androidide.viewmodel.DebuggerViewModel
import io.github.dingyi222666.view.treeview.TreeView
import kotlinx.coroutines.Dispatchers

/**
 * @author Akash Yadav
 */
class VariableListFragment : Fragment() {

    private lateinit var treeView: TreeView<ResolvableVariable<*>>

    private val viewModel by activityViewModels<DebuggerViewModel>()

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        if (::treeView.isInitialized) {
            return treeView
        }

        treeView = TreeView(requireContext())
        return treeView
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        treeView.apply {
            supportHorizontalScroll = true
            supportDragging = false
            tree = viewModel.variablesTree.value
            binder = VariableListBinder(viewLifecycleOwner.lifecycleScope, viewModel)

            bindCoroutineScope(viewLifecycleOwner.lifecycleScope)
        }

        viewModel.observeLatestVariablesTree(
            notifyOn = Dispatchers.Main
        ) { tree ->
            treeView.tree = tree
            treeView.refresh()
        }
    }
}



================================================
File: java/com/itsaky/androidide/fragments/debug/VariableTreeNodeGenerator.kt
================================================
package com.itsaky.androidide.fragments.debug

import io.github.dingyi222666.view.treeview.AbstractTree
import io.github.dingyi222666.view.treeview.Tree
import io.github.dingyi222666.view.treeview.TreeNode
import io.github.dingyi222666.view.treeview.TreeNodeGenerator

class VariableTreeNodeGenerator private constructor(
    private val rootNodes: Set<ResolvableVariable<*>> = emptySet()
) : TreeNodeGenerator<ResolvableVariable<*>> {

    companion object {
        fun newInstance(
            rootNodes: Set<ResolvableVariable<*>> = emptySet()
        ): TreeNodeGenerator<ResolvableVariable<*>> = VariableTreeNodeGenerator(rootNodes)
    }

    override fun createNode(
        parentNode: TreeNode<ResolvableVariable<*>>,
        currentData: ResolvableVariable<*>,
        tree: AbstractTree<ResolvableVariable<*>>
    ): TreeNode<ResolvableVariable<*>> = TreeNode(
        id = Tree.generateId(),
        data = currentData,
        depth = parentNode.depth + 1,
        name = currentData.resolvedOrNull?.name ?: "<unknown>",
        isExpanded = false,
        isBranch = true,
    )

    override suspend fun fetchChildData(targetNode: TreeNode<ResolvableVariable<*>>): Set<ResolvableVariable<*>> {
        if (targetNode.id == Tree.ROOT_NODE_ID) {
            return rootNodes
        }

        val data = targetNode.data ?: return emptySet()
        return data.objectMembers()
    }

    override fun createRootNode(): TreeNode<ResolvableVariable<*>> {
        return TreeNode(
            id = Tree.ROOT_NODE_ID,
            data = null,
            depth = -1,
            name = Tree.ROOT_NODE_ID.toString(),
            isExpanded = true,
            isBranch = false,
        )
    }
}


================================================
File: java/com/itsaky/androidide/fragments/onboarding/GreetingFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.onboarding

import com.itsaky.androidide.databinding.FragmentOnboardingGreetingBinding
import com.itsaky.androidide.fragments.FragmentWithBinding

/**
 * @author Akash Yadav
 */
class GreetingFragment :
  FragmentWithBinding<FragmentOnboardingGreetingBinding>(FragmentOnboardingGreetingBinding::inflate)


================================================
File: java/com/itsaky/androidide/fragments/onboarding/IdeSetupConfigurationFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.onboarding

import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.NetworkCallback
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.text.Html
import android.text.Spannable
import android.text.SpannableStringBuilder
import android.text.style.URLSpan
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.core.content.getSystemService
import androidx.core.view.isVisible
import org.adfa.constants.ARM_KEY
import org.adfa.constants.V7_KEY
import org.adfa.constants.V8_KEY
import com.github.appintro.SlidePolicy
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.LayoutOnboardngSetupConfigBinding
import com.itsaky.androidide.models.IdeSetupArgument
import com.itsaky.androidide.resources.R.string
import com.itsaky.androidide.tasks.runOnUiThread
import com.itsaky.androidide.utils.ConnectionInfo
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.getConnectionInfo

/**
 * @author Akash Yadav
 */
class IdeSetupConfigurationFragment : OnboardingFragment(), SlidePolicy {

  private var _content: LayoutOnboardngSetupConfigBinding? = null
  private val content: LayoutOnboardngSetupConfigBinding
    get() = checkNotNull(_content) { "Fragment has been destroyed" }

  private var backgroundDataRestrictionReceiver: BroadcastReceiver? = null
  private var networkStateChangeCallback: NetworkCallback? = null

  companion object {

    @JvmStatic
    fun newInstance(context: Context): IdeSetupConfigurationFragment {
      return IdeSetupConfigurationFragment().also {
        it.arguments = Bundle().apply {
          putCharSequence(KEY_ONBOARDING_TITLE, context.getString(R.string.title_install_tools))
          putCharSequence(KEY_ONBOARDING_SUBTITLE,
            context.getString(R.string.subtitle_install_tools))
          putCharSequence(KEY_ONBOARDING_EXTRA_INFO,
            Html.fromHtml(context.getString(R.string.msg_install_tools),
              Html.FROM_HTML_MODE_COMPACT))
        }
      }
    }
  }

  @SuppressLint("PrivateResource")
  override fun createContentView(parent: ViewGroup, attachToParent: Boolean) {
    _content = LayoutOnboardngSetupConfigBinding.inflate(layoutInflater, parent, attachToParent)

    content.apply {
      noConnection.root.setText(R.string.msg_no_internet)
      cellularConnection.root.setText(R.string.msg_connected_to_cellular)
      meteredConnection.root.setText(R.string.msg_connected_to_metered_connection)
      backgroundDataRestricted.root.setText(R.string.msg_disable_background_data_restriction)

      sdkVersionLayout.isEnabled = true
      jdkVersionLayout.isEnabled = true
      installGit.isEnabled = true
      installOpenssh.isEnabled = true

      val sdkVersions = SdkVersion.entries.map { "SDK ${it.version}" }.reversed()
      sdkVersion.setText(sdkVersions[0])
      sdkVersion.setAdapter(ArrayAdapter(
        requireContext(),
        com.google.android.material.R.layout.m3_auto_complete_simple_item,
        sdkVersions)
      )

      val jdkVersions = JdkVersion.entries.map { "JDK ${it.version}" }
      jdkVersion.setText(jdkVersions[0])
      jdkVersion.setAdapter(ArrayAdapter(
        requireContext(),
        com.google.android.material.R.layout.m3_auto_complete_simple_item,
        jdkVersions)
      )
    }

    updateConnectionStatus()
  }

  fun buildIdeSetupArguments(): Array<String> {
    val args = mutableListOf<String>()
    // this is unused due to idesetup.sh changes
    // I want to keep this as an example in case we will need termux bash scrip arguments in the future.

    args.setArgument(IdeSetupArgument.INSTALL_DIR, Environment.HOME.absolutePath)
    args.setArgument(IdeSetupArgument.SDK_VERSION,
      SdkVersion.fromDisplayName(content.sdkVersion.text).version)
    args.setArgument(IdeSetupArgument.JDK_VERSION,
      JdkVersion.fromDisplayName(content.jdkVersion.text).version)
    args.setArgument(IdeSetupArgument.ASSUME_YES)
    if (content.installGit.isChecked) {
      args.setArgument(IdeSetupArgument.WITH_GIT)
    }
    if (content.installOpenssh.isChecked) {
      args.setArgument(IdeSetupArgument.WITH_OPENSSH)
    }
    args.setArgument(IdeSetupArgument.OFFLINE_MODE, true)
    args.setArgument(IdeSetupArgument.CACHE_DIR, "../../cache/apt/archives")
    args.setArgument(IdeSetupArgument.ABI_FOLDER, getAbiFolder(Build.SUPPORTED_ABIS[0]))
    return args.toTypedArray()
  }

  private fun MutableList<String>.setArgument(argument: IdeSetupArgument, value: Any? = null) {
    val strVal = value?.toString() ?: ""
    if (argument.requiresValue && strVal.isBlank()) {
      throw IllegalArgumentException("${argument.name} requires a value")
    }

    add(argument.argumentName)
    add(strVal)
  }

  private fun getAbiFolder(deviceAbi:String) : String {
    val abiList = listOf(V8_KEY, V7_KEY, ARM_KEY)  // List of substrings to check for

    val index = abiList.indexOfFirst { deviceAbi.contains(it) }
    return abiList[index]
  }

  override fun onStart() {
    super.onStart()
    updateConnectionStatus()
    monitorNetworkState()
  }

  override fun onStop() {
    super.onStop()
    removeNetworkMonitors()
  }

  private fun updateConnectionStatus(networkCapabilities: NetworkCapabilities? = null) =
    updateConnectionStatus(getConnectionInfo(requireContext(), networkCapabilities))

  private fun updateConnectionStatus(connectionInfo: ConnectionInfo) = runOnUiThread {
    content.noConnection.root.isVisible = false
    content.cellularConnection.root.isVisible = false
    content.meteredConnection.root.isVisible = false
    content.backgroundDataRestricted.root.isVisible = false

    if (connectionInfo === ConnectionInfo.UNKNOWN || !connectionInfo.isConnected) {
      showNoConnectionWarning()
      return@runOnUiThread
    }

    if (connectionInfo.isCellularTransport) {
      addCellularTransportWarning()
    }

    if (connectionInfo.isMeteredConnection && !connectionInfo.isCellularTransport) {
      addMeteredConnectionWarning()
    }

    if (connectionInfo.isBackgroundDataRestricted) {
      addBackgroundDataRestrictedWarning()
    }
  }

  private fun addBackgroundDataRestrictedWarning() {
    content.backgroundDataRestricted.root.apply {
      setText(R.string.msg_disable_background_data_restriction)
      isVisible = true
    }
  }

  private fun addMeteredConnectionWarning() {
    content.meteredConnection.root.apply {
      setText(R.string.msg_connected_to_metered_connection)
      isVisible = true
    }
  }

  private fun addCellularTransportWarning() {
    content.cellularConnection.root.apply {
      setText(R.string.msg_connected_to_cellular)
      isVisible = true
    }
  }

  private fun showNoConnectionWarning() {
    val msg = SpannableStringBuilder(getString(R.string.msg_no_internet))
    msg.append(" ")
    msg.append(getString(R.string.action_open_settings), URLSpan(""),
      Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
    )

    content.noConnection.root.apply {
      isVisible = true
      setOnClickListener {
        it.context.startActivity(Intent(Settings.ACTION_WIFI_SETTINGS))
      }
    }
  }

  override fun onDestroyView() {
    super.onDestroyView()
    backgroundDataRestrictionReceiver = null
    networkStateChangeCallback = null
  }

  override val isPolicyRespected: Boolean
    get() = getConnectionInfo(requireContext()).isConnected

  override fun onUserIllegallyRequestedNextPage() {
    flashError(string.msg_no_internet)
  }

  private fun monitorNetworkState() {
    val connectivityManager = requireContext().getSystemService<ConnectivityManager>() ?: return
    networkStateChangeCallback?.also {
      connectivityManager.registerDefaultNetworkCallback(it)
    }

    networkStateChangeCallback = object : NetworkCallback() {

      override fun onCapabilitiesChanged(
        network: Network,
        networkCapabilities: NetworkCapabilities
      ) {
        updateConnectionStatus(networkCapabilities)
      }

      override fun onLost(network: Network) {
        updateConnectionStatus(ConnectionInfo.UNKNOWN)
      }
    }

    val networkRequest = NetworkRequest.Builder()
      .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
      .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
      .addTransportType(NetworkCapabilities.TRANSPORT_ETHERNET)
      .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
      .build()
    connectivityManager.registerNetworkCallback(networkRequest, networkStateChangeCallback!!)

    backgroundDataRestrictionReceiver?.also {
      try {
        requireContext().unregisterReceiver(it)
      } catch (err: Throwable) { /*ignored*/
      }
    }

    backgroundDataRestrictionReceiver = object : BroadcastReceiver() {
      override fun onReceive(context: Context?, intent: Intent?) {
        updateConnectionStatus()
      }
    }

    requireContext().registerReceiver(backgroundDataRestrictionReceiver!!,
      IntentFilter(ConnectivityManager.ACTION_RESTRICT_BACKGROUND_CHANGED))
  }

  private fun removeNetworkMonitors() {
    networkStateChangeCallback?.also {
      requireContext().getSystemService<ConnectivityManager>()?.unregisterNetworkCallback(it)
      networkStateChangeCallback = null
    }

    backgroundDataRestrictionReceiver?.also {
      requireContext().unregisterReceiver(it)
      backgroundDataRestrictionReceiver = null
    }
  }

}


================================================
File: java/com/itsaky/androidide/fragments/onboarding/OnboardingFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.onboarding

import android.os.Bundle
import android.view.View
import android.view.ViewGroup
import androidx.core.text.method.LinkMovementMethodCompat
import androidx.core.view.updateLayoutParams
import com.itsaky.androidide.databinding.FragmentOnboardingBinding
import com.itsaky.androidide.fragments.FragmentWithBinding

open class OnboardingFragment :
  FragmentWithBinding<FragmentOnboardingBinding>(FragmentOnboardingBinding::inflate) {

  companion object {

    const val KEY_ONBOARDING_TITLE = "ide.onboarding.fragment.title"
    const val KEY_ONBOARDING_SUBTITLE = "ide.onboarding.fragment.subtitle"
    const val KEY_ONBOARDING_EXTRA_INFO = "ide.onboarding.fragment.extraInfo"

    @JvmStatic
    fun newInstance(title: CharSequence, subtitle: CharSequence,
      extraInfo: CharSequence = ""): OnboardingFragment {
      return OnboardingFragment().apply {
        arguments = Bundle().apply {
          putCharSequence(KEY_ONBOARDING_TITLE, title)
          putCharSequence(KEY_ONBOARDING_SUBTITLE, subtitle)
          putCharSequence(KEY_ONBOARDING_EXTRA_INFO, extraInfo)
        }
      }
    }
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    binding.onboardingTitle.text = requireArguments().getCharSequence(KEY_ONBOARDING_TITLE)
    binding.onboardingSubtitle.text = requireArguments().getCharSequence(KEY_ONBOARDING_SUBTITLE)

    val extraInfo = requireArguments().getCharSequence(KEY_ONBOARDING_EXTRA_INFO, "")
    if (extraInfo.isBlank()) {
      binding.onboardingExtraInfo.updateLayoutParams<ViewGroup.LayoutParams> {
        height = 0
      }
    } else {
      binding.onboardingExtraInfo.movementMethod = LinkMovementMethodCompat.getInstance()
      binding.onboardingExtraInfo.text = extraInfo
    }

    binding.contentContainer.removeAllViews()
    createContentView(binding.contentContainer, true)
  }

  protected open fun createContentView(parent: ViewGroup, attachToParent: Boolean) {}
}


================================================
File: java/com/itsaky/androidide/fragments/onboarding/OnboardingInfoFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.onboarding

import android.content.res.ColorStateList
import android.os.Bundle
import android.view.View
import androidx.annotation.ColorInt
import androidx.annotation.DrawableRes
import androidx.core.widget.ImageViewCompat
import com.itsaky.androidide.databinding.FragmentOnboardingInfoBinding
import com.itsaky.androidide.fragments.FragmentWithBinding

/**
 * @author Akash Yadav
 */
class OnboardingInfoFragment :
  FragmentWithBinding<FragmentOnboardingInfoBinding>(FragmentOnboardingInfoBinding::inflate) {

  companion object {

    const val KEY_INFO_TEXT = "ide.onboarding.infoFragment.info"
    const val KEY_INFO_ICON = "ide.onboarding.infoFragment.icon"
    const val KEY_INFO_ICON_TINT = "ide.onboarding.infoFragment.icon.tint"

    @JvmStatic
    fun newInstance(
      title: CharSequence,
      info: CharSequence,
      @DrawableRes icon: Int,
      @ColorInt iconTint: Int
    ): OnboardingInfoFragment {
      return OnboardingInfoFragment().apply {
        arguments = Bundle().apply {
          putCharSequence(OnboardingFragment.KEY_ONBOARDING_TITLE, title)
          putCharSequence(KEY_INFO_TEXT, info)
          putInt(KEY_INFO_ICON, icon)
          putInt(KEY_INFO_ICON_TINT, iconTint)
        }
      }
    }
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    binding.infoTitle.text = requireArguments().getCharSequence(
      OnboardingFragment.KEY_ONBOARDING_TITLE)

    binding.infoMessage.text = requireArguments().getCharSequence(KEY_INFO_TEXT)
    binding.image.setImageResource(requireArguments().getInt(KEY_INFO_ICON))
    ImageViewCompat.setImageTintList(binding.image,
      ColorStateList.valueOf(requireArguments().getInt(
        KEY_INFO_ICON_TINT)))
  }
}


================================================
File: java/com/itsaky/androidide/fragments/onboarding/OnboardingMultiActionFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.onboarding

import android.os.Build
import android.os.Bundle
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.adapters.onboarding.DefaultOnboardingItemAdapter
import com.itsaky.androidide.databinding.LayoutOnboardingMultiactionBinding
import com.itsaky.androidide.models.OnboardingItem
import com.itsaky.androidide.utils.uncheckedCast

/**
 * @author Akash Yadav
 */
open class OnboardingMultiActionFragment : OnboardingFragment() {

  protected var recyclerView: RecyclerView? = null
    private set

  companion object {

    const val KEY_ACTION_ITEMS = "ide.onboarding.multiActionFragment.items"

    @JvmStatic
    fun newInstance(
      title: CharSequence,
      subtitle: CharSequence,
      items: List<OnboardingItem>
    ): OnboardingFragment {
      return OnboardingMultiActionFragment().apply {
        arguments = Bundle().apply {
          putCharSequence(KEY_ONBOARDING_TITLE, title)
          putCharSequence(KEY_ONBOARDING_SUBTITLE, subtitle)

          val arr = items.toTypedArray()
          putParcelableArray(KEY_ACTION_ITEMS, arr)
        }
      }
    }
  }

  override fun createContentView(parent: ViewGroup, attachToParent: Boolean) {
    val binding = LayoutOnboardingMultiactionBinding.inflate(layoutInflater, parent, attachToParent)
    binding.onboardingItems.adapter = createAdapter()
    recyclerView = binding.onboardingItems
  }

  protected inline fun <reified T : OnboardingItem> getItemsFromArgs(): Array<T> {
    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
      requireArguments().getParcelableArray(KEY_ACTION_ITEMS, T::class.java)!!
    } else {
      uncheckedCast(
        @Suppress("DEPRECATION") requireArguments().getParcelableArray(KEY_ACTION_ITEMS)!!)
    }
  }

  override fun onDestroyView() {
    super.onDestroyView()
    recyclerView = null
  }

  protected open fun createAdapter(): RecyclerView.Adapter<*> {
    val items = getItemsFromArgs<OnboardingItem>()
    return DefaultOnboardingItemAdapter(items.toList())
  }
}


================================================
File: java/com/itsaky/androidide/fragments/onboarding/PermissionsFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.onboarding

import android.Manifest
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.os.Environment
import android.provider.Settings
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.app.ActivityCompat
import androidx.recyclerview.widget.RecyclerView
import com.github.appintro.SlidePolicy
import com.itsaky.androidide.R
import com.itsaky.androidide.utils.isAccessibilityEnabled
import com.itsaky.androidide.adapters.onboarding.OnboardingPermissionsAdapter
import com.itsaky.androidide.buildinfo.BuildInfo
import com.itsaky.androidide.models.OnboardingPermissionItem
import com.itsaky.androidide.services.debug.ForegroundDetectionService
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.isAtLeastR

/**
 * @author Akash Yadav
 */
class PermissionsFragment : OnboardingMultiActionFragment(), SlidePolicy {

  var adapter: OnboardingPermissionsAdapter? = null

  private val storagePermissionRequestLauncher = registerForActivityResult(
    ActivityResultContracts.RequestMultiplePermissions()) {
    onPermissionsUpdated()
  }

  private val settingsTogglePermissionRequestLauncher = registerForActivityResult(
    ActivityResultContracts.StartActivityForResult()) {
    onPermissionsUpdated()
  }

  private val permissions by lazy {
    getRequiredPermissions(requireContext())
  }

  companion object {

    @JvmStatic
    fun newInstance(context: Context): PermissionsFragment {
      return PermissionsFragment().apply {
        arguments = Bundle().apply {
          putCharSequence(KEY_ONBOARDING_TITLE,
            context.getString(R.string.onboarding_title_permissions))
          putCharSequence(KEY_ONBOARDING_SUBTITLE,
            context.getString(R.string.onboarding_subtitle_permissions))
        }
      }
    }

    @JvmStatic
    fun getRequiredPermissions(context: Context): List<OnboardingPermissionItem> {
      val permissions = mutableListOf<OnboardingPermissionItem>()

      permissions.add(OnboardingPermissionItem(Manifest.permission_group.STORAGE,
        R.string.permission_title_storage, R.string.permission_desc_storage,
        isStoragePermissionGranted(context)))

      permissions.add(OnboardingPermissionItem(Manifest.permission.REQUEST_INSTALL_PACKAGES,
        R.string.permission_title_install_packages, R.string.permission_desc_install_packages,
        canRequestPackageInstalls(context)))

      permissions.add(OnboardingPermissionItem(Manifest.permission.SYSTEM_ALERT_WINDOW,
        R.string.permission_title_overlay_window, R.string.permission_desc_overlay_window,
        canDrawOverlays(context)))

      permissions.add(OnboardingPermissionItem(Manifest.permission.BIND_ACCESSIBILITY_SERVICE,
        R.string.permission_title_accessibility, R.string.permission_desc_accessibility,
        canDetectForegroundApps(context), isOptional = true
      ))

      return permissions
    }

      @JvmStatic
      fun canDetectForegroundApps(context: Context): Boolean = context.isAccessibilityEnabled<ForegroundDetectionService>()

    @JvmStatic
    fun canDrawOverlays(context: Context) : Boolean = Settings.canDrawOverlays(context)

    @JvmStatic
    fun areAllPermissionsGranted(context: Context) : Boolean = getRequiredPermissions(context).all { it.isOptional || it.isGranted }

    @JvmStatic
    fun isStoragePermissionGranted(context: Context): Boolean {
      if (isAtLeastR()) {
        return Environment.isExternalStorageManager()
      }

      return checkSelfPermission(context,
        Manifest.permission.READ_EXTERNAL_STORAGE) && checkSelfPermission(context,
        Manifest.permission.WRITE_EXTERNAL_STORAGE)
    }

    @JvmStatic
    fun canRequestPackageInstalls(context: Context): Boolean {
      return context.packageManager.canRequestPackageInstalls()
    }

    @JvmStatic
    fun isPermissionGranted(context: Context, permission: String): Boolean {
      return when (permission) {
        Manifest.permission_group.STORAGE -> isStoragePermissionGranted(context)
        Manifest.permission.REQUEST_INSTALL_PACKAGES -> context.packageManager.canRequestPackageInstalls()
        Manifest.permission.SYSTEM_ALERT_WINDOW -> canDrawOverlays(context)
        Manifest.permission.BIND_ACCESSIBILITY_SERVICE -> canDetectForegroundApps(context)
        else -> checkSelfPermission(context, permission)
      }
    }

    @JvmStatic
    fun checkSelfPermission(context: Context, permission: String): Boolean {
      return ActivityCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED
    }
  }

  override fun createAdapter(): RecyclerView.Adapter<*> {
    return OnboardingPermissionsAdapter(permissions,
      this::requestPermission).also { this.adapter = it }
  }

  private fun onPermissionsUpdated() {
    permissions.forEach { it.isGranted = isPermissionGranted(requireContext(), it.permission) }
    recyclerView?.adapter = createAdapter()
  }

  private fun requestPermission(permission: String) {
    when (permission) {
      Manifest.permission_group.STORAGE -> requestStoragePermission()
      Manifest.permission.REQUEST_INSTALL_PACKAGES -> requestSettingsTogglePermission(
        Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES)
      Manifest.permission.SYSTEM_ALERT_WINDOW -> requestSettingsTogglePermission(Settings.ACTION_MANAGE_OVERLAY_PERMISSION)
      Manifest.permission.BIND_ACCESSIBILITY_SERVICE -> requestSettingsTogglePermission(Settings.ACTION_ACCESSIBILITY_SETTINGS, false)
    }
  }

  private fun requestStoragePermission() {
    if (isAtLeastR()) {
      requestSettingsTogglePermission(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION)
      return
    }

    storagePermissionRequestLauncher.launch(arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE,
      Manifest.permission.WRITE_EXTERNAL_STORAGE))
  }

  private fun requestSettingsTogglePermission(action: String, setData: Boolean = true) {
    val intent = Intent(action)
    if (setData) {
      intent.setData(Uri.fromParts("package", BuildInfo.PACKAGE_NAME, null))
    }
    try {
      settingsTogglePermissionRequestLauncher.launch(intent)
    } catch (err: Throwable) {
      flashError(getString(R.string.err_no_activity_to_handle_action, action))
    }
  }

  override val isPolicyRespected: Boolean
    get() = permissions.all { it.isOptional || it.isGranted }

  override fun onUserIllegallyRequestedNextPage() {
    activity?.flashError(R.string.msg_grant_permissions)
  }
}


================================================
File: java/com/itsaky/androidide/fragments/onboarding/StatisticsFragment.kt
================================================
package com.itsaky.androidide.fragments.onboarding

import android.content.Context
import android.os.Bundle
import android.view.ViewGroup
import com.itsaky.androidide.R
import com.itsaky.androidide.app.IDEApplication
import com.itsaky.androidide.databinding.LayoutOnboardingStatisticsBinding

class StatisticsFragment : OnboardingFragment() {

  private var _content: LayoutOnboardingStatisticsBinding? = null
  private val content: LayoutOnboardingStatisticsBinding
    get() = checkNotNull(_content) { "Fragment has been destroyed" }

  companion object {

    @JvmStatic
    fun newInstance(context: Context): StatisticsFragment {
      return StatisticsFragment().apply {
        arguments = Bundle().apply {
          putCharSequence(KEY_ONBOARDING_TITLE,
            context.getString(R.string.title_androidide_statistics))
          putCharSequence(KEY_ONBOARDING_SUBTITLE,
            context.getString(R.string.idepref_stats_optIn_summary))
        }
      }
    }
  }

  override fun createContentView(parent: ViewGroup, attachToParent: Boolean) {
    _content = LayoutOnboardingStatisticsBinding.inflate(layoutInflater, parent, attachToParent)
    content.statOptIn.isChecked = true
  }

  override fun onDestroy() {
    super.onDestroy()
    _content = null
  }

  fun updateStatOptInStatus() {
    com.itsaky.androidide.preferences.internal.StatPreferences.statOptIn =
      _content?.statOptIn?.isChecked ?: false

    IDEApplication.instance.reportStatsIfNecessary()
  }
}


================================================
File: java/com/itsaky/androidide/fragments/onboarding/ideSetupConfig.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.onboarding

import com.itsaky.androidide.app.configuration.CpuArch

private val ARM_ONLY = arrayOf(CpuArch.AARCH64, CpuArch.ARM)
private val ALL = arrayOf(CpuArch.AARCH64, CpuArch.ARM, CpuArch.X86_64)

/**
 * Android SDK versions.
 *
 * @author Akash Yadav
 */
enum class SdkVersion(val version: String, val supportedArchs: Array<CpuArch>) {

  SDK_33_0_1("33.0.1", ARM_ONLY),
  SDK_34_0_0("34.0.0", ARM_ONLY),
  SDK_34_0_1("34.0.1", ARM_ONLY),
  SDK_34_0_3("34.0.3", ARM_ONLY),
  SDK_34_0_4("34.0.4", ALL),
  ;

  val displayName = "SDK $version"

  companion object {

    @JvmStatic
    fun fromDisplayName(displayName: CharSequence) =
      entries.first { it.displayName.contentEquals(displayName) }

    @JvmStatic
    fun fromVersion(version: CharSequence) = entries.first { it.version.contentEquals(version) }
  }
}

/**
 * JDK versions.
 *
 * @author Akash Yadav
 */
enum class JdkVersion(val version: String) {

  JDK_17("17"),
  JDK_21("21"),
  ;

  val displayName = "JDK $version"

  companion object {

    @JvmStatic
    fun fromDisplayName(displayName: CharSequence) =
      entries.first { it.displayName.contentEquals(displayName) }

    @JvmStatic
    fun fromVersion(version: CharSequence) = entries.first { it.version.contentEquals(version) }
  }
}


================================================
File: java/com/itsaky/androidide/fragments/output/AppLogFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.output

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Bundle
import android.view.View
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import com.itsaky.androidide.R
import com.itsaky.androidide.preferences.internal.DevOpsPreferences
import com.itsaky.androidide.services.log.ConnectionObserverParams
import com.itsaky.androidide.services.log.LogReceiverImpl
import com.itsaky.androidide.services.log.LogReceiverService
import com.itsaky.androidide.services.log.LogReceiverServiceConnection
import com.itsaky.androidide.services.log.lookupLogService
import org.slf4j.LoggerFactory
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Fragment to show application logs.
 * @author Akash Yadav
 */
class AppLogFragment : LogViewFragment() {

  private val isBoundToLogReceiver = AtomicBoolean(false)

  private var logServiceConnection: LogReceiverServiceConnection? = null
  private var logReceiverImpl: LogReceiverImpl? = null

  private val logServiceConnectionObserver = object : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {
      if (intent?.action != LogReceiverService.ACTION_CONNECTION_UPDATE) {
        log.warn(
          "Received invalid broadcast. Action '${LogReceiverService.ACTION_CONNECTION_UPDATE}' is expected.")
        return
      }

      val params = ConnectionObserverParams.from(intent) ?: run {
        log.warn(
          "Received ${LogReceiverService.ACTION_CONNECTION_UPDATE} broadcast, but invalid extras were provided: $intent")
        return
      }

      val isBound = isBoundToLogReceiver.get()
      if (!isBound && params.totalConnections > 0) {
        // log receiver has been connected to one or more log senders
        // bind to the receiver and notify senders to start reading logs
        bindToLogReceiver()
        return
      }

      if (isBound && params.totalConnections == 0) {
        // all log senders have been disconnected from the log receiver
        // unbind from the log receiver
        unbindFromLogReceiver()
        return
      }
    }
  }

  companion object {

    private val log = LoggerFactory.getLogger(AppLogFragment::class.java)
  }

  override fun isSimpleFormattingEnabled() = false
  override fun getFilename() = "app_logs"

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    emptyStateViewModel.emptyMessage.value = if (DevOpsPreferences.logsenderEnabled) {
      getString(R.string.msg_emptyview_applogs)
    } else {
      getString(R.string.msg_logsender_disabled)
    }

    registerLogConnectionObserver()
  }

  override fun onDestroyView() {
    super.onDestroyView()
    unregisterLogConnectionObserver()

    if (isBoundToLogReceiver.get()) {
      unbindFromLogReceiver()
    }
  }

  private fun registerLogConnectionObserver() {
    try {
      val intentFilter = IntentFilter(LogReceiverService.ACTION_CONNECTION_UPDATE)
      LocalBroadcastManager.getInstance(requireContext())
        .registerReceiver(logServiceConnectionObserver, intentFilter)
    } catch (e: Exception) {
      log.warn("Failed to register connection observer for LogReceiverService", e)
    }
  }

  private fun unregisterLogConnectionObserver() {
    try {
      LocalBroadcastManager.getInstance(requireContext())
        .unregisterReceiver(logServiceConnectionObserver)
    } catch (e: Exception) {
      log.warn("Failed to unregister connection observer for LogReceiverService", e)
    }
  }

  private fun bindToLogReceiver() {
    try {
      if (!DevOpsPreferences.logsenderEnabled) {
        log.info("LogSender is disabled. LogReceiver service won't be started...")

        // release the connection listener
        logServiceConnection?.onConnected = null
        return
      }

      val context = context ?: return
      val intent = Intent(context, LogReceiverService::class.java).setAction(
        LogReceiverService.ACTION_CONNECT_LOG_CONSUMER)

      val serviceConnection = logServiceConnection ?: LogReceiverServiceConnection { binder ->
        logReceiverImpl = binder
        lookupLogService()?.setConsumer(this::appendLog)
      }.also { serviceConnection ->
        logServiceConnection = serviceConnection
      }

      // do not auto create the service with BIND_AUTO_CREATE
      check(context.bindService(intent, serviceConnection, Context.BIND_IMPORTANT))
      this.isBoundToLogReceiver.set(true)
      log.info("LogReceiver service is being started")
    } catch (err: Throwable) {
      log.error("Failed to start LogReceiver service", err)
    }
  }

  private fun unbindFromLogReceiver() {
    try {
      if (!DevOpsPreferences.logsenderEnabled) {
        return
      }

      lookupLogService()?.setConsumer(null)
      logReceiverImpl?.disconnectAll()

      val serviceConnection = logServiceConnection ?: run {
        log.warn("Trying to unbind from LogReceiverService, but ServiceConnection is null")
        return
      }

      val context = context ?: return
      context.unbindService(serviceConnection)

      this.isBoundToLogReceiver.set(false)
      log.info("Unbound from LogReceiver service")
    } catch (e: Exception) {
      log.error("Failed to unbind from LogReceiver service")
    } finally {
      this.logServiceConnection?.onConnected = null
      this.logServiceConnection = null

      this.logReceiverImpl = null
    }
  }
}


================================================
File: java/com/itsaky/androidide/fragments/output/BuildOutputFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.fragments.output

import android.os.Bundle
import android.view.View
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R

class BuildOutputFragment : NonEditableEditorFragment() {
  private val unsavedLines: MutableList<String?> = ArrayList()
  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    emptyStateViewModel.emptyMessage.value = getString(R.string.msg_emptyview_buildoutput)
    if (unsavedLines.isNotEmpty()) {
      for (line in unsavedLines) {
        editor?.append("${line!!.trim()}\n")
      }
      unsavedLines.clear()
    }
  }
  
  override fun onDestroyView() {
    editor?.release()
    super.onDestroyView()
  }
  
  fun appendOutput(output: String?) {
    if (editor == null) {
      unsavedLines.add(output)
      return
    }
    ThreadUtils.runOnUiThread {
      val message = if (output == null || output.endsWith("\n")) {
        output
      } else {
        "${output}\n"
      }
      editor!!.append(message).also {
        emptyStateViewModel.isEmpty.value = false
      }
    }
  }
}


================================================
File: java/com/itsaky/androidide/fragments/output/IDELogFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.output

import android.os.Bundle
import android.view.View
import androidx.lifecycle.Lifecycle
import ch.qos.logback.classic.Logger
import ch.qos.logback.classic.LoggerContext
import com.itsaky.androidide.R
import com.itsaky.androidide.logging.LifecycleAwareAppender
import org.slf4j.LoggerFactory

/**
 * Fragment to show IDE logs.
 * @author Akash Yadav
 */
class IDELogFragment : LogViewFragment() {

  private val lifecycleAwareAppender = LifecycleAwareAppender(Lifecycle.State.CREATED)

  override fun isSimpleFormattingEnabled() = true
  override fun getFilename() = "ide_logs"

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    emptyStateViewModel.emptyMessage.value = getString(R.string.msg_emptyview_idelogs)

    lifecycleAwareAppender.consumer = this::appendLine
    lifecycleAwareAppender.attachTo(viewLifecycleOwner)

    val loggerContext = LoggerFactory.getILoggerFactory() as LoggerContext
    val rootLogger = LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME) as Logger

    lifecycleAwareAppender.context = loggerContext
    lifecycleAwareAppender.start()

    rootLogger.addAppender(lifecycleAwareAppender)
  }

  override fun onDestroy() {
    super.onDestroy()
    lifecycleAwareAppender.stop()

    val logger = LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME) as Logger
    logger.detachAppender(lifecycleAwareAppender)
  }
}


================================================
File: java/com/itsaky/androidide/fragments/output/LogViewFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.output

import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.view.View
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.FragmentLogBinding
import com.itsaky.androidide.editor.language.treesitter.LogLanguage
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguageProvider
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.editor.schemes.IDEColorSchemeProvider
import com.itsaky.androidide.fragments.EmptyStateFragment
import com.itsaky.androidide.models.LogLine
import com.itsaky.androidide.utils.ILogger.Level
import com.itsaky.androidide.utils.jetbrainsMono
import com.itsaky.androidide.utils.isTestMode
import io.github.rosemoe.sora.widget.style.CursorAnimator
import org.slf4j.LoggerFactory
import java.util.concurrent.ArrayBlockingQueue
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock
import kotlin.math.min

/**
 * Fragment to show logs.
 *
 * @author Akash Yadav
 */
abstract class LogViewFragment :
  EmptyStateFragment<FragmentLogBinding>(R.layout.fragment_log, FragmentLogBinding::bind),
  ShareableOutputFragment {

  companion object {

    private val log = LoggerFactory.getLogger(LogViewFragment::class.java)

    /** The maximum number of characters to append to the editor in case of huge log texts. */
    const val MAX_CHUNK_SIZE = 10000

    /**
     * The time duration, in milliseconds which is used to determine whether logs are too frequent
     * or not. If the logs are produced within this time duration, they are considered as too
     * frequent. In this case, the logs are cached and appended in chunks of [MAX_CHUNK_SIZE]
     * characters in size.
     */
    const val LOG_FREQUENCY = 50L

    /**
     * The time duration, in milliseconds we wait before appending the logs. This must be greater
     * than [LOG_FREQUENCY].
     */
    const val LOG_DELAY = 100L

    /**
     * Trim the logs when the number of lines reaches this value. Only [MAX_LINE_COUNT]
     * number of lines are kept in the logs.
     */
    const val TRIM_ON_LINE_COUNT = 5000

    /**
     * The maximum number of lines that are shown in the log view. This value must be less than
     * [TRIM_ON_LINE_COUNT] by a difference of [LOG_FREQUENCY] or preferably, more.
     */
    const val MAX_LINE_COUNT = TRIM_ON_LINE_COUNT - 300
  }

  private var lastLog = -1L

  private val cacheLock = ReentrantLock()
  private val cache = StringBuilder()
  private var cacheLineTrack = ArrayBlockingQueue<Int>(MAX_LINE_COUNT, true)

  private val isTrimming = AtomicBoolean(false)

  private val logHandler = Handler(Looper.getMainLooper())
  private val logRunnable = object : Runnable {
    override fun run() {
      cacheLock.withLock {
        if (cacheLineTrack.size == MAX_LINE_COUNT) {
          cache.delete(0, cacheLineTrack.poll()!!)
        }

        cacheLineTrack.clear()

        if (cache.length < MAX_CHUNK_SIZE) {
          append(cache)
          cache.clear()
        } else {
          // Append the lines in chunks to avoid UI lags
          val length = min(cache.length, MAX_CHUNK_SIZE)
          append(cache.subSequence(0, length))
          cache.delete(0, length)
        }

        if (cache.isNotEmpty()) {
          // if we still have data left to append, resechedule this
          logHandler.removeCallbacks(this)
          logHandler.postDelayed(this, LOG_DELAY)
        } else {
          trimLinesAtStart()
        }
      }
    }
  }

  fun appendLog(line: LogLine) {

    val lineString = if (isSimpleFormattingEnabled()) {
      line.toSimpleString()
    } else {
      line.toString()
    }

    line.recycle()

    appendLine(lineString)
  }

  protected fun appendLine(line: String) {
    var lineStr = line
    if (!lineStr.endsWith("\n")) {
      lineStr += "\n"
    }

    if (isTrimming.get() || cache.isNotEmpty() || System.currentTimeMillis() - lastLog <= LOG_FREQUENCY) {
      cacheLock.withLock {
        logHandler.removeCallbacks(logRunnable)

        // If the log lines are too frequent, cache the lines to log them later at once
        cache.append(lineStr)
        logHandler.postDelayed(logRunnable, LOG_DELAY)

        lastLog = System.currentTimeMillis()

        val length = cache.length + 1
        if (!cacheLineTrack.offer(length)) {
          cacheLineTrack.poll()
          cacheLineTrack.offer(length)
        }
      }
      return
    }

    lastLog = System.currentTimeMillis()

    append(lineStr)
    trimLinesAtStart()
  }

  private fun append(chars: CharSequence?) {
    chars?.let {
      ThreadUtils.runOnUiThread {
        _binding?.editor?.append(chars)?.also {
          emptyStateViewModel.isEmpty.value = false
        }
      }
    }
  }

  private fun trimLinesAtStart() {
    if (isTrimming.get()) {
      // trimming is already in progress
      return
    }

    ThreadUtils.runOnUiThread {
      _binding?.editor?.text?.apply {
        if (lineCount <= TRIM_ON_LINE_COUNT) {
          isTrimming.set(false)
          return@apply
        }

        isTrimming.set(true)
        val lastLine = lineCount - MAX_LINE_COUNT
        log.debug("Deleting log text till line {}", lastLine)
        delete(0, 0, lastLine, getColumnCount(lastLine))
        isTrimming.set(false)
      }
    }
  }

  abstract fun isSimpleFormattingEnabled(): Boolean

  protected open fun logLine(level: Level, tag: String, message: String) {
    val line = LogLine.obtain(level, tag, message)
    appendLog(line)
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    val editor = this.binding.editor
    editor.props.autoIndent = false
    editor.isEditable = false
    editor.dividerWidth = 0f
    editor.isWordwrap = false
    editor.isUndoEnabled = false
    editor.typefaceLineNumber = jetbrainsMono()
    editor.setTextSize(12f)
    editor.typefaceText = jetbrainsMono()
    editor.isEnsurePosAnimEnabled = false
    editor.cursorAnimator = object : CursorAnimator {
      override fun markStartPos() {}
      override fun markEndPos() {}
      override fun start() {}
      override fun cancel() {}
      override fun isRunning(): Boolean {
        return false
      }

      override fun animatedX(): Float {
        return 0f
      }

      override fun animatedY(): Float {
        return 0f
      }

      override fun animatedLineHeight(): Float {
        return 0f
      }

      override fun animatedLineBottom(): Float {
        return 0f
      }
    }

    // Skip tree-sitter language setup during tests to avoid native library issues
    if (!isTestMode()) {
      IDEColorSchemeProvider.readSchemeAsync(context = requireContext(),
        coroutineScope = editor.editorScope, type = LogLanguage.TS_TYPE) { scheme ->
        val language = TreeSitterLanguageProvider.forType(LogLanguage.TS_TYPE, requireContext())
        if (language != null) {
          if (scheme is IDEColorScheme) {
            language.setupWith(scheme)
          }
          editor.applyTreeSitterLang(language, LogLanguage.TS_TYPE, scheme)
        }
      }
    }
  }


  override fun onDestroyView() {
    _binding?.editor?.release()
    logHandler.removeCallbacks(logRunnable)
    super.onDestroyView()
  }

  override fun getContent(): String {
    return this._binding?.editor?.text?.toString() ?: ""
  }

  override fun clearOutput() {
    _binding?.editor?.setText("")?.also {
      emptyStateViewModel.isEmpty.value = true
    }
  }
}



================================================
File: java/com/itsaky/androidide/fragments/output/NonEditableEditorFragment.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.output;

import android.os.Bundle;
import android.view.View;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.itsaky.androidide.R;
import com.itsaky.androidide.databinding.FragmentNonEditableEditorBinding;
import com.itsaky.androidide.editor.ui.IDEEditor;
import com.itsaky.androidide.fragments.EmptyStateFragment;
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE;
import com.itsaky.androidide.utils.TypefaceUtilsKt;
import io.github.rosemoe.sora.lang.EmptyLanguage;

public abstract class NonEditableEditorFragment extends
    EmptyStateFragment<FragmentNonEditableEditorBinding>
    implements ShareableOutputFragment {

  public NonEditableEditorFragment() {
    super(R.layout.fragment_non_editable_editor, FragmentNonEditableEditorBinding::bind);
  }

  @Override
  public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    getEmptyStateViewModel().getEmptyMessage().setValue(createEmptyStateMessage());
    final var editor = getBinding().getRoot();
    editor.setEditable(false);
    editor.setDividerWidth(0);
    editor.setEditorLanguage(new EmptyLanguage());
    editor.setWordwrap(false);
    editor.setUndoEnabled(false);
    editor.setTypefaceLineNumber(TypefaceUtilsKt.jetbrainsMono());
    editor.setTypefaceText(TypefaceUtilsKt.jetbrainsMono());
    editor.setTextSize(12);
    editor.setColorScheme(SchemeAndroidIDE.newInstance(requireContext()));
  }

  private CharSequence createEmptyStateMessage() {
    return null;
  }

  @NonNull
  @Override
  public String getContent() {
    final var editor = getEditor();
    if (editor == null) {
      return "";
    }

    return editor.getText().toString();
  }

  @Nullable
  public IDEEditor getEditor() {
    final var binding = get_binding();
    if (binding == null) {
      return null;
    }
    return binding.editor;
  }

  @NonNull
  @Override
  public String getFilename() {
    return "build_output";
  }

  @Override
  public void clearOutput() {
    final var editor = getEditor();
    if (editor == null) {
      return;
    }

    // Editing CodeEditor's content is a synchronized operation
    editor.getText().delete(0, editor.getText().length());
    getEmptyStateViewModel().isEmpty().setValue(true);
  }
}



================================================
File: java/com/itsaky/androidide/fragments/output/ShareableOutputFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.output

/**
 * Any fragment that allows to share it's content.
 *
 * @author Akash Yadav
 */
interface ShareableOutputFragment {

  /** Get the content of the fragment. */
  fun getContent(): String

  /** Get the name of the file to which the output will be written. */
  fun getFilename(): String

  /** Clear the output of this fragment. */
  fun clearOutput()
}



================================================
File: java/com/itsaky/androidide/fragments/sheets/BaseBottomSheetFragment.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.fragments.sheets;

import android.app.Dialog;
import android.os.Bundle;
import androidx.annotation.NonNull;
import com.google.android.material.bottomsheet.BottomSheetDialogFragment;

public abstract class BaseBottomSheetFragment extends BottomSheetDialogFragment {

  protected Dialog mDialog;

  @NonNull
  @Override
  public Dialog onCreateDialog(Bundle savedInstanceState) {
    mDialog = super.onCreateDialog(savedInstanceState);
    return mDialog;
  }

  public boolean isShowing() {
    return mDialog != null && mDialog.isShowing();
  }
}



================================================
File: java/com/itsaky/androidide/fragments/sheets/OptionsListFragment.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

package com.itsaky.androidide.fragments.sheets;

import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.blankj.utilcode.util.SizeUtils;
import com.itsaky.androidide.adapters.OptionsSheetAdapter;
import com.itsaky.androidide.events.FileContextMenuItemClickEvent;
import com.itsaky.androidide.models.SheetOption;
import java.util.ArrayList;
import java.util.List;
import org.greenrobot.eventbus.EventBus;

public class OptionsListFragment extends BaseBottomSheetFragment {

  private final List<SheetOption> mOptions = new ArrayList<>();
  protected boolean dismissOnItemClick = true;
  private RecyclerView mList;

  @Nullable
  @Override
  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                           @Nullable Bundle savedInstanceState
  ) {
    final var dp8 = SizeUtils.dp2px(8);
    final var dp16 = dp8 * 2;
    mList = new RecyclerView(requireContext());
    mList.setLayoutParams(new LayoutParams(-1, -1));
    mList.setPaddingRelative(dp16, dp8, dp16, dp8);
    return mList;
  }

  @Override
  public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    mList.setLayoutManager(new LinearLayoutManager(getContext()));
    mList.setAdapter(new OptionsSheetAdapter(mOptions, option -> {
      if (dismissOnItemClick) {
        dismiss();
      }
      final var event = new FileContextMenuItemClickEvent(option);
      event.put(Context.class, requireContext());
      EventBus.getDefault().post(event);
    }));
  }

  public void addOption(SheetOption option) {
    if (!mOptions.contains(option)) {
      mOptions.add(option);
    }
  }

  public OptionsListFragment removeOption(int optionIndex) {
    return removeOption(mOptions.get(optionIndex));
  }

  public OptionsListFragment removeOption(SheetOption option) {
    mOptions.remove(option);
    return this;
  }

  public OptionsListFragment setDismissOnItemClick(boolean dissmiss) {
    this.dismissOnItemClick = dissmiss;
    return this;
  }
}



================================================
File: java/com/itsaky/androidide/fragments/sheets/ProgressSheet.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.sheets;

import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.constraintlayout.widget.ConstraintLayout;
import androidx.constraintlayout.widget.ConstraintLayout.LayoutParams;
import com.itsaky.androidide.databinding.LayoutProgressSheetBinding;

public class ProgressSheet extends BaseBottomSheetFragment {

  private LayoutProgressSheetBinding binding;
  private String message = "";
  private String subMessage = "";
  private boolean subMessageEnabled = false;

  @Override
  public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);

    binding.message.setText(message);

    final var params = (ConstraintLayout.LayoutParams) binding.message.getLayoutParams();
    if (subMessageEnabled) {
      binding.subMessage.setText(subMessage);
      binding.subMessage.setVisibility(View.VISIBLE);
      params.bottomToBottom = View.NO_ID;
    } else {
      binding.subMessage.setVisibility(View.GONE);
      params.bottomToBottom = LayoutParams.PARENT_ID;
    }
  }

  @Nullable
  @Override
  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                           @Nullable Bundle savedInstanceState
  ) {
    binding = LayoutProgressSheetBinding.inflate(LayoutInflater.from(getContext()));
    return binding.getRoot();
  }

  public void setSubMessageEnabled(boolean enabled) {
    this.subMessageEnabled = enabled;
  }

  public void setSubMessage(String msg) {
    this.subMessage = msg;
    if (isShowing()) {
      binding.subMessage.setText(msg);
    }
  }

  public ProgressSheet setMessage(String message) {
    this.message = message;
    if (isShowing()) {
      binding.message.setText(message);
    }

    return this;
  }

  public ProgressSheet setProgressDrawable(Drawable drawable) {
    if (isShowing()) {
      binding.progress.setIndeterminateDrawable(drawable);
    }
    return this;
  }

  @Override
  public void dismiss() {
    if (isShowing()) {
      super.dismiss();
    }
  }
}



================================================
File: java/com/itsaky/androidide/fragments/sidebar/BuildVariantsFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.sidebar

import android.os.Bundle
import android.view.View
import androidx.fragment.app.viewModels
import androidx.recyclerview.widget.DividerItemDecoration
import com.itsaky.androidide.activities.editor.ProjectHandlerActivity
import com.itsaky.androidide.adapters.BuildVariantsAdapter
import com.itsaky.androidide.databinding.FragmentBuildVariantsBinding
import com.itsaky.androidide.fragments.EmptyStateFragment
import com.itsaky.androidide.tooling.api.models.BuildVariantInfo
import com.itsaky.androidide.viewmodel.BuildVariantsViewModel
import com.itsaky.androidide.viewmodel.EditorViewModel

/**
 * A fragment to show the list of Android modules and its build variants.
 *
 * @author Akash Yadav
 */
class BuildVariantsFragment :
  EmptyStateFragment<FragmentBuildVariantsBinding>(FragmentBuildVariantsBinding::inflate) {

  private val variantsViewModel by viewModels<BuildVariantsViewModel>(
    ownerProducer = { requireActivity() }
  )

  private val editorViewModel by viewModels<EditorViewModel>(
    ownerProducer = { requireActivity() }
  )

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    variantsViewModel._buildVariants.observe(viewLifecycleOwner) {
      populateRecyclerView()
      updateButtonStates(variantsViewModel.updatedBuildVariants)
    }

    // observe values and update the button states accordingly
    variantsViewModel._updatedBuildVariants.observe(viewLifecycleOwner) { updatedVariants ->
      updateButtonStates(updatedVariants)
    }

    editorViewModel._isBuildInProgress.observe(viewLifecycleOwner) {
      updateButtonStates(variantsViewModel.updatedBuildVariants)
    }

    editorViewModel._isInitializing.observe(viewLifecycleOwner) {
      updateButtonStates(variantsViewModel.updatedBuildVariants)
    }

    binding.apply.setOnClickListener {
      (activity as? ProjectHandlerActivity?)?.initializeProject()
    }

    binding.discard.setOnClickListener {
      variantsViewModel.resetUpdatedSelections()
      populateRecyclerView()
    }

    binding.variantsList.addItemDecoration(
      DividerItemDecoration(requireContext(), DividerItemDecoration.VERTICAL)
    )

    populateRecyclerView()
  }

  private fun updateButtonStates(
    updatedVariants: MutableMap<String, BuildVariantInfo>?
  ) {
    _binding?.apply {
      // enable buttons only if any of the project's selected build variant was changed
      // also, changes can only if be applied if no build is in progress
      val isBuilding = editorViewModel.let { it.isBuildInProgress || it.isInitializing }
      val isEnabled = updatedVariants?.isNotEmpty() == true && !isBuilding

      apply.isEnabled = isEnabled
      discard.isEnabled = isEnabled
    }
  }

  private fun populateRecyclerView() {
    _binding?.variantsList?.apply {
      this.adapter = BuildVariantsAdapter(variantsViewModel,
        variantsViewModel.buildVariants.values.toList())
      checkIsEmpty()
    }
  }

  private fun checkIsEmpty() {
    emptyStateViewModel.isEmpty.value = _binding?.variantsList?.adapter?.itemCount == 0
  }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/EditorSidebarFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.sidebar

import android.os.Bundle
import android.util.Log
import android.view.View
import android.view.ViewGroup.MarginLayoutParams
import androidx.core.graphics.Insets
import androidx.core.view.marginBottom
import androidx.core.view.marginTop
import androidx.core.view.updateLayoutParams
import androidx.core.view.updateMarginsRelative
import androidx.core.view.updatePadding
import androidx.lifecycle.lifecycleScope
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.databinding.FragmentEditorSidebarBinding
import com.itsaky.androidide.fragments.FragmentWithBinding
import com.itsaky.androidide.utils.EditorSidebarActions
import com.itsaky.androidide.utils.TooltipUtils
import kotlinx.coroutines.launch

/**
 * Fragment for showing the default items in the editor activity's sidebar.
 *
 * @author Akash Yadav
 */
class EditorSidebarFragment : FragmentWithBinding<FragmentEditorSidebarBinding>(
  FragmentEditorSidebarBinding::inflate
) {

  internal fun onApplyWindowInsets(insets: Insets) {
    _binding?.apply {
      title.updateLayoutParams<MarginLayoutParams> {
        updateMarginsRelative(
          top = title.marginTop + insets.top,
        )
      }
      fragmentContainer.updateLayoutParams<MarginLayoutParams> {
        updateMarginsRelative(
          bottom = fragmentContainer.marginBottom + insets.bottom,
        )
      }
      navigation.updatePadding(
        top = navigation.paddingTop + insets.top,
        bottom = navigation.paddingBottom + insets.bottom,
        left = navigation.paddingLeft + insets.left,
      )
    }
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    EditorSidebarActions.setup(this)
  }

  fun setupTooltip(view: View, tooltipCategory: String, tooltipTag: String) {
    (requireActivity() as? EditorHandlerActivity)?.let { activity ->
      view.setOnLongClickListener { view ->
        activity.lifecycleScope.launch {
          try {
            val tooltipData = activity.getTooltipData(tooltipCategory, tooltipTag)
            tooltipData?.let {
              TooltipUtils.showIDETooltip(
                context = view.context,
                anchorView = view,
                level = 0,
                tooltipItem = it
              )
            }
          } catch (e: Exception) {
            Log.e("Tooltip", "Error loading tooltip for $tooltipTag", e)
          }
        }
        true
      }
    }
  }

  /**
   * Get the (nullable) binding object for this fragment.
   */
  internal fun getBinding() = _binding
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/FileTreeFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.fragments.sidebar

import android.content.Context
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.WindowInsetsCompat.Type.statusBars
import androidx.core.view.updatePadding
import androidx.fragment.app.viewModels
import androidx.transition.ChangeBounds
import androidx.transition.TransitionManager
import com.blankj.utilcode.util.SizeUtils
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.itsaky.androidide.adapters.viewholders.FileTreeViewHolder
import com.itsaky.androidide.databinding.LayoutEditorFileTreeBinding
import com.itsaky.androidide.eventbus.events.filetree.FileClickEvent
import com.itsaky.androidide.eventbus.events.filetree.FileLongClickEvent
import com.itsaky.androidide.events.CollapseTreeNodeRequestEvent
import com.itsaky.androidide.events.ExpandTreeNodeRequestEvent
import com.itsaky.androidide.events.ListProjectFilesRequestEvent
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.resources.R.drawable
import com.itsaky.androidide.tasks.TaskExecutor.executeAsync
import com.itsaky.androidide.tasks.callables.FileTreeCallable
import com.itsaky.androidide.tasks.callables.FileTreeCallable.SortFileName
import com.itsaky.androidide.tasks.callables.FileTreeCallable.SortFolder
import com.itsaky.androidide.utils.doOnApplyWindowInsets
import com.itsaky.androidide.viewmodel.FileTreeViewModel
import com.unnamed.b.atv.model.TreeNode
import com.unnamed.b.atv.model.TreeNode.TreeNodeClickListener
import com.unnamed.b.atv.model.TreeNode.TreeNodeLongClickListener
import com.unnamed.b.atv.view.AndroidTreeView
import org.greenrobot.eventbus.EventBus
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode.MAIN
import java.io.File
import java.util.Arrays

class FileTreeFragment : BottomSheetDialogFragment(), TreeNodeClickListener,
  TreeNodeLongClickListener {

  private var binding: LayoutEditorFileTreeBinding? = null
  private var fileTreeView: AndroidTreeView? = null

  private val viewModel by viewModels<FileTreeViewModel>(ownerProducer = { requireActivity() })

  override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View {
    if (!EventBus.getDefault().isRegistered(this)) {
      EventBus.getDefault().register(this)
    }

    binding = LayoutEditorFileTreeBinding.inflate(inflater, container, false)
    binding?.root?.doOnApplyWindowInsets { view, insets, _, _ ->
      insets.getInsets(statusBars()).apply { view.updatePadding(top = top + SizeUtils.dp2px(8f)) }
    }
    return binding!!.root
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    listProjectFiles()
  }

  override fun onDestroyView() {
    super.onDestroyView()
    EventBus.getDefault().unregister(this)

    saveTreeState()

    binding = null
    fileTreeView = null
  }

  fun saveTreeState() {
    viewModel.saveState(fileTreeView)
  }

  override fun onClick(node: TreeNode, p2: Any) {
    val file = p2 as File
    if (!file.exists()) {
      return
    }
    if (file.isDirectory) {
      if (node.isExpanded) {
        collapseNode(node)
      } else {
        setLoading(node)
        listNode(node) { expandNode(node) }
      }
    }
    val event = FileClickEvent(file)
    event.put(Context::class.java, requireContext())
    EventBus.getDefault().post(event)
  }

  private fun updateChevron(node: TreeNode) {
    if (node.viewHolder is FileTreeViewHolder) {
      (node.viewHolder as FileTreeViewHolder).updateChevron(node.isExpanded)
    }
  }

  private fun expandNode(node: TreeNode, animate: Boolean = true) {
    if (fileTreeView == null) {
      return
    }
    if (animate) {
      TransitionManager.beginDelayedTransition(binding!!.root, ChangeBounds())
    }
    fileTreeView!!.expandNode(node)
    updateChevron(node)
  }

  private fun collapseNode(node: TreeNode, animate: Boolean = true, includeSubnodes: Boolean = false) {
    if (fileTreeView == null) {
      return
    }
    if (animate) {
      TransitionManager.beginDelayedTransition(binding!!.root, ChangeBounds())
    }
    fileTreeView!!.collapseNode(node, includeSubnodes)
    updateChevron(node)
  }

  private fun setLoading(node: TreeNode) {
    if (node.viewHolder is FileTreeViewHolder) {
      (node.viewHolder as FileTreeViewHolder).setLoading(true)
    }
  }

  private fun listNode(node: TreeNode, whenDone: Runnable) {
    node.children.clear()
    node.isExpanded = false
    executeAsync({
      listFilesForNode(node.value.listFiles() ?: return@executeAsync null, node)
      var temp = node
      while (temp.size() == 1) {
        temp = temp.childAt(0)
        if (!temp.value.isDirectory) {
          break
        }
        listFilesForNode(temp.value.listFiles() ?: continue, temp)
        temp.isExpanded = true
      }
      null
    }) {
      whenDone.run()
    }
  }

  private fun listFilesForNode(files: Array<File>, parent: TreeNode) {
    Arrays.sort(files, SortFileName())
    Arrays.sort(files, SortFolder())
    for (file in files) {
      val node = TreeNode(file)
      node.viewHolder = FileTreeViewHolder(context)
      parent.addChild(node, false)
    }
  }

  override fun onLongClick(node: TreeNode, value: Any): Boolean {
    val event = FileLongClickEvent((value as File))
    event.put(Context::class.java, requireContext())
    event.put(TreeNode::class.java, node)
    EventBus.getDefault().post(event)
    return true
  }

  @Suppress("unused", "UNUSED_PARAMETER")
  @Subscribe(threadMode = MAIN)
  fun onGetListFilesRequested(event: ListProjectFilesRequestEvent?) {
    if (!isVisible || context == null) {
      return
    }
    listProjectFiles()
  }

  @Suppress("unused")
  @Subscribe(threadMode = MAIN)
  fun onGetExpandTreeNodeRequest(event: ExpandTreeNodeRequestEvent) {
    if (!isVisible || context == null) {
      return
    } else {
      event.node
    }
    expandNode(event.node)
  }

  @Suppress("unused")
  @Subscribe(threadMode = MAIN)
  fun onGetCollapseTreeNodeRequest(event: CollapseTreeNodeRequestEvent) {
    if (!isVisible || context == null) {
      return
    } else {
      event.node
    }
    collapseNode(event.node, event.includeSubnodes)

    setLoading(event.node)
    listNode(event.node) { expandNode(event.node) }
  }

  fun listProjectFiles() {
    if (binding == null) {
      // Fragment has been destroyed
      return
    }
    val projectDirPath = IProjectManager.getInstance().projectDirPath
    val projectDir = File(projectDirPath)
    val rootNode = TreeNode(File(""))
    rootNode.viewHolder = FileTreeViewHolder(requireContext())

    val projectRoot = TreeNode.root(projectDir)
    projectRoot.viewHolder = FileTreeViewHolder(context)
    rootNode.addChild(projectRoot, false)

    binding!!.horizontalCroll.visibility = View.GONE
    binding!!.horizontalCroll.visibility = View.VISIBLE
    executeAsync(FileTreeCallable(context, projectRoot, projectDir)) {
      if (binding == null) {
        // Fragment has been destroyed
        return@executeAsync
      }
      binding!!.horizontalCroll.visibility = View.VISIBLE
      binding!!.loading.visibility = View.GONE
      val tree = createTreeView(rootNode)
      if (tree != null) {
        tree.setUseAutoToggle(false)
        tree.setDefaultNodeClickListener(this@FileTreeFragment)
        tree.setDefaultNodeLongClickListener(this@FileTreeFragment)
        binding!!.horizontalCroll.removeAllViews()
        val view = tree.view
        binding!!.horizontalCroll.addView(view)
        view.post { tryRestoreState(rootNode) }
      }
    }
  }

  private fun createTreeView(node: TreeNode): AndroidTreeView? {
    return if (context == null) {
      null
    } else AndroidTreeView(context, node, drawable.bg_ripple).also { fileTreeView = it }
  }

  private fun tryRestoreState(rootNode: TreeNode, state: String? = viewModel.savedState) {
    if (!TextUtils.isEmpty(state) && fileTreeView != null) {
      fileTreeView!!.collapseAll()
      val openNodes =
        state!!.split(AndroidTreeView.NODES_PATH_SEPARATOR.toRegex()).dropLastWhile { it.isEmpty() }
      restoreNodeState(rootNode, HashSet(openNodes))
    }

    if (rootNode.children.isNotEmpty()) {
      rootNode.childAt(0)?.let { projectRoot -> expandNode(projectRoot, false) }
    }
  }

  private fun restoreNodeState(root: TreeNode, openNodes: Set<String>) {
    val children = root.children
    var i = 0
    val childrenSize = children.size
    while (i < childrenSize) {
      val node = children[i]
      if (openNodes.contains(node.path)) {
        listNode(node) {
          expandNode(node, false)
          restoreNodeState(node, openNodes)
        }
      }
      i++
    }
  }

  companion object {

    // Should be same as defined in layout/activity_layouteditor.xml
    const val TAG = "editor.fileTree"

    @JvmStatic
    fun newInstance(): FileTreeFragment {
      return FileTreeFragment()
    }
  }
}



================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitCommitDetailFragment.kt
================================================
package com.itsaky.androidide.fragments.sidebar

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.navArgs
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.FragmentGitCommitDetailBinding
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class GitCommitDetailFragment : Fragment(R.layout.fragment_git_commit_detail) {

    private var _binding: FragmentGitCommitDetailBinding? = null
    private val binding get() = _binding!!
    private val args: GitCommitDetailFragmentArgs by navArgs()
    private var originalRemoteName: String? = null

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        _binding = FragmentGitCommitDetailBinding.bind(view)

        originalRemoteName = args.commitHash

        if (originalRemoteName != null) {
            loadRemoteDetails(originalRemoteName!!)
        } else {
//            binding.btnDeleteRemote.isVisible = false
        }

//        binding.btnSaveRemote.setOnClickListener { saveRemote() }
//        binding.btnDeleteRemote.setOnClickListener { /* Add confirmation dialog and delete logic */ }
    }

    private fun loadRemoteDetails(remoteName: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            // ... (Fetch remote details and populate UI)
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitCommitFragment.kt
================================================
// In: com/itsaky/androidide/fragments/sidebar/GitCommitFragment.kt

package com.itsaky.androidide.fragments.sidebar

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.LinearLayoutManager
import com.itsaky.androidide.databinding.FragmentGitCommitBinding
import com.itsaky.androidide.projects.ProjectManagerImpl
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.eclipse.jgit.api.Git

class GitCommitFragment : Fragment() {

    private var _binding: FragmentGitCommitBinding? = null
    private val binding get() = _binding!!

    private lateinit var git: Git
    private lateinit var gitStatusAdapter: GitStatusAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentGitCommitBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val projectDir = ProjectManagerImpl.getInstance().projectDir
        if (projectDir == null) {
            Toast.makeText(requireContext(), "No project open", Toast.LENGTH_SHORT).show()
            return
        }

        // Initialize the Git instance
        git = Git.open(projectDir)

        // Load the changed files into the RecyclerView
        loadGitStatus()

        // **MODIFIED:** The commit logic now lives here
        binding.btnCommit.setOnClickListener {
            val stagedFiles = gitStatusAdapter.getStagedFiles()
            val message = binding.commitMessageInput.text.toString()

            if (message.isBlank()) {
                Toast.makeText(
                    requireContext(),
                    "Commit message cannot be empty.",
                    Toast.LENGTH_SHORT
                ).show()
                return@setOnClickListener
            }
            if (stagedFiles.isEmpty()) {
                Toast.makeText(requireContext(), "No files selected to commit.", Toast.LENGTH_SHORT)
                    .show()
                return@setOnClickListener
            }

            performCommit(stagedFiles, message)
        }
    }

    private fun loadGitStatus() {
        lifecycleScope.launch(Dispatchers.IO) {
            val status = git.status().call()
            val fileList = mutableListOf<GitFileStatus>()

            // Populate the list with all changed files
            status.untracked.forEach { fileList.add(GitFileStatus(it, "New")) }
            status.added.forEach { fileList.add(GitFileStatus(it, "Added")) }
            status.modified.forEach { fileList.add(GitFileStatus(it, "Modified")) }
            status.changed.forEach { fileList.add(GitFileStatus(it, "Changed")) }
            status.removed.forEach { fileList.add(GitFileStatus(it, "Deleted")) }

            // Update the UI on the main thread
            withContext(Dispatchers.Main) {
                gitStatusAdapter = GitStatusAdapter(fileList)
                binding.commitFilesRecyclerView.apply {
                    adapter = gitStatusAdapter
                    layoutManager = LinearLayoutManager(requireContext())
                }
            }
        }
    }

    private fun performCommit(filesToCommit: List<String>, message: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                // Add each selected file to the index
                val addCommand = git.add()
                filesToCommit.forEach { addCommand.addFilepattern(it) }
                addCommand.call()

                // Now, commit the files that were just added
                git.commit().setMessage(message).call()

                withContext(Dispatchers.Main) {
                    Toast.makeText(requireContext(), "Commit successful!", Toast.LENGTH_SHORT)
                        .show()
                    findNavController().popBackStack()
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        requireContext(),
                        "Commit failed: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitEditRemoteFragment.kt
================================================
package com.itsaky.androidide.fragments.sidebar

import android.os.Bundle
import android.view.View
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.google.android.material.snackbar.Snackbar
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.FragmentGitEditRemoteBinding
import com.itsaky.androidide.projects.ProjectManagerImpl
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.transport.URIish

class GitEditRemoteFragment : Fragment(R.layout.fragment_git_edit_remote) {

    private var _binding: FragmentGitEditRemoteBinding? = null
    private val binding get() = _binding!!
    private val args: GitEditRemoteFragmentArgs by navArgs()
    private var originalRemoteName: String? = null

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        _binding = FragmentGitEditRemoteBinding.bind(view)

        originalRemoteName = args.remoteName

        if (originalRemoteName != null) {
            loadRemoteDetails(originalRemoteName!!)
        } else {
            binding.btnDeleteRemote.isVisible = false
        }

        binding.btnSaveRemote.setOnClickListener { saveRemote() }
        binding.btnDeleteRemote.setOnClickListener { /* Add confirmation dialog and delete logic */ }
    }

    private fun loadRemoteDetails(remoteName: String) {
        lifecycleScope.launch(Dispatchers.IO) {
            // ... (Fetch remote details and populate UI)
        }
    }

    private fun saveRemote() {
        val name = binding.remoteNameInput.text.toString().trim()
        val url = binding.remoteUrlInput.text.toString().trim()

        if (name.isEmpty() || url.isEmpty()) {
            Snackbar.make(binding.root, "Name and URL cannot be empty.", Snackbar.LENGTH_SHORT)
                .show()
            return
        }

        binding.loadingProgressBar.isVisible = true
        binding.btnSaveRemote.isEnabled = false

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val projectDir = ProjectManagerImpl.getInstance().projectDir
                    ?: throw IllegalStateException("Project not open")
                val git = Git.open(projectDir)

                // If editing, remove the old one first
                if (originalRemoteName != null) {
                    git.remoteRemove().setRemoteName(originalRemoteName).call()
                }

                // Add the new or updated remote
                git.remoteAdd().setName(name).setUri(URIish().setRawPath(url)).call()

                // If checked, verify by listing remote heads
                if (binding.fetchCheckBox.isChecked) {
                    git.lsRemote().setRemote(name).setHeads(true).call()
                }

                withContext(Dispatchers.Main) {
                    findNavController().popBackStack()
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    binding.loadingProgressBar.isVisible = false
                    binding.btnSaveRemote.isEnabled = true
                    val message = e.cause?.message ?: e.message
                    Snackbar.make(binding.root, "Error: $message", Snackbar.LENGTH_LONG).show()
                }
            }
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitFileStatus.kt
================================================
package com.itsaky.androidide.fragments.sidebar

data class GitFileStatus(
    val filePath: String,
    val status: String,
    var isChecked: Boolean = true // Default to checked
)


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitFragment.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.fragments.sidebar

import android.os.Bundle
import android.view.View
import androidx.core.view.isVisible
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.FragmentGitBinding
import com.itsaky.androidide.fragments.EmptyStateFragment
import com.itsaky.androidide.git.GitInitTask
import com.itsaky.androidide.git.GitPullTask
import com.itsaky.androidide.git.GitPushTask
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.viewmodel.GitViewModel
import java.io.File

class GitFragment :
    EmptyStateFragment<FragmentGitBinding>(FragmentGitBinding::inflate) {

    private val gitViewModel by viewModels<GitViewModel>(
        ownerProducer = { requireActivity() }
    )

    override fun onResume() {
        super.onResume()
        // Update the UI every time the activity is shown
        updateGitButtonVisibility()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        emptyStateViewModel.emptyMessage.value = "No git actions yet"
        emptyStateViewModel.isEmpty.value = false

        binding.btnManageRemotes.setOnClickListener {
            findNavController().navigate(R.id.action_gitFragment_to_gitRemotesListFragment)
        }
        // Set up the Commit button
        binding.btnGitCommit.setOnClickListener {
            // Use the NavController to navigate via the action defined in the graph
            findNavController().navigate(R.id.action_gitFragment_to_gitCommitFragment)
        }

        // Set up the Push button
        binding.btnGitPush.setOnClickListener {
            // This runs the push task and shows progress via GitProgressMonitor.
            GitPushTask.push(requireContext())
        }

        // Set up the Pull button
        binding.btnGitPull.setOnClickListener {
            GitPullTask.pull(requireContext())
        }
        binding.btnGitInit.setOnClickListener {
            GitInitTask.init(requireContext())
            // After attempting to init, refresh the button visibility
            updateGitButtonVisibility()
        }

        binding.btnGitLog.setOnClickListener {
            findNavController().navigate(R.id.action_gitFragment_to_gitCommitListFragment)
        }
    }

    private fun updateGitButtonVisibility() {
        val projectDir = ProjectManagerImpl.getInstance().projectDir

        val gitDir = File(projectDir, ".git")
        val isGitRepo = gitDir.exists()

        // Show "Init" only if it's NOT a git repo
        binding.btnGitInit.isVisible = !isGitRepo

        // Show other Git actions only if it IS a git repo
        binding.btnGitCommit.isVisible = isGitRepo
        binding.btnGitPush.isVisible = isGitRepo
        binding.btnGitPull.isVisible = isGitRepo
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitFragmentContainer.kt
================================================
package com.itsaky.androidide.fragments.sidebar

import android.os.Bundle
import android.view.View
import com.itsaky.androidide.databinding.FragmentGitContainerBinding
import com.itsaky.androidide.fragments.EmptyStateFragment

class GitFragmentContainer :
    EmptyStateFragment<FragmentGitContainerBinding>(FragmentGitContainerBinding::inflate) {

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        emptyStateViewModel.emptyMessage.value = "No git actions yet"
        emptyStateViewModel.isEmpty.value = false

    }

}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitGraphItemDecoration.kt
================================================
package com.itsaky.androidide.fragments.sidebar

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.view.View
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.R

class GitGraphItemDecoration : RecyclerView.ItemDecoration() {

    private val paint = Paint().apply {
        color = Color.GRAY
        strokeWidth = 4f
        isAntiAlias = true
    }

    private val dotRadius = 10f

    override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
        super.onDraw(c, parent, state)

        val layoutManager = parent.layoutManager ?: return

        for (i in 0 until parent.childCount) {
            val child = parent.getChildAt(i)
            val graphSpace = child.findViewById<View>(R.id.graph_space)

            val cx = graphSpace.left + (graphSpace.width / 2f)
            val cy = child.top + (child.height / 2f)

            // Draw a dot for the commit
            c.drawCircle(cx, cy, dotRadius, paint)

            // VERY SIMPLIFIED: Draw a line to the previous item
            if (i > 0) {
                val prevChild = parent.getChildAt(i - 1)
                val prevCy = prevChild.top + (prevChild.height / 2f)
                c.drawLine(cx, cy, cx, prevCy, paint)
            }
        }
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitHistoryAdapter.kt
================================================
package com.itsaky.androidide.fragments.sidebar

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.databinding.ListItemCommitBinding
import org.eclipse.jgit.revwalk.RevCommit
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

class GitHistoryAdapter(
    private val commits: List<RevCommit>,
    private val onCommitClick: (RevCommit) -> Unit
) : RecyclerView.Adapter<GitHistoryAdapter.ViewHolder>() {

    class ViewHolder(val binding: ListItemCommitBinding) : RecyclerView.ViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding =
            ListItemCommitBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val commit = commits[position]
        val author = commit.authorIdent
        val date = Date(author.getWhen().time)
        val dateFormat = SimpleDateFormat("MMM dd, yyyy", Locale.getDefault())

        holder.binding.commitMessageTextView.text = commit.shortMessage
        holder.binding.commitAuthorTextView.text = author.name
        holder.binding.commitDateTextView.text = dateFormat.format(date)
        holder.itemView.setOnClickListener { onCommitClick(commit) }
    }

    override fun getItemCount() = commits.size
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitHistoryFragment.kt
================================================
package com.itsaky.androidide.fragments.sidebar;

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.FragmentGitCommitListBinding
import com.itsaky.androidide.projects.ProjectManagerImpl
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.revwalk.RevCommit

class GitHistoryFragment : Fragment(R.layout.fragment_git_commit_list) {
    // Basic implementation using ViewBinding
    private var _binding: FragmentGitCommitListBinding? = null
    private val binding get() = _binding!!

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        _binding = FragmentGitCommitListBinding.bind(view)

        loadCommits()

    }

    private fun loadCommits() {
        lifecycleScope.launch(Dispatchers.IO) {
            val projectDir = ProjectManagerImpl.getInstance().projectDir
            val git = Git.open(projectDir)
            val commits = git.log().all().call().toList()

            withContext(Dispatchers.Main) {
                setupRecyclerView(commits)
            }
        }
    }

    private fun setupRecyclerView(remotes: List<RevCommit>) {
        val adapter = GitHistoryAdapter(remotes) { remote ->
//            val action =
//                GitRemotesListFragmentDirections.actionGitRemotesListFragmentToGitEditRemoteFragment(
//                    remote.name
//                )
//            findNavController().navigate(action)
        }
        binding.commitsRecyclerView.adapter = adapter
        binding.commitsRecyclerView.layoutManager = LinearLayoutManager(requireContext())
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitRemote.kt
================================================
package com.itsaky.androidide.fragments.sidebar

data class GitRemote(
    val name: String,
    val url: String
)


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitRemotesListFragment.kt
================================================
package com.itsaky.androidide.fragments.sidebar;

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.FragmentGitRemotesListBinding
import com.itsaky.androidide.projects.ProjectManagerImpl
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.eclipse.jgit.api.Git

class GitRemotesListFragment : Fragment(R.layout.fragment_git_remotes_list) {
    // Basic implementation using ViewBinding
    private var _binding: FragmentGitRemotesListBinding? = null
    private val binding get() = _binding!!

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        _binding = FragmentGitRemotesListBinding.bind(view)

        loadRemotes()

        binding.fabAddRemote.setOnClickListener {
            findNavController().navigate(R.id.action_gitRemotesListFragment_to_gitEditRemoteFragment)
        }
    }

    private fun loadRemotes() {
        lifecycleScope.launch(Dispatchers.IO) {
            val projectDir = ProjectManagerImpl.getInstance().projectDir ?: return@launch
            val git = Git.open(projectDir)
            val remotes = git.remoteList().call()
                .map { GitRemote(it.name, it.urIs.firstOrNull()?.toString() ?: "") }

            withContext(Dispatchers.Main) {
                setupRecyclerView(remotes.toMutableList())
            }
        }
    }

    private fun setupRecyclerView(remotes: MutableList<GitRemote>) {
        val adapter = RemotesAdapter(remotes) { remote ->
            val action =
                GitRemotesListFragmentDirections.actionGitRemotesListFragmentToGitEditRemoteFragment(
                    remote.name
                )
            findNavController().navigate(action)
        }
        binding.remotesRecyclerView.adapter = adapter
        binding.remotesRecyclerView.layoutManager = LinearLayoutManager(requireContext())

        // Setup swipe to delete
        val itemTouchHelper =
            ItemTouchHelper(object : ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.LEFT) {
                override fun onMove(
                    recyclerView: RecyclerView,
                    viewHolder: RecyclerView.ViewHolder,
                    target: RecyclerView.ViewHolder
                ): Boolean = false

                override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
                    val position = viewHolder.adapterPosition
                    val remoteToDelete = adapter.getRemoteAt(position)
                    deleteRemote(remoteToDelete, position)
                }
            })
        itemTouchHelper.attachToRecyclerView(binding.remotesRecyclerView)
    }

    private fun deleteRemote(remote: GitRemote, position: Int) {
        lifecycleScope.launch(Dispatchers.IO) {
            val projectDir = ProjectManagerImpl.getInstance().projectDir ?: return@launch
            val git = Git.open(projectDir)
            git.remoteRemove().setRemoteName(remote.name).call()
            withContext(Dispatchers.Main) {
                (binding.remotesRecyclerView.adapter as RemotesAdapter).removeAt(position)
                Snackbar.make(binding.root, "Deleted remote: ${remote.name}", Snackbar.LENGTH_SHORT)
                    .show()
            }
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/GitStatusAdapter.kt
================================================
package com.itsaky.androidide.fragments.sidebar

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.databinding.ListItemChangedFileBinding

class GitStatusAdapter(private val files: List<GitFileStatus>) :
    RecyclerView.Adapter<GitStatusAdapter.ViewHolder>() {

    class ViewHolder(val binding: ListItemChangedFileBinding) :
        RecyclerView.ViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = ListItemChangedFileBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val fileStatus = files[position]
        holder.binding.filePathTextView.text = fileStatus.filePath
        holder.binding.fileStatusTextView.text = fileStatus.status

        // Set checkbox state without triggering the listener
        holder.binding.fileCheckbox.setOnCheckedChangeListener(null)
        holder.binding.fileCheckbox.isChecked = fileStatus.isChecked

        // Listen for user clicks on the checkbox
        holder.binding.fileCheckbox.setOnCheckedChangeListener { _, isChecked ->
            fileStatus.isChecked = isChecked
        }
    }

    override fun getItemCount() = files.size

    // Helper function to get the list of files the user has checked
    fun getStagedFiles(): List<String> {
        return files.filter { it.isChecked }.map { it.filePath }
    }
}


================================================
File: java/com/itsaky/androidide/fragments/sidebar/RemotesAdapter.kt
================================================
package com.itsaky.androidide.fragments.sidebar

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.databinding.ListItemRemoteBinding

class RemotesAdapter(
    private val remotes: MutableList<GitRemote>,
    private val onRemoteClick: (GitRemote) -> Unit
) : RecyclerView.Adapter<RemotesAdapter.ViewHolder>() {

    class ViewHolder(val binding: ListItemRemoteBinding) : RecyclerView.ViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding =
            ListItemRemoteBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val remote = remotes[position]
        holder.binding.remoteNameTextView.text = remote.name
        holder.binding.remoteUrlTextView.text = remote.url
        holder.itemView.setOnClickListener { onRemoteClick(remote) }
    }

    override fun getItemCount() = remotes.size

    fun getRemoteAt(position: Int): GitRemote = remotes[position]

    fun removeAt(position: Int) {
        remotes.removeAt(position)
        notifyItemRemoved(position)
    }
}


================================================
File: java/com/itsaky/androidide/git/GitCommitTask.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.git

import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Typeface
import android.net.Uri
import android.os.Build
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.style.StyleSpan
import android.view.LayoutInflater
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.databinding.GitCommitDialogBinding
import com.itsaky.androidide.preferences.internal.GITHUB_EMAIL
import com.itsaky.androidide.preferences.internal.GITHUB_PAT
import com.itsaky.androidide.preferences.internal.GITHUB_USERNAME
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.tasks.TaskExecutor.executeAsyncProvideError
import org.eclipse.jgit.api.CommitCommand
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.errors.RepositoryNotFoundException
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider
import java.io.File

object GitCommitTask {

        private val prefs = BaseApplication.getBaseInstance().prefManager

        //@RequiresApi(Build.VERSION_CODES.TIRAMISU)
        fun commit(/*project: Project,*/ context: Context) {

            val inflater =
                LayoutInflater.from(context).context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            inflater.inflate(R.layout.git_commit_dialog, null)

            val binding = GitCommitDialogBinding.inflate(inflater, null, false)
            val filesToCommit = ArrayList<String>()
            val filesUntracked = ArrayList<String>()
            val targetDir = ProjectManagerImpl.getInstance().projectDir


            binding.fabSendFeedback.setOnClickListener {
                val email = "thursdaynext@gmail.com"
                val subject = "Git Commit Feedback"
                val body = "Please Enter Your Feedback Below"
                val urlString =
                    "mailto:" + Uri.encode(email) + "?subject=" + Uri.encode(subject) + "&body=" + Uri.encode(
                        body
                    )
                val intent = Intent(Intent.ACTION_SENDTO).apply {
                    data = Uri.parse(urlString)
                    putExtra(Intent.EXTRA_EMAIL, email)
                    putExtra(Intent.EXTRA_SUBJECT, subject)
                    putExtra(Intent.EXTRA_TEXT, body)
                }
                val packageManager = context.packageManager
                val activities = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    context.packageManager.queryIntentActivities(
                        Intent(Intent.ACTION_MAIN, null).addCategory(Intent.CATEGORY_LAUNCHER),
                        PackageManager.ResolveInfoFlags.of(PackageManager.MATCH_DEFAULT_ONLY.toLong())
                    )
                } else {
                    context.packageManager.queryIntentActivities(
                        Intent(Intent.ACTION_MAIN, null).addCategory(Intent.CATEGORY_LAUNCHER),
                        PackageManager.GET_META_DATA
                    )
                }
                if (activities.isNotEmpty()) {
                    try {
                        //start email intent
                        //context.startActivity(createChooser(intent, "Choose Email Client..."))
                        context.startActivity(intent)
                    } catch (e: Exception) {
                        //if any thing goes wrong for example no email client application or any exception
                        //get and show exception message
                        Toast.makeText(context, e.message, Toast.LENGTH_LONG).show()
                    }
                }
            }

            val git : Git = try {
                 Git.open(targetDir)
            } catch(e : RepositoryNotFoundException) {
                null
            } ?: TODO("add alert dialog here to explain missing repo")
            val repo = git.repository
            val branch = repo.branch
            val result = git.status().call()
            val cf = git.diff().setCached(false).setShowNameOnly(true).call()

            if (cf.size == 0) {

                Toast.makeText(
                    context,
                    context.getString(R.string.commit_canceled_files_to_commit),
                    Toast.LENGTH_LONG
                )
                    .show();
                return;
            } else {
                for (name in cf) {
                    if (!name.newPath.isNullOrBlank()) {
                        filesToCommit.add(name.newPath)
                    }
                }
            }

            val sb: StringBuilder = StringBuilder()
            sb.append("On Branch ")
            var pos = sb.length
            sb.append(branch)
            val ssb = SpannableStringBuilder(sb)
            val bi = StyleSpan(Typeface.BOLD_ITALIC)
            ssb.setSpan(bi, pos, sb.length, Spanned.SPAN_INCLUSIVE_INCLUSIVE)
            binding.tvOnBranch.text = ssb


            val status = git.status().call()
            sb.clear()
            ssb.clear()
            sb.append("Your branch is up to date with '")
            pos = sb.length
            sb.append("origin/master")
            var pos1 = sb.length
            sb.append("'")
            ssb.append(sb)
            ssb.setSpan(bi, pos, pos1, Spanned.SPAN_INCLUSIVE_INCLUSIVE)
            binding.tvBranchStatus.text = ssb

            binding.teCommitMessage.hint = "enter commit message here"
            val adapter = ArrayAdapter<String>(
                context,
                android.R.layout.simple_list_item_multiple_choice,
                filesToCommit
            )
            binding.lvFilesToCommit.adapter = adapter
            binding.lvFilesToCommit.choiceMode = ListView.CHOICE_MODE_MULTIPLE
            for (i in 0 until adapter.count) {
                binding.lvFilesToCommit.setItemChecked(i, true)
            }

            // Set a listener to handle item check changes
            binding.lvFilesToCommit.setOnItemClickListener { _, _, position, _ ->
                // Handle the long click event
                val item = binding.lvFilesToCommit.getItemAtPosition(position).toString()
                val isChecked = binding.lvFilesToCommit.isItemChecked(position)
                // Return true to consume the long click event
                true
            }


            val builder = AlertDialog.Builder(context)
            builder.setTitle(R.string.commit_changes)
            builder.setView(binding.root)
            builder.setPositiveButton(R.string.title_commit) { _, _ ->

                val userName = prefs.getString(GITHUB_USERNAME, "")
                val userEmail = prefs.getString(GITHUB_EMAIL, "")

                val future =
                    executeAsyncProvideError({

                        val msg = binding.teCommitMessage.text?.toString()
                        var file = File(targetDir, "/.git")
                        var path = file.toString()

                        if (userName.isNullOrBlank() && userEmail.isNullOrBlank()) {
                            ThreadUtils.runOnUiThread {
                                Toast.makeText(
                                    context,
                                    context.getString(R.string.set_user_and_password),
                                    Toast.LENGTH_SHORT
                                ).show()
                            }
                        } else if (msg.isNullOrBlank()) {
                            ThreadUtils.runOnUiThread {
                                Toast.makeText(
                                    context,
                                    context.getString(R.string.empty_commit),
                                    Toast.LENGTH_SHORT
                                ).show()
                            }
                        } else if (binding.lvFilesToCommit.checkedItemCount == 0) {
                            Toast.makeText(
                                context,
                                context.getString(R.string.commit_canceled_no_files_to_commit),
                                Toast.LENGTH_LONG
                            ).show()
                        } else {

                            val gitDir = Git.open(targetDir)
                            val cmd: CommitCommand = gitDir.commit()
                            for (i in 0 until adapter.count) {
                                if (binding.lvFilesToCommit.isItemChecked(i)) {
                                    cmd.setOnly(
                                        binding.lvFilesToCommit.getItemAtPosition(i).toString()
                                    )
                                }
                                cmd.setCommitter(userName.toString(), userEmail.toString())
                                    .setMessage(msg)
                                val token = prefs.getString(
                                        GITHUB_PAT,
                                        ""
                                    )
                                if (!token.isNullOrBlank()) {
                                    cmd.setCredentialsProvider(
                                        UsernamePasswordCredentialsProvider(
                                            "<token>",
                                            token
                                        )
                                    )
                                }

                                cmd.call()

                                ThreadUtils.runOnUiThread {
                                    Toast.makeText(
                                        context,
                                        context.getString(
                                            R.string.committed_all_changes_to_repository_in,
                                            path
                                        ),
                                        Toast.LENGTH_SHORT
                                    ).show()
                                }

                            }
                        }

                        return@executeAsyncProvideError
                    }, { _, _ -> })

                future.whenComplete { result, error ->
                    ThreadUtils.runOnUiThread {
                        //TODO error log
//                        if (result == null || error != null) {
//                            ErrorOutput.ShowError(error, context)
//                        }
                    }
                }

            }

            builder.setNegativeButton(android.R.string.cancel, null)
            builder.show()

        }
    }



================================================
File: java/com/itsaky/androidide/git/GitFetchTask.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.git

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.common.databinding.LayoutDialogProgressBinding
import com.itsaky.androidide.preferences.internal.GITHUB_PAT
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.tasks.TaskExecutor
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider

object GitFetchTask {
  //  val sshTransportConfigCallback = SshTransportConfigCallback()
  private val prefs = BaseApplication.getBaseInstance().prefManager

  fun fetch(context: Context) {

    val inflater =
      LayoutInflater.from(context).context.getSystemService(
        Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    inflater.inflate(R.layout.layout_dialog_progress, null)
    val binding = LayoutDialogProgressBinding.inflate(inflater, null, false)
    val view = binding.root
    binding.message.visibility = View.VISIBLE
    val builder = AlertDialog.Builder(context)
    builder.setTitle(R.string.fetching)
    builder.setView(view)
    builder.setCancelable(false)
    val targetDir = ProjectManagerImpl.getInstance().projectDir


    val progress = GitProgressMonitor(binding.progress, binding.message)

    val future =
      TaskExecutor.executeAsyncProvideError({

        val git = Git.open(targetDir)
        val cmd = git.fetch().setProgressMonitor(progress)
//          .setTransportConfigCallback(sshTransportConfigCallback)
        val token = prefs.getString(
          GITHUB_PAT,
          ""
        )
        if (!token.isNullOrBlank()) {
          cmd.setCredentialsProvider(
            UsernamePasswordCredentialsProvider(
              "<token>",
              token
            )
          )
          cmd.call()
        }
        return@executeAsyncProvideError
      }, { _, _ -> })

    val dialog = builder.show()

    future.whenComplete { result, error ->
      ThreadUtils.runOnUiThread {
        dialog?.dismiss()

        if (result == null || error != null) {
          TODO("ErrorOutput.ShowError(error, context)")
        } else {
          Toast.makeText(
            context,
            context.getString(R.string.fetch_completed),
            Toast.LENGTH_SHORT
          ).show()
        }

      }
    }

  }
}


================================================
File: java/com/itsaky/androidide/git/GitInitTask.kt
================================================
package com.itsaky.androidide.git

import android.content.Context
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import org.eclipse.jgit.api.Git
import java.io.File

object GitInitTask {

    fun init(context: Context) {
        val projectDir = ProjectManagerImpl.getInstance().projectDir
        if (projectDir == null) {
            flashError("No project is open.")
            return
        }

        // Check if a .git directory already exists
        val gitDir = File(projectDir, ".git")
        if (gitDir.exists()) {
            flashError("Project is already a Git repository.")
            return
        }

        try {
            // Initialize the repository
            Git.init().setDirectory(projectDir).call()
            flashSuccess("Git repository initialized successfully!")

            // Optional: You might want to refresh UI elements that depend on Git status
            // For example, by sending an event or calling a method on a ViewModel.

        } catch (e: Exception) {
            flashError("Failed to initialize repository: ${e.message}")
            e.printStackTrace()
        }
    }
}


================================================
File: java/com/itsaky/androidide/git/GitProgressMonitor.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.git

import android.widget.TextView
import com.blankj.utilcode.util.ThreadUtils
import com.google.android.material.progressindicator.LinearProgressIndicator
import org.eclipse.jgit.lib.ProgressMonitor

class GitProgressMonitor(val progress: LinearProgressIndicator, val message: TextView) :
  ProgressMonitor {

  private var cancelled = false

  fun cancel() {
    cancelled = true
  }

  override fun start(totalTasks: Int) {
    ThreadUtils.runOnUiThread { progress.max = totalTasks }
  }

  override fun beginTask(title: String?, totalWork: Int) {
    ThreadUtils.runOnUiThread { message.text = title }
  }

  override fun update(completed: Int) {
    ThreadUtils.runOnUiThread { progress.progress = completed }
  }

  override fun endTask() {}

  override fun isCancelled(): Boolean {
    return cancelled || Thread.currentThread().isInterrupted
  }

  override fun showDuration(p0: Boolean) {
    TODO("Not yet implemented")
  }
}



================================================
File: java/com/itsaky/androidide/git/GitPullTask.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.git

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.common.databinding.LayoutDialogProgressBinding
import com.itsaky.androidide.preferences.internal.GITHUB_PAT
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.tasks.TaskExecutor
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider

object GitPullTask {
  //  val sshTransportConfigCallback = SshTransportConfigCallback()
  private val prefs = BaseApplication.getBaseInstance().prefManager

  fun pull(context: Context) {

    val inflater =
      LayoutInflater.from(context).context.getSystemService(
        Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    inflater.inflate(R.layout.layout_dialog_progress, null)
    val binding = LayoutDialogProgressBinding.inflate(inflater, null, false)
    val view = binding.root
    binding.message.visibility = View.VISIBLE
    val builder = AlertDialog.Builder(context)
    builder.setTitle(R.string.pulling)
    builder.setView(view)
    builder.setCancelable(false)
    val targetDir = ProjectManagerImpl.getInstance().projectDir


    val progress = GitProgressMonitor(binding.progress, binding.message)

    val future =
      TaskExecutor.executeAsyncProvideError({

        val git = Git.open(targetDir)
        val cmd = git.pull().setProgressMonitor(progress)
//          .setTransportConfigCallback(sshTransportConfigCallback)
        val token = prefs.getString(
          GITHUB_PAT,
          ""
        )
        if (!token.isNullOrBlank()) {
          cmd.setCredentialsProvider(
            UsernamePasswordCredentialsProvider(
              "<token>",
              token
            )
          )
          cmd.call()
        }
        return@executeAsyncProvideError
      }, { _, _ -> })

    val dialog = builder.show()

    future.whenComplete { result, error ->
      ThreadUtils.runOnUiThread {
        dialog?.dismiss()

        if (result == null || error != null) {
          TODO("ErrorOutput.ShowError(error, context)")
        } else {
          Toast.makeText(
            context,
            context.getString(R.string.pull_completed),
            Toast.LENGTH_SHORT
          ).show()
        }

      }
    }

  }
}


================================================
File: java/com/itsaky/androidide/git/GitPushTask.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.git

import android.content.Context
import android.content.SharedPreferences
import android.view.LayoutInflater
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import com.blankj.utilcode.util.ThreadUtils
import com.itsaky.androidide.R
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.common.databinding.LayoutDialogProgressBinding
import com.itsaky.androidide.preferences.internal.GITHUB_PAT
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.tasks.TaskExecutor.executeAsyncProvideError
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider

object GitPushTask {

//  val sshTransportConfigCallback = SshTransportConfigCallback()
  private val prefs = BaseApplication.getBaseInstance().prefManager

  fun push(context: Context) {

    val inflater =
      LayoutInflater.from(context).context.getSystemService(
        Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    inflater.inflate(R.layout.layout_dialog_progress, null)
    val binding = LayoutDialogProgressBinding.inflate(inflater, null, false)
    val view = binding.root
    binding.message.visibility = View.VISIBLE
    val builder = AlertDialog.Builder(context)
    builder.setTitle(R.string.pushing)
    builder.setView(view)
    builder.setCancelable(false)
    val targetDir = ProjectManagerImpl.getInstance().projectDir


    val progress = GitProgressMonitor(binding.progress, binding.message)

    val future =
      executeAsyncProvideError({

        val git = Git.open(targetDir)
        val cmd = git.push().setProgressMonitor(progress)
//          .setTransportConfigCallback(sshTransportConfigCallback)
        val token = prefs.getString(
          GITHUB_PAT,
          ""
        )
        if (!token.isNullOrBlank()) {
          cmd.setCredentialsProvider(
            UsernamePasswordCredentialsProvider(
              "<token>",
              token
            )
          )
          cmd.call()
        }
          return@executeAsyncProvideError
        }, { _, _ -> })

    val dialog = builder.show()

    future.whenComplete { result, error ->
      ThreadUtils.runOnUiThread {
        dialog?.dismiss()

        if (result == null || error != null) {
          TODO("ErrorOutput.ShowError(error, context)")
        } else {
          Toast.makeText(
            context,
            context.getString(R.string.push_completed),
            Toast.LENGTH_SHORT
          ).show()
        }

      }
    }

  }
}



================================================
File: java/com/itsaky/androidide/handlers/BaseEventHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.handlers

import android.content.Context
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.eventbus.events.Event
import com.itsaky.androidide.eventbus.events.EventReceiver
import org.slf4j.Logger
import org.slf4j.LoggerFactory

/**
 * Base class for event handlers.
 *
 * @author Akash Yadav
 */
abstract class BaseEventHandler : EventReceiver {

  companion object {

    @JvmStatic
    protected val log: Logger = LoggerFactory.getLogger(BaseEventHandler::class.java)
  }

  protected open fun checkIsEditorActivity(event: Event): Boolean {
    return event.get(Context::class.java) is EditorHandlerActivity
  }

  protected open fun logCannotHandle(event: Event) {
    log.warn("Context is not EditorActivity. Cannot handle {} event.", event.javaClass.simpleName)
  }
}



================================================
File: java/com/itsaky/androidide/handlers/EditorActivityLifecyclerObserver.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.handlers

import android.content.Context
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import com.itsaky.androidide.eventbus.events.Event
import com.itsaky.androidide.eventbus.events.EventReceiver
import com.itsaky.androidide.eventbus.events.editor.OnCreateEvent
import com.itsaky.androidide.eventbus.events.editor.OnDestroyEvent
import com.itsaky.androidide.eventbus.events.editor.OnPauseEvent
import com.itsaky.androidide.eventbus.events.editor.OnResumeEvent
import com.itsaky.androidide.eventbus.events.editor.OnStartEvent
import com.itsaky.androidide.eventbus.events.editor.OnStopEvent
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.projects.util.BootClasspathProvider
import com.itsaky.androidide.utils.EditorActivityActions
import com.itsaky.androidide.utils.EditorSidebarActions
import com.itsaky.androidide.utils.Environment
import org.greenrobot.eventbus.EventBus
import java.util.concurrent.CompletableFuture

/**
 * Observes lifecycle events if [com.itsaky.androidide.EditorActivityKt].
 *
 * @author Akash Yadav
 */
class EditorActivityLifecyclerObserver : DefaultLifecycleObserver {

  private val fileActionsHandler = FileTreeActionHandler()

  override fun onCreate(owner: LifecycleOwner) {
    EditorActivityActions.register(owner as Context)
    EditorSidebarActions.registerActions(owner as Context)
    dispatchEvent(OnCreateEvent())
  }

  override fun onStart(owner: LifecycleOwner) {
    CompletableFuture.runAsync(this::initBootclasspathProvider)
    register(fileActionsHandler, ProjectManagerImpl.getInstance())

    dispatchEvent(OnStartEvent())
  }

  override fun onResume(owner: LifecycleOwner) {
    EditorActivityActions.register(owner as Context)
    dispatchEvent(OnResumeEvent())
  }

  override fun onPause(owner: LifecycleOwner) {
    EditorActivityActions.clearActions()
    dispatchEvent(OnPauseEvent())
  }

  override fun onStop(owner: LifecycleOwner) {
    unregister(fileActionsHandler, ProjectManagerImpl.getInstance())
    dispatchEvent(OnStopEvent())
  }

  override fun onDestroy(owner: LifecycleOwner) {
    dispatchEvent(OnDestroyEvent())
  }

  private fun register(vararg receivers: EventReceiver) {
    receivers.forEach { it.register() }
  }

  private fun unregister(vararg receivers: EventReceiver) {
    receivers.forEach { it.unregister() }
  }

  private fun dispatchEvent(event: Event) {
    EventBus.getDefault().post(event)
  }

  private fun initBootclasspathProvider() {
    BootClasspathProvider.update(listOf(Environment.ANDROID_JAR.absolutePath))
  }
}



================================================
File: java/com/itsaky/androidide/handlers/EditorBuildEventListener.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.handlers

import com.itsaky.androidide.R
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.preferences.internal.GeneralPreferences
import com.itsaky.androidide.resources.R.string
import com.itsaky.androidide.services.builder.GradleBuildService
import com.itsaky.androidide.tooling.api.messages.result.BuildInfo
import com.itsaky.androidide.tooling.events.ProgressEvent
import com.itsaky.androidide.tooling.events.configuration.ProjectConfigurationStartEvent
import com.itsaky.androidide.tooling.events.task.TaskStartEvent
import com.itsaky.androidide.utils.flashError
import com.itsaky.androidide.utils.flashSuccess
import org.slf4j.LoggerFactory
import java.lang.ref.WeakReference

/**
 * Handles events received from [GradleBuildService] updates [EditorHandlerActivity].
 * @author Akash Yadav
 */
class EditorBuildEventListener : GradleBuildService.EventListener {

  private var enabled = true
  private var activityReference: WeakReference<EditorHandlerActivity> = WeakReference(null)

  companion object {

    private val log = LoggerFactory.getLogger(EditorBuildEventListener::class.java)
  }

  private val _activity: EditorHandlerActivity?
    get() = activityReference.get()
  private val activity: EditorHandlerActivity
    get() = checkNotNull(activityReference.get()) { "Activity reference has been destroyed!" }

  fun setActivity(activity: EditorHandlerActivity) {
    this.activityReference = WeakReference(activity)
    this.enabled = true
  }

  fun release() {
    activityReference.clear()
    this.enabled = false
  }

  override fun prepareBuild(buildInfo: BuildInfo) {
    checkActivity("prepareBuild") ?: return

    val isFirstBuild = GeneralPreferences.isFirstBuild
    activity
      .setStatus(
        activity.getString(if (isFirstBuild) string.preparing_first else string.preparing)
      )

    if (isFirstBuild) {
      activity.showFirstBuildNotice()
    }

    activity.editorViewModel.isBuildInProgress = true
    activity.content.bottomSheet.clearBuildOutput()

    if (buildInfo.tasks.isNotEmpty()) {
      activity.content.bottomSheet.appendBuildOut(
        activity.getString(R.string.title_run_tasks) + " : " + buildInfo.tasks)
    }
  }

  override fun onBuildSuccessful(tasks: List<String?>) {
    checkActivity("onBuildSuccessful") ?: return

    analyzeCurrentFile()

    GeneralPreferences.isFirstBuild = false
    activity.editorViewModel.isBuildInProgress = false

    activity.flashSuccess(R.string.build_status_sucess)
  }

  override fun onProgressEvent(event: ProgressEvent) {
    checkActivity("onProgressEvent") ?: return

    if (event is ProjectConfigurationStartEvent || event is TaskStartEvent) {
      activity.setStatus(event.descriptor.displayName)
    }
  }

  override fun onBuildFailed(tasks: List<String?>) {
    checkActivity("onBuildFailed") ?: return

    analyzeCurrentFile()

    GeneralPreferences.isFirstBuild = false
    activity.editorViewModel.isBuildInProgress = false

    activity.flashError(R.string.build_status_failed)
  }

  override fun onOutput(line: String?) {
    checkActivity("onOutput") ?: return

    line?.let { activity.appendBuildOutput(it) }
    // TODO This can be handled better when ProgressEvents are received from Tooling API server
    if (line!!.contains("BUILD SUCCESSFUL") || line.contains("BUILD FAILED")) {
      activity.setStatus(line)
    }
  }

  private fun analyzeCurrentFile() {
    checkActivity("analyzeCurrentFile") ?: return

    val editorView = _activity?.getCurrentEditor()
    if (editorView != null) {
      val editor = editorView.editor
      editor?.analyze()
    }
  }

  private fun checkActivity(action: String): EditorHandlerActivity? {
    if (!enabled) return null

    return _activity.also {
      if (it == null) {
        log.warn("[{}] Activity reference has been destroyed!", action)
        enabled = false
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/handlers/FileTreeActionHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.handlers

import android.content.Context
import androidx.core.view.GravityCompat
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem.Location.EDITOR_FILE_TREE
import com.itsaky.androidide.actions.ActionMenu
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.actions.internal.DefaultActionsRegistry
import com.itsaky.androidide.activities.editor.EditorHandlerActivity
import com.itsaky.androidide.eventbus.events.filetree.FileClickEvent
import com.itsaky.androidide.eventbus.events.filetree.FileLongClickEvent
import com.itsaky.androidide.events.CollapseTreeNodeRequestEvent
import com.itsaky.androidide.events.ExpandTreeNodeRequestEvent
import com.itsaky.androidide.events.FileContextMenuItemClickEvent
import com.itsaky.androidide.events.ListProjectFilesRequestEvent
import com.itsaky.androidide.fragments.sheets.OptionsListFragment
import com.itsaky.androidide.models.SheetOption
import com.itsaky.androidide.utils.ApkInstaller
import com.itsaky.androidide.utils.InstallationResultHandler
import com.itsaky.androidide.utils.flashError
import com.unnamed.b.atv.model.TreeNode
import org.greenrobot.eventbus.EventBus
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode.MAIN
import java.io.File

/**
 * Handles events related to files in filetree.
 *
 * @author Akash Yadav
 */
@Suppress("unused")
class FileTreeActionHandler : BaseEventHandler() {

  private var lastHeld: TreeNode? = null

  companion object {

    const val TAG_FILE_OPTIONS_FRAGMENT = "file_options_fragment"
    const val MB_10: Long = 10 * 1024 * 1024
  }

  @Subscribe(threadMode = MAIN)
  fun onFileClicked(event: FileClickEvent) {
    if (!checkIsEditorActivity(event)) {
      logCannotHandle(event)
      return
    }

    if (event.file.isDirectory) {
      return
    }

    val context = event[Context::class.java]!! as EditorHandlerActivity
    context.binding.root.closeDrawer(GravityCompat.START)
    if (event.file.name.endsWith(".apk")) {
      ApkInstaller.installApk(
        context,
        InstallationResultHandler.createEditorActivitySender(context),
        event.file,
        context.installationSessionCallback()
      )
      return
    }

    if (MB_10 < event.file.length()) {
      flashError("File is too big!")
      log.warn(
        "Cannot open {} as it is too big. File size: {} bytes", event.file, event.file.length())
      return
    }

    context.openFile(event.file)
  }

  @Subscribe(threadMode = MAIN)
  fun onFileLongClicked(event: FileLongClickEvent) {
    if (!checkIsEditorActivity(event)) {
      logCannotHandle(event)
      return
    }

    this.lastHeld = event[TreeNode::class.java]
    val context = event[Context::class.java]!! as EditorHandlerActivity
    createFileOptionsFragment(context, event.file)
      .show(context.supportFragmentManager, TAG_FILE_OPTIONS_FRAGMENT)
  }

  private fun createFileOptionsFragment(
    context: EditorHandlerActivity,
    file: File
  ): OptionsListFragment {
    val fragment = OptionsListFragment()
    val registry = ActionsRegistry.getInstance()
    val actions = registry.getActions(EDITOR_FILE_TREE)
    val data = ActionData.create(context)
    data.apply {
      put(File::class.java, file)
      put(TreeNode::class.java, lastHeld)
    }

    for (action in actions.values) {

      check(action !is ActionMenu) { "File tree actions do not support action menus" }

      action.prepare(data)
      if (!action.enabled || !action.visible) {
        continue
      }

      fragment.addOption(
        SheetOption(action.id, action.icon, action.label, file).apply { this.extra = data }
      )
    }

    return fragment
  }

  @Subscribe(threadMode = MAIN)
  internal fun onFileOptionClicked(event: FileContextMenuItemClickEvent) {
    val option = event.option
    if (option.extra !is ActionData) {
      return
    }

    val data = option.extra!! as ActionData
    val registry = ActionsRegistry.getInstance() as DefaultActionsRegistry
    val action = registry.findAction(EDITOR_FILE_TREE, option.id)

    checkNotNull(action) {
      "Invalid FileContextMenuItemClickEvent received. No action item registered with id '${option.id}'"
    }

    registry.executeAction(action, data)
  }

  private fun requestFileListing() {
    EventBus.getDefault().post(ListProjectFilesRequestEvent())
  }

  private fun requestExpandHeldNode() {
    requestExpandNode(lastHeld!!)
  }

  private fun requestCollapseHeldNode() {
    requestCollapseNode(lastHeld!!, true)
  }

  private fun requestExpandNode(node: TreeNode) {
    EventBus.getDefault().post(ExpandTreeNodeRequestEvent(node))
  }

  private fun requestCollapseNode(node: TreeNode, includeSubnodes: Boolean) {
    EventBus.getDefault().post(CollapseTreeNodeRequestEvent(node, includeSubnodes))
  }
}



================================================
File: java/com/itsaky/androidide/handlers/LspHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.handlers

import com.itsaky.androidide.lsp.api.ILanguageClient
import com.itsaky.androidide.lsp.api.ILanguageServerRegistry
import com.itsaky.androidide.lsp.debug.IDebugClient
import com.itsaky.androidide.lsp.java.JavaLanguageServer
import com.itsaky.androidide.lsp.xml.XMLLanguageServer

/**
 *
 * @author Akash Yadav
 */
object LspHandler {

  fun registerLanguageServers() {
    ILanguageServerRegistry.getDefault().apply {
      getServer(JavaLanguageServer.SERVER_ID) ?: register(JavaLanguageServer())
      getServer(XMLLanguageServer.SERVER_ID) ?: register(XMLLanguageServer())
    }
  }
  
  fun connectClient(client: ILanguageClient) {
    ILanguageServerRegistry.getDefault().connectClient(client)
  }

  fun connectDebugClient(client: IDebugClient) {
    ILanguageServerRegistry.getDefault().connectDebugClient(client)
  }

  fun destroyLanguageServers(isConfigurationChange: Boolean) {
    if (isConfigurationChange) {
      return
    }
    ILanguageServerRegistry.getDefault().destroy()
  }
}



================================================
File: java/com/itsaky/androidide/interfaces/DiagnosticClickListener.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/
package com.itsaky.androidide.interfaces;

import com.itsaky.androidide.lsp.models.DiagnosticItem;
import com.itsaky.androidide.models.DiagnosticGroup;
import java.io.File;

public interface DiagnosticClickListener {
  void onGroupClick(DiagnosticGroup group);

  void onDiagnosticClick(File file, DiagnosticItem diagnostic);
}



================================================
File: java/com/itsaky/androidide/interfaces/IEditorHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.interfaces

import com.itsaky.androidide.idetooltips.IDETooltipItem
import com.itsaky.androidide.models.Range
import com.itsaky.androidide.models.SaveResult
import com.itsaky.androidide.ui.CodeEditorView
import java.io.File

/**
 * @author Akash Yadav
 */
interface IEditorHandler {
  
  fun findIndexOfEditorByFile(file: File?) : Int
  
  fun getCurrentEditor(): CodeEditorView?
  fun getEditorAtIndex(index: Int) : CodeEditorView?
  fun getEditorForFile(file: File) : CodeEditorView?
  
  fun openFile(file: File) : CodeEditorView? = openFile(file, null)
  fun openFile(file: File, selection: Range?) : CodeEditorView?
  fun openFileAndSelect(file: File, selection: Range?)
  fun openFileAndGetIndex(file: File, selection: Range?) : Int
  
  fun areFilesModified(): Boolean
  fun areFilesSaving(): Boolean

  /**
   * Save all files.
   *
   * @param notify Whether to notify the user about the save event.
   * @param processResources Whether the resources must be generated after the save operation.
   * @param progressConsumer A function which consumes the progress of the save operation.
   * See [saveAllResult] for more details.
   */
  suspend fun saveAll(
    notify: Boolean = true,
    requestSync: Boolean = true,
    processResources: Boolean = false,
    progressConsumer: ((progress: Int, total: Int) -> Unit)? = null
  ) : Boolean

  /**
   * Save all files asynchronously.
   *
   * @param runAfter A callback function which will be run after the files are saved.
   * @see saveAll
   */
  fun saveAllAsync(
    notify: Boolean = true,
    requestSync: Boolean = true,
    processResources: Boolean = false,
    progressConsumer: ((progress: Int, total: Int) -> Unit)? = null,
    runAfter: (() -> Unit)? = null
  )

  /**
   * Save all files and get the [SaveResult].
   *
   * @param progressConsumer A function which consumes the progress of the save operation. The first
   * parameter of the function is the current save progress (saved file count) and the second parameter
   * is the total file count.
   */
  suspend fun saveAllResult(progressConsumer: ((progress: Int, total: Int) -> Unit)? = null) : SaveResult
  suspend fun saveResult(index: Int, result: SaveResult)
  
  fun closeFile(index: Int) = closeFile(index) {}
  fun closeFile(index: Int, runAfter: () -> Unit)
  fun closeAll() = closeAll {}
  fun closeAll(runAfter: () -> Unit)
  fun closeOthers()
  fun openFAQActivity(htmlData: String)
  suspend fun getTooltipData(category: String, tag:String): IDETooltipItem?
}


================================================
File: java/com/itsaky/androidide/localWebServer/WebServer.kt
================================================
package org.appdevforall.localwebserver

import android.database.sqlite.SQLiteDatabase
import android.util.Log
import com.aayushatharva.brotli4j.decoder.BrotliInputStream
import java.io.BufferedReader
import java.io.ByteArrayInputStream
import java.io.InputStreamReader
import java.io.PrintWriter
import java.net.ServerSocket
import java.net.Socket


data class ServerConfig(
    val port: Int = 6174,
    val databasePath: String
)

class WebServer(private val config: ServerConfig) {
    private var running = false
    private lateinit var serverSocket: ServerSocket
    private val TAG = "WebServer"

    fun start() {
        try {
            Log.d(TAG, "Starting WebServer on port ${config.port}")
            
            // Verify database access
            try {
                val testDb = SQLiteDatabase.openDatabase(config.databasePath, null, SQLiteDatabase.OPEN_READONLY)
                testDb.close()
            } catch (e: Exception) {
                Log.e(TAG, "Cannot open database: ${e.message}")
                return
            }

            serverSocket = ServerSocket(config.port, 0, java.net.InetAddress.getByName("0.0.0.0"))
            running = true
            Log.i(TAG, "WebServer started successfully on port ${config.port}")
            
            while (running) {
                val clientSocket = serverSocket.accept()
                handleClient(clientSocket)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error: ${e.message}")
        } finally {
            stop()
        }
    }

    private fun handleClient(clientSocket: Socket) {
        try {
            val reader = BufferedReader(InputStreamReader(clientSocket.getInputStream()))
            val writer = PrintWriter(clientSocket.getOutputStream(), true)
            val output = clientSocket.getOutputStream()

            // Read the request line
            val requestLine = reader.readLine()
            
            if (requestLine == null) {
                return
            }

            // Parse the request
            val parts = requestLine.split(" ")
            if (parts.size != 3) {
                sendError(writer, 400, "Bad Request")
                return
            }

            val method = parts[0]
            val path = parts[1]
            
            // Only support GET method for now
            if (method != "GET") {
                sendError(writer, 501, "Not Implemented")
                return
            }

            val db = SQLiteDatabase.openDatabase(config.databasePath, null, SQLiteDatabase.OPEN_READONLY)
            val query = """
                SELECT c.content, ct.value AS mime_type, ct.compression
                FROM Content c
                JOIN ContentTypes ct ON c.contentTypeID = ct.id
                WHERE c.path = ? OR c.path = ?
                LIMIT 1
            """
            val cursor = db.rawQuery(query, arrayOf(path, path.substring(1)))
            if (cursor.moveToFirst()) {
                var dbContent = cursor.getBlob(cursor.getColumnIndexOrThrow("content"))
                val dbMimeType = cursor.getString(cursor.getColumnIndexOrThrow("mime_type"))
                val compression = cursor.getString(cursor.getColumnIndexOrThrow("compression"))
                    
                // If content is Brotli compressed, decompress it
                if (compression == "brotli") {
                    try {
                        dbContent = BrotliInputStream(ByteArrayInputStream(dbContent)).use { it.readBytes() }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error decompressing Brotli content: ${e.message}")
                        sendError(writer, 500, "Internal Server Error")
                        return
                    }
                }
                    
                writer.println("HTTP/1.1 200 OK")
                writer.println("Content-Type: $dbMimeType")
                writer.println("Content-Length: ${dbContent.size}")
                writer.println("Connection: close")
                writer.println()
                writer.flush()
                output.write(dbContent)
                output.flush()
            } else {
                sendError(writer, 404, "Not Found")
            }
            cursor.close()
            db.close()
        } catch (e: Exception) {
            Log.e(TAG, "Error handling client: ${e.message}")
            try {
                val writer = PrintWriter(clientSocket.getOutputStream(), true)
                sendError(writer, 500, "Internal Server Error")
            } catch (e: Exception) {
                Log.e(TAG, "Error sending error response: ${e.message}")
            }
        } finally {
            clientSocket.close()
        }
    }

    private fun sendError(writer: PrintWriter, code: Int, message: String) {
        writer.println("HTTP/1.1 $code $message")
        writer.println("Content-Type: text/plain")
        writer.println("Connection: close")
        writer.println()
        writer.println("$code $message")
    }

    fun stop() {
        running = false
        if (::serverSocket.isInitialized) {
            serverSocket.close()
        }
    }
} 



================================================
File: java/com/itsaky/androidide/logging/IDELoggingConfigurator.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.logging

import ch.qos.logback.classic.Logger
import ch.qos.logback.classic.LoggerContext
import ch.qos.logback.classic.spi.Configurator
import ch.qos.logback.classic.spi.ConfiguratorRank
import ch.qos.logback.core.spi.ContextAwareBase
import com.google.auto.service.AutoService
import com.itsaky.androidide.logging.encoder.IDELogFormatEncoder

/**
 * Default IDE logging configurator.
 *
 * @author Akash Yadav
 */
@ConfiguratorRank(ConfiguratorRank.CUSTOM_TOP_PRIORITY)
@AutoService(Configurator::class)
@Suppress("UNUSED")
class IDELoggingConfigurator : ContextAwareBase(), Configurator {

  override fun configure(context: LoggerContext): Configurator.ExecutionStatus {
    addInfo("Setting up logging configuration")

    val appender = LogcatAppender()
    appender.context = context
    appender.start()

    val rootLogger = context.getLogger(Logger.ROOT_LOGGER_NAME)
    rootLogger.addAppender(appender)

    return Configurator.ExecutionStatus.DO_NOT_INVOKE_NEXT_IF_ANY
  }
}


================================================
File: java/com/itsaky/androidide/logging/LifecycleAwareAppender.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.logging

import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.LifecycleOwner
import ch.qos.logback.classic.spi.ILoggingEvent
import ch.qos.logback.core.AppenderBase
import ch.qos.logback.core.Context
import com.itsaky.androidide.logging.encoder.IDELogFormatLayout

/**
 * An [AppenderBase] implementation to show the logs in the GUI.
 *
 * @author Akash Yadav
 */
class LifecycleAwareAppender @JvmOverloads constructor(
  private val requireLifecycleState: Lifecycle.State = Lifecycle.State.CREATED,
  var consumer: ((String) -> Unit)? = null
) : AppenderBase<ILoggingEvent>(), LifecycleEventObserver {

  private var currentState: Lifecycle.State? = null
  private val logLayout = IDELogFormatLayout(true)

  init {
    setName("LifecycleAwareAppender")
  }

  fun attachTo(lifecycleOwner: LifecycleOwner) = attachTo(lifecycleOwner.lifecycle)
  fun attachTo(lifecycle: Lifecycle) = lifecycle.addObserver(this)

  fun detachFrom(lifecycleOwner: LifecycleOwner) = detachFrom(lifecycleOwner.lifecycle)
  fun detachFrom(lifecycle: Lifecycle) = lifecycle.removeObserver(this)

  override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {

    this.currentState = when (event) {
      Lifecycle.Event.ON_ANY -> null
      else -> event.targetState
    }
  }

  override fun isStarted(): Boolean {
    return (super.isStarted()
        && currentState?.isAtLeast(this.requireLifecycleState) == true
        && consumer != null)
  }

  override fun start() {
    this.logLayout.start()
    super.start()
  }

  override fun stop() {
    super.stop()
    this.logLayout.stop()
    this.consumer = null
  }

  override fun setContext(context: Context?) {
    super.setContext(context)
    this.logLayout.context = context
  }

  override fun append(eventObject: ILoggingEvent?) {
    if (eventObject == null || !isStarted) {
      return
    }

    // When rendering the logs in the GUI, we need to ensure that the message does not span multiple lines
    // if it does, we need to prefix the message with the layout header
    val prefix = logLayout.doLayout(eventObject).trim()
    eventObject.formattedMessage.split('\n').forEach {
      consumer?.invoke("$prefix $it")
    }
  }
}


================================================
File: java/com/itsaky/androidide/lsp/BreakpointHandler.kt
================================================
package com.itsaky.androidide.lsp

import com.google.common.collect.HashBasedTable
import com.itsaky.androidide.eventbus.events.editor.ChangeType
import com.itsaky.androidide.eventbus.events.editor.DocumentChangeEvent
import com.itsaky.androidide.lsp.debug.model.BreakpointDefinition
import com.itsaky.androidide.lsp.debug.model.PositionalBreakpoint
import com.itsaky.androidide.lsp.debug.model.Source
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.newSingleThreadContext
import org.slf4j.LoggerFactory
import java.io.File
import java.util.concurrent.CopyOnWriteArrayList
import kotlin.properties.Delegates

private interface BreakpointEvent {
    data class DocChange(
        val event: DocumentChangeEvent
    ): BreakpointEvent

    data class Toggle(
        val file: File,
        val line: Int
    ): BreakpointEvent

}

class BreakpointHandler {

    @OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
    private val scope = CoroutineScope(newSingleThreadContext("BreakpointHandler"))
    private val events = Channel<BreakpointEvent>(capacity = Channel.UNLIMITED)
    private val breakpoints = HashBasedTable.create<String, Int, PositionalBreakpoint>()
    private val _highlightedLocation = MutableStateFlow<Pair<String, Int>?>(null)
    private var onSetBreakpoints: (List<BreakpointDefinition>) -> Unit by Delegates.notNull()
    private val listeners = CopyOnWriteArrayList<EventListener>()

    val highlightedLocationState: StateFlow<Pair<String, Int>?>
        get() = _highlightedLocation.asStateFlow()

    val highlightedLocation: Pair<String, Int>?
        get() = highlightedLocationState.value

    val allBreakpoints: List<BreakpointDefinition>
        get() = ArrayList(breakpoints.rowMap().flatMap { (_, bp) -> bp.values })

    companion object {
        private val logger = LoggerFactory.getLogger(BreakpointHandler::class.java)
    }

    fun highlightLocation(file: String, line: Int) {
        this._highlightedLocation.update { file to line }
        notifyHighlighted(file, line)
    }

    fun unhighlightHighlightedLocation() {
        this._highlightedLocation.update { null }
        notifyUnhighlight()
    }

    fun breakpointsInFile(path: String) = ArrayList(breakpoints.row(path).values)

    fun begin(consumer: (List<BreakpointDefinition>) -> Unit) {
        onSetBreakpoints = consumer

        scope.launch {
            for (event in events) {
                process(event)
            }
        }
    }

    fun addListener(listener: EventListener) {
        if (listeners.contains(listener)) {
            logger.warn("listener {} is already added", listener)
            return
        }

        listeners.add(listener)
    }

    fun removeListener(listener: EventListener) {
        listeners.remove(listener)
    }

    suspend fun change(event: DocumentChangeEvent) {
        events.send(BreakpointEvent.DocChange(event))
    }

    suspend fun toggle(file: File, line: Int) {
        events.send(BreakpointEvent.Toggle(file, line))
    }

    private fun process(event: BreakpointEvent) {
        when (event) {
            is BreakpointEvent.DocChange -> onChange(event)
            is BreakpointEvent.Toggle -> onToggle(event)
        }
    }

    private fun onChange(event: BreakpointEvent.DocChange) {
        val ev = event.event
        val path = ev.file.toRealPath().toString()
        logger.debug("change: range={}-{}", ev.changeRange.start.line, ev.changeRange.end.line)
        if (ev.changeType == ChangeType.NEW_TEXT) {
            logger.debug("new content set to file {}. removing all breakpoints", path)

            // all of the editor's text was invalidated
            // remove all breakpoints in this file
            val breakpoints = breakpoints.row(path)
            synchronized(breakpoints) {
                // remove breakpoints from client if we're connected
                // create a copy, because 'breakpoints' may be cleared even before the
                // coroutine is launched
                val localBreakpoints = ArrayList(breakpoints.values)
                localBreakpoints.forEach { notifyRemoved(path, it.line) }

                onSetBreakpoints(localBreakpoints)
                breakpoints.clear()
            }

            return
        }

        val range = ev.changeRange
        val (start, end) = range

        val fileBreakpoints = breakpoints.row(path)
        val newBreakpoints = synchronized(breakpoints) {
            val newBreakpoints = mutableMapOf<Int, PositionalBreakpoint>()
            for ((line, breakpoint) in fileBreakpoints) {
                if (line < start.line) {
                    // this breakpoint lies before the edit region, or on the same line
                    // as a result, it doesn't require an update to the line number
                    logger.debug("keep breakpoint at line {} in file {}", line, path)
                    newBreakpoints[line] = breakpoint
                    continue
                }

                if (start.line != end.line && range.containsLine(line)) {
                    // in case of multi-line edits, if the breakpoint line was in the edited region
                    // then the breakpoint is no longer valid
                    // in such cases, remove all breakpoints which were in the edited region
                    logger.debug("removing breakpoint at line {} in file {} because the breakpoint line was removed by editing file", line, path)
                    notifyRemoved(path, line)
                    continue
                }

                // we assume that the end line always > start line
                var lineDelta = end.line - start.line
                if (ev.changeType == ChangeType.DELETE) {
                    // content was deleted, so the lines must be reduced by delta
                    lineDelta = -lineDelta
                }

                logger.debug("updating breakpoints in file {} by delta {}", path, lineDelta)

                // for breakpoints that lie beyond the edit range, we need to update their line
                // numbers according to the delta in change range
                val newLine = line + lineDelta
                logger.debug("breakpoint at line {} moved to line {} in file {}", line, newLine, path)
                newBreakpoints[newLine] = breakpoint.copy(line = newLine)
                notifyMoved(path, line, newLine)
            }

            breakpoints.row(path).apply {
                clear()
                putAll(newBreakpoints)
            }

            newBreakpoints.values.toList()
        }

        // publish the new breakpoints to the client, if connected
        onSetBreakpoints(newBreakpoints)
    }

    private fun onToggle(event: BreakpointEvent.Toggle) {
        val (file, line) = event
        val breakpoint = PositionalBreakpoint(
            source = Source(
                path = file.absolutePath,
                name = file.name
            ),
            line = line
        )

        val path = file.canonicalPath

        val remove = breakpoints.contains(path, line)
        logger.debug("{} breakpoint at line {} in {}", if (remove) "remove" else "add", line, path)

        if (remove) {
            breakpoints.remove(path, line)
            notifyRemoved(path, line)
        } else {
            breakpoints.put(path, line, breakpoint)
            notifyAdded(path, line)
        }

        notifyToggled(path, line)

        // if we're already connected to a client, update the client as well
        val fileBreakpoints = breakpoints.row(path)
        onSetBreakpoints(ArrayList(fileBreakpoints.values))
    }

    private fun notifyAdded(file: String, line: Int) {
        for (listener in listeners) {
            listener.onAddBreakpoint(file, line)
        }
    }

    private fun notifyRemoved(file: String, line: Int) {
        for (listener in listeners) {
            listener.onRemoveBreakpoint(file, line)
        }
    }

    private fun notifyToggled(file: String, line: Int) {
        for (listener in listeners) {
            listener.onToggle(file, line)
        }
    }

    private fun notifyMoved(file: String, oldLine: Int, newLine: Int) {
        for (listener in listeners) {
            listener.onMoveBreakpoint(file, oldLine, newLine)
        }
    }

    private fun notifyHighlighted(file: String, line: Int) {
        for (listener in listeners) {
            listener.onHighlightLine(file, line)
        }
    }

    private fun notifyUnhighlight() {
        for (listener in listeners) {
            listener.onUnhighlight()
        }
    }

    interface EventListener {
        fun onAddBreakpoint(file: String, line: Int) {}
        fun onRemoveBreakpoint(file: String, line: Int) {}
        fun onToggle(file: String, line: Int) {}
        fun onMoveBreakpoint(file: String, oldLine: Int, newLine: Int) {}
        fun onHighlightLine(file: String, line: Int) {}
        fun onUnhighlight()
    }
}


================================================
File: java/com/itsaky/androidide/lsp/IDEDebugClientImpl.kt
================================================
package com.itsaky.androidide.lsp

import android.annotation.SuppressLint
import android.widget.RemoteViews.RemoteView
import com.itsaky.androidide.eventbus.events.EventReceiver
import com.itsaky.androidide.eventbus.events.editor.DocumentChangeEvent
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.lsp.debug.IDebugClient
import com.itsaky.androidide.lsp.debug.IDebugEventHandler
import com.itsaky.androidide.lsp.debug.RemoteClient
import com.itsaky.androidide.lsp.debug.events.BreakpointHitEvent
import com.itsaky.androidide.lsp.debug.events.StepEvent
import com.itsaky.androidide.lsp.debug.model.BreakpointRequest
import com.itsaky.androidide.lsp.debug.model.LocatableEvent
import com.itsaky.androidide.lsp.debug.model.Location
import com.itsaky.androidide.lsp.debug.model.StepRequestParams
import com.itsaky.androidide.lsp.debug.model.StepResult
import com.itsaky.androidide.lsp.debug.model.StepType
import com.itsaky.androidide.lsp.debug.model.ThreadListRequestParams
import com.itsaky.androidide.models.Position
import com.itsaky.androidide.models.Range
import com.itsaky.androidide.viewmodel.DebuggerConnectionState
import com.itsaky.androidide.viewmodel.DebuggerViewModel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.newFixedThreadPoolContext
import kotlinx.coroutines.withContext
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode
import org.slf4j.LoggerFactory
import java.io.File
import java.util.concurrent.CopyOnWriteArraySet

/**
 * @author Akash Yadav
 */
class IDEDebugClientImpl(
    private val viewModel: DebuggerViewModel,
) : IDebugClient, IDebugEventHandler, EventReceiver {

    private val logger = LoggerFactory.getLogger(IDEDebugClientImpl::class.java)

    @OptIn(DelicateCoroutinesApi::class)
    private val clientContext = newFixedThreadPoolContext(4, "IDEDebugClient")
    private val clientScope = CoroutineScope(clientContext + SupervisorJob())
    private val clients = CopyOnWriteArraySet<RemoteClient>()
    val breakpoints = BreakpointHandler()

    companion object {
        @JvmStatic
        fun getInstance() = Lookup.getDefault().lookup(IDEDebugClientImpl::class.java)

        @JvmStatic
        fun requireInstance() = checkNotNull(getInstance()) {
            "Cannot lookup IDEDebugClientImpl"
        }
    }

    val connectionStateFlow: StateFlow<DebuggerConnectionState>
        get() = viewModel.connectionState

    var connectionState: DebuggerConnectionState
        get() = viewModel.connectionState.value
        private set(value) {
            logger.debug("move to connection state: {}", value)
            viewModel.setConnectionState(value)
        }

    val debugeePackage: String
        get() = viewModel.debugeePackage

    internal val requireClient: RemoteClient
        get() = checkNotNull(clientOrNull)

    internal val clientOrNull: RemoteClient?
        get() = clients.firstOrNull()

    /**
     * Returns true if the client is connected.
     *
     * @return `true` if the client is connected, `false` otherwise.
     */
    fun isVmConnected() = connectionState >= DebuggerConnectionState.ATTACHED

    /**
     * Returns true if the client is connected and suspended.
     *
     * The VM may or may not be able to view/alter its state. Check [connectionState]
     * to get the actual state.
     *
     * @return `true` if the client is connected and suspended, `false` otherwise.
     */
    fun isVmSuspended() = connectionState >= DebuggerConnectionState.SUSPENDED

    fun suspendVm() = withClient("suspend vm") { client ->
        if (!client.capabilities.suspensionSupport) {
            logger.error("Remote client does not support suspending")
            return@withClient
        }

        if (isVmSuspended()) {
            logger.warn("Ignoring attempt to suspend VM when it is already suspended")
            return@withClient
        }

        logger.debug("suspending client: {}", client.name)
        clientScope.launch {
            if (client.adapter.suspendClient(client)) {
                connectionState = DebuggerConnectionState.SUSPENDED
                updateThreadInfo(client)
            }
        }
    }

    fun resumeVm() = withClient("resume vm") { client ->
        if (!client.capabilities.suspensionSupport) {
            logger.error("Remote client does not support resuming")
            return@withClient
        }

        if (!isVmSuspended()) {
            logger.warn("Ignoring attempt to resume VM when it is not suspended")
            return@withClient
        }

        logger.debug("resuming client: {}", client.name)
        clientScope.launch {
            if (client.adapter.resumeClient(client)) {
                connectionState = DebuggerConnectionState.ATTACHED
                updateThreadInfo(client)
            }
        }
    }

    fun killVm() = withClient("kill vm") { client ->
        if (!client.capabilities.killSupport) {
            logger.error("Remote client does not support killing debug application")
            return@withClient
        }

        logger.debug("killing client: {}", client.name)
        clientScope.launch { client.adapter.killClient(client) }
    }

    fun stepOver() = doStep(type = StepType.Over)
    fun stepInto() = doStep(type = StepType.Into)
    fun stepOut() = doStep(type = StepType.Out)

    private inline fun withClient(action: String, block: (RemoteClient) -> Unit) {
        clientOrNull?.also(block)
            ?: logger.error("Cannot perform $action action. Not connected to a remote client.")
    }

    private fun doStep(
        type: StepType,
        countFilter: Int = 1
    ) = withClient("step $type") { client ->
        if (!client.capabilities.stepSupport) {
            logger.error("Remote client does not support stepping")
            return@withClient
        }

        clientScope.launch {
            val params = StepRequestParams(
                remoteClient = client,
                type = type,
                countFilter = countFilter
            )

            val response = client.adapter.step(params)
            if (response.result != StepResult.Success) {
                logger.error("Failed to perform step action, result={}", response.result)
            }
        }
    }

    init {
        register()
        breakpoints.begin { breakpoints ->

            // if we're already connected to a client, update the client as well
            clientOrNull?.also { client ->
                if (!client.capabilities.breakpointSupport) {
                    logger.error("Remote client does not support breakpoints")
                    return@also
                }

                clientScope.launch {
                    clientOrNull?.also { client ->
                        val response = client.adapter.setBreakpoints(
                            BreakpointRequest(
                                remoteClient = client,
                                breakpoints = breakpoints
                            )
                        )

                        logger.debug("breakpoint result: {}", response.results)
                    } ?: logger.info("client ${client.name} disconnected while updating breakpoints")
                }
            } ?: logger.info("deferring breakpoint update, no clients connected")
        }
    }

    @SuppressLint("ImplicitSamInstance")
    @Suppress("UNUSED")
    @Subscribe(threadMode = ThreadMode.ASYNC)
    fun onContentChange(event: DocumentChangeEvent) {
        clientScope.launch { breakpoints.change(event) }
    }

    fun toggleBreakpoint(file: File, line: Int) {
        clientScope.launch { breakpoints.toggle(file, line) }
    }

    override fun onBreakpointHit(event: BreakpointHitEvent) {
        logger.debug("onBreakpointHit: {}", event)

        clientScope.launch {
            connectionState = DebuggerConnectionState.AWAITING_BREAKPOINT
            updateThreadInfo(event.remoteClient, event.threadId)

            openLocation(event)
        }
    }

    override fun onStep(event: StepEvent) {
        logger.debug("onStep: {}", event)

        clientScope.launch {
            updateThreadInfo(event.remoteClient, event.threadId)
            connectionState = DebuggerConnectionState.AWAITING_BREAKPOINT

            openLocation(event)
        }
    }

    override fun onAttach(client: RemoteClient) {
        logger.debug("onAttach: client={}", client)

        check(client !in clients) {
            "Already attached to client"
        }

        clients += client
        connectionState = DebuggerConnectionState.ATTACHED
        breakpoints.unhighlightHighlightedLocation()

        clientScope.launch {
            updateThreadInfo(client)

            val breakpoints = breakpoints.allBreakpoints
            client.adapter.setBreakpoints(
                BreakpointRequest(
                    remoteClient = client,
                    breakpoints = breakpoints
                )
            )
        }
    }

    override fun onDisconnect(client: RemoteClient) {
        logger.debug("onDisconnect: client={}", client)
        breakpoints.unhighlightHighlightedLocation()
        clients -= client
        connectionState = DebuggerConnectionState.DETACHED
        clientScope.launch { updateThreadInfo(client) }
    }

    suspend fun updateThreadInfo(
        client: RemoteClient,
        selectedThreadId: String? = null,
    ) {
        val adapter = client.adapter
        var selectedThreadIndex = -1
        val threads = when (connectionState) {
            DebuggerConnectionState.DETACHED,
            DebuggerConnectionState.ATTACHED -> emptyList()

            DebuggerConnectionState.SUSPENDED,
            DebuggerConnectionState.AWAITING_BREAKPOINT -> {
                val threadResponse = adapter.allThreads(
                    ThreadListRequestParams(
                        remoteClient = client
                    )
                )

                val threads = threadResponse.threads
                if (threads.isEmpty()) {
                    logger.error("Failed to get info about active threads in VM: {}", client.name)
                } else if (selectedThreadId != null) {
                    selectedThreadIndex = threads.indexOfFirst {
                        it.descriptor().id == selectedThreadId
                    }
                }

                threads
            }
        }

        if (threads.isNotEmpty() && selectedThreadIndex < 0) {
            selectedThreadIndex = 0
        }

        viewModel.setThreads(threads)

        if (selectedThreadIndex >= 0) {
            viewModel.setSelectedThreadIndex(selectedThreadIndex)
        }
    }

    private suspend fun openLocation(event: LocatableEvent) = openLocation(event.location)

    private suspend fun openLocation(location: Location) {
        val file = location.source.path
        val position = Position(location.line, 0)

        val activity = IDELanguageClientImpl.getInstance().activity

        if (activity == null) {
            logger.error("Cannot open {}:{} because activity is null", file, position.line)
            return
        }

        breakpoints.highlightLocation(file, position.line)

        withContext(Dispatchers.Main.immediate) {
            activity.openFileAndSelect(
                file = File(file),
                selection = Range(
                    start = position,
                    end = position
                )
            )
        }
    }
}


================================================
File: java/com/itsaky/androidide/lsp/IDELanguageClientImpl.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.lsp;

import static com.itsaky.androidide.resources.R.drawable;
import static com.itsaky.androidide.resources.R.string;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.blankj.utilcode.util.FileIOUtils;
import com.blankj.utilcode.util.FileUtils;
import com.itsaky.androidide.activities.editor.EditorHandlerActivity;
import com.itsaky.androidide.adapters.DiagnosticsAdapter;
import com.itsaky.androidide.adapters.SearchListAdapter;
import com.itsaky.androidide.editor.ui.IDEEditor;
import com.itsaky.androidide.fragments.sheets.ProgressSheet;
import com.itsaky.androidide.lsp.api.ILanguageClient;
import com.itsaky.androidide.lsp.models.CodeActionItem;
import com.itsaky.androidide.lsp.models.DiagnosticItem;
import com.itsaky.androidide.lsp.models.DiagnosticResult;
import com.itsaky.androidide.lsp.models.PerformCodeActionParams;
import com.itsaky.androidide.lsp.models.ShowDocumentParams;
import com.itsaky.androidide.lsp.models.ShowDocumentResult;
import com.itsaky.androidide.lsp.models.TextEdit;
import com.itsaky.androidide.lsp.util.DiagnosticUtil;
import com.itsaky.androidide.models.DiagnosticGroup;
import com.itsaky.androidide.models.Location;
import com.itsaky.androidide.models.Range;
import com.itsaky.androidide.models.SearchResult;
import com.itsaky.androidide.tasks.TaskExecutor;
import com.itsaky.androidide.ui.CodeEditorView;
import com.itsaky.androidide.utils.FlashbarActivityUtilsKt;
import com.itsaky.androidide.utils.FlashbarUtilsKt;
import com.itsaky.androidide.utils.LSPUtils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

import io.github.rosemoe.sora.lang.diagnostic.DiagnosticsContainer;
import io.github.rosemoe.sora.text.Content;
import kotlin.Unit;

/**
 * AndroidIDE specific implementation of the LanguageClient
 */
public class IDELanguageClientImpl implements ILanguageClient {

  public static final int MAX_DIAGNOSTIC_FILES = 10;
  public static final int MAX_DIAGNOSTIC_ITEMS_PER_FILE = 20;
  protected static final Logger LOG = LoggerFactory.getLogger(IDELanguageClientImpl.class);
  private static IDELanguageClientImpl mInstance;
  private final Map<File, List<DiagnosticItem>> diagnostics = new HashMap<>();

  protected EditorHandlerActivity activity;

  private IDELanguageClientImpl(EditorHandlerActivity provider) {
    setActivity(provider);
  }

  public void setActivity(EditorHandlerActivity provider) {
    this.activity = provider;
  }

  public static IDELanguageClientImpl initialize(EditorHandlerActivity provider) {
    if (mInstance != null) {
      throw new IllegalStateException("Client is already initialized");
    }

    mInstance = new IDELanguageClientImpl(provider);

    return getInstance();
  }

  public static IDELanguageClientImpl getInstance() {
    if (mInstance == null) {
      throw new IllegalStateException("Client not initialized");
    }

    return mInstance;
  }

  public static void shutdown() {
    if (mInstance != null) {
      mInstance.activity = null;
    }
    mInstance = null;
  }

  public static boolean isInitialized() {
    return mInstance != null;
  }

  @Override
  public IDEDebugClientImpl getDebugClient() {
    return IDEDebugClientImpl.getInstance();
  }

  @Override
  public void publishDiagnostics(DiagnosticResult result) {
    if (result == DiagnosticResult.NO_UPDATE || !canUseActivity()) {
      // No update is expected
      return;
    }

    boolean error = result == null;
    activity.handleDiagnosticsResultVisibility(error || result.getDiagnostics().isEmpty());

    if (error) {
      return;
    }

    File file = result.getFile().toFile();
    if (!file.exists() || !file.isFile()) {
      return;
    }

    final var editorView = activity.getEditorForFile(file);
    if (editorView != null) {
      final var editor = editorView.getEditor();
      if (editor != null) {
        final var container = new DiagnosticsContainer();
        try {
          container.addDiagnostics(
              result.getDiagnostics().stream()
                  .map(DiagnosticItem::asDiagnosticRegion)
                  .collect(Collectors.toList()));
        } catch (Throwable err) {
          LOG.error("Unable to map DiagnosticItem to DiagnosticRegion", err);
        }
        editor.setDiagnostics(container);
      }
    }

    diagnostics.put(file, result.getDiagnostics());
    activity.setDiagnosticsAdapter(newDiagnosticsAdapter());
  }

  @Nullable
  @Override
  public DiagnosticItem getDiagnosticAt(final File file, final int line, final int column) {
    return DiagnosticUtil.binarySearchDiagnostic(this.diagnostics.get(file), line, column);
  }

  @Override
  public void performCodeAction(PerformCodeActionParams params) {
    if (params == null) {
      return;
    }

    final var action = params.getAction();
    if (!canUseActivity()) {
      LOG.error("Unable to perform code action activity=null action={}", action);
      FlashbarUtilsKt.flashError(string.msg_cannot_perform_fix);
      return;
    }

    final var currentEditor = this.activity.getCurrentEditor();
    final var editor = currentEditor != null ? currentEditor.getEditor() : null;

    if (!params.getAsync()) {
      applyActionEdits(editor, action);
      if (editor != null) {
        action.getCommand();
        editor.executeCommand(action.getCommand());
      }
      return;
    }

    final ProgressSheet progress = new ProgressSheet();
    progress.setSubMessageEnabled(false);
    progress.setCancelable(false);
    progress.setMessage(this.activity.getString(string.msg_performing_actions));
    progress.show(this.activity.getSupportFragmentManager(), "quick_fix_progress");

    TaskExecutor.executeAsyncProvideError(
        () -> applyActionEdits(editor, action),
        (result, throwable) -> {
          progress.dismiss();
          if (result == null || throwable != null || !result) {
            LOG.error("Unable to perform code action result={}", result, throwable);
            FlashbarActivityUtilsKt.flashError(this.activity, string.msg_cannot_perform_fix);
          } else if (editor != null) {
            editor.executeCommand(action.getCommand());
          }
        });
  }

  private Boolean applyActionEdits(@Nullable final IDEEditor editor, final CodeActionItem action) {
    final var changes = action.getChanges();
    if (changes.isEmpty()) {
      return Boolean.FALSE;
    }

    for (var change : changes) {
      final var path = change.getFile();
      if (path == null) {
        continue;
      }

      final File file = path.toFile();
      if (!file.exists()) {
        continue;
      }

      for (TextEdit edit : change.getEdits()) {
        final String editorFilepath =
            editor == null || editor.getFile() == null ? "" : editor.getFile().getAbsolutePath();
        if (file.getAbsolutePath().equals(editorFilepath)) {
          // Edit is in the same editor which requested the code action
          editInEditor(editor, edit);
        } else {
          var openedFrag = findEditorByFile(file);

          if (openedFrag != null && openedFrag.getEditor() != null) {
            // Edit is in another 'opened' file
            editInEditor(openedFrag.getEditor(), edit);
          } else {
            // Edit is in some other file which is not opened
            // open that file and perform the edit
            openedFrag = activity.openFile(file);
            if (openedFrag != null && openedFrag.getEditor() != null) {
              editInEditor(openedFrag.getEditor(), edit);
            }
          }
        }
      }
    }

    return Boolean.TRUE;
  }

  private void editInEditor(final IDEEditor editor, final TextEdit edit) {
    activity
        .runOnUiThread(
            () -> {
              final Range range = edit.getRange();
              final int startLine = range.getStart().getLine();
              final int startCol = range.getStart().getColumn();
              final int endLine = range.getEnd().getLine();
              final int endCol = range.getEnd().getColumn();
              if (startLine == endLine && startCol == endCol) {
                editor.getText().insert(startLine, startCol, edit.getNewText());
              } else {
                editor.getText().replace(startLine, startCol, endLine, endCol, edit.getNewText());
              }
            });
  }

  @Override
  public ShowDocumentResult showDocument(ShowDocumentParams params) {
    boolean success = false;
    final var result = new ShowDocumentResult(false);
    if (!canUseActivity()) {
      return result;
    }

    if (params != null) {
      File file = params.getFile().toFile();
      if (file.exists() && file.isFile() && FileUtils.isUtf8(file)) {
        final var range = params.getSelection();
        var frag =
            activity.getEditorAtIndex(activity.getContent().tabs.getSelectedTabPosition());
        if (frag != null
            && frag.getFile() != null
            && frag.getEditor() != null
            && frag.getFile().getAbsolutePath().equals(file.getAbsolutePath())) {
          if (LSPUtils.isEqual(range.getStart(), range.getEnd())) {
            frag.getEditor().setSelection(range.getStart().getLine(), range.getStart().getColumn());
          } else {
            frag.getEditor().setSelection(range);
          }
        } else {
          activity.openFileAndSelect(file, range);
        }
        success = true;
      }
    }

    result.setSuccess(success);
    return result;
  }

  public DiagnosticsAdapter newDiagnosticsAdapter() {
    return new DiagnosticsAdapter(mapAsGroup(this.diagnostics), activity);
  }

  private List<DiagnosticGroup> mapAsGroup(Map<File, List<DiagnosticItem>> map) {
    final var groups = new ArrayList<DiagnosticGroup>();
    var diagnosticMap = map;
    if (diagnosticMap == null || diagnosticMap.size() == 0) {
      return groups;
    }

    if (diagnosticMap.size() > 10) {
      LOG.warn("Limiting the diagnostics to 10 files");
      diagnosticMap = filterRelevantDiagnostics(map);
    }

    for (File file : diagnosticMap.keySet()) {
      var fileDiagnostics = diagnosticMap.get(file);
      if (fileDiagnostics == null || fileDiagnostics.size() == 0) {
        continue;
      }

      // Trim the diagnostics list if we have too many diagnostic items.
      // Including a lot of diagnostic items will result in UI lag when they are shown
      if (fileDiagnostics.size() > MAX_DIAGNOSTIC_ITEMS_PER_FILE) {
        LOG.warn("Limiting diagnostics to {} items for file {}",
            MAX_DIAGNOSTIC_ITEMS_PER_FILE,
            file.getName());

        fileDiagnostics = fileDiagnostics.subList(0, MAX_DIAGNOSTIC_ITEMS_PER_FILE);
      }
      DiagnosticGroup group = new DiagnosticGroup(drawable.ic_language_java, file, fileDiagnostics);
      groups.add(group);
    }
    return groups;
  }

  @NonNull
  private Map<File, List<DiagnosticItem>> filterRelevantDiagnostics(
      @NonNull final Map<File, List<DiagnosticItem>> map) {
    final var result = new HashMap<File, List<DiagnosticItem>>();
    final var files = map.keySet();

    // Diagnostics of files that are open must always be included
    final var relevantFiles = findOpenFiles(files, MAX_DIAGNOSTIC_FILES);

    // If we can show a few more file diagnostics...
    if (relevantFiles.size() < MAX_DIAGNOSTIC_FILES) {
      final var alphabetical = new TreeSet<>(Comparator.comparing(File::getName));
      alphabetical.addAll(files);
      for (var file : alphabetical) {
        relevantFiles.add(file);
        if (relevantFiles.size() == MAX_DIAGNOSTIC_FILES) {
          break;
        }
      }
    }

    for (var file : relevantFiles) {
      result.put(file, map.get(file));
    }
    return result;
  }

  @NonNull
  private Set<File> findOpenFiles(final Set<File> files, final int max) {
    final var openedFiles = activity.getEditorViewModel().getOpenedFiles();
    final var result = new TreeSet<File>();
    for (int i = 0; i < openedFiles.size(); i++) {
      final var opened = openedFiles.get(i);
      if (files.contains(opened)) {
        result.add(opened);
      }
      if (result.size() == max) {
        break;
      }
    }
    return result;
  }

  /**
   * Called by {@link IDEEditor IDEEditor} to show locations in EditorActivity
   */
  @Override
  public void showLocations(List<Location> locations) {

    // Cannot show anything if the activity() is null
    if (!canUseActivity()) {
      return;
    }

    boolean error = locations == null || locations.isEmpty();
    activity.handleSearchResultVisibility(error);

    if (error) {
      activity
          .setSearchResultAdapter(
              new SearchListAdapter(Collections.emptyMap(), this::noOp, this::noOp));
      return;
    }

    final Map<File, List<SearchResult>> results = new HashMap<>();
    for (int i = 0; i < locations.size(); i++) {
      try {
        final Location loc = locations.get(i);
        if (loc == null) {
          continue;
        }

        final File file = loc.getFile().toFile();
        if (!file.exists() || !file.isFile()) {
          continue;
        }
        var frag = findEditorByFile(file);
        Content content;
        if (frag != null && frag.getEditor() != null) {
          content = frag.getEditor().getText();
        } else {
          content = new Content(FileIOUtils.readFile2String(file));
        }
        final List<SearchResult> matches =
            results.containsKey(file) ? results.get(file) : new ArrayList<>();
        Objects.requireNonNull(matches)
            .add(
                new SearchResult(
                    loc.getRange(),
                    file,
                    content.getLineString(loc.getRange().getStart().getLine()),
                    content
                        .subContent(
                            loc.getRange().getStart().getLine(),
                            loc.getRange().getStart().getColumn(),
                            loc.getRange().getEnd().getLine(),
                            loc.getRange().getEnd().getColumn())
                        .toString()));
        results.put(file, matches);
      } catch (Throwable th) {
        LOG.error("Failed to show file location", th);
      }
    }

    activity.handleSearchResults(results);
  }

  private CodeEditorView findEditorByFile(File file) {
    return activity.getEditorForFile(file);
  }

  private boolean canUseActivity() {
    return activity != null
        && !activity.isFinishing()
        && !activity.isDestroyed()
        && !activity.getSupportFragmentManager().isDestroyed()
        && !activity.getSupportFragmentManager().isStateSaved();
  }

  private Unit noOp(final Object obj) {
    return Unit.INSTANCE;
  }
}



================================================
File: java/com/itsaky/androidide/models/ApkMetadata.kt
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.models

import com.google.gson.annotations.SerializedName
import com.itsaky.androidide.utils.JSONUtility.gson
import com.itsaky.androidide.utils.ListingFileRedirect.getListingFile
import org.slf4j.LoggerFactory
import java.io.File
import java.io.FileNotFoundException
import java.io.FileReader

class ApkMetadata {

  @SerializedName("version")
  var version = 0

  @SerializedName("artifactType")
  var artifactType: ArtifactType? = null

  @SerializedName("applicationId")
  var applicationId: String? = null

  @SerializedName("variantName")
  var variantName: String? = null

  @SerializedName("elements")
  var elements: List<MetadataElement>? = null

  @SerializedName("elementType")
  var elementType: String? = null

  companion object {

    private val log = LoggerFactory.getLogger(ApkMetadata::class.java)

    fun findApkFile(listingFIle: File): File? {
      return try {
        // This sometimes might be a redirect to the listing file
        // So we have to handle this case too.
        val redirectedFile = getListingFile(listingFIle).absoluteFile
        val dir = redirectedFile.parentFile

        FileReader(redirectedFile).use {
          val metadata = gson.fromJson(it, ApkMetadata::class.java)
          if (!isValid(metadata)) {
            log.warn("Invalid APK metadata: {}", metadata)
            return@use null
          }

          for (element in metadata.elements!!) {
            if (element.outputFile == null) {
              log.warn("No output file specified in APK metadata element: {}", element)
              continue
            }

            if (element.outputFile!!.endsWith(".apk")) {
              val apk = element.outputFile?.let { File(dir, it) } ?: continue
              if (apk.exists() && apk.isFile) {
                log.info("Found apk in metadata: {}", apk)
                return@use apk
              }
            }
          }

          return@use null
        }
      } catch (e: FileNotFoundException) {
        log.error("Metadata file not found...", e)
        null
      }
    }

    private fun isValid(metadata: ApkMetadata?): Boolean {
      // Null checks
      if (metadata?.artifactType?.type == null || metadata.elements == null) {
        log.warn("APK metadata null check failed. Metadata: {}", metadata)
        return false
      }

      val type = metadata.artifactType
      val elements = metadata.elements
      if (type!!.type != ArtifactType.TYPE_APK) {
        log.warn("Artifact is not of type APK. Metadata: {}", metadata)
        return false
      }
      if (elements!!.isEmpty()) {
        log.warn("No output elements found for metadata: {}", metadata)
        return false
      }
      var atLeastOneApk = false
      for (element in elements) {
        if (element.outputFile?.endsWith(".apk") == false) {
          log.warn("Skipping output element because file is not APK: {}", element)
          continue
        }
        atLeastOneApk = true
        break
      }
      log.debug("Output metadata validation succeeded")
      return atLeastOneApk
    }
  }

  override fun toString(): String {
    return "ApkMetadata(version=$version, artifactType=$artifactType, applicationId=$applicationId, variantName=$variantName, elements=$elements, elementType=$elementType)"
  }

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is ApkMetadata) return false

    if (version != other.version) return false
    if (artifactType != other.artifactType) return false
    if (applicationId != other.applicationId) return false
    if (variantName != other.variantName) return false
    if (elements != other.elements) return false
    if (elementType != other.elementType) return false

    return true
  }

  override fun hashCode(): Int {
    var result = version
    result = 31 * result + (artifactType?.hashCode() ?: 0)
    result = 31 * result + (applicationId?.hashCode() ?: 0)
    result = 31 * result + (variantName?.hashCode() ?: 0)
    result = 31 * result + (elements?.hashCode() ?: 0)
    result = 31 * result + (elementType?.hashCode() ?: 0)
    return result
  }
}



================================================
File: java/com/itsaky/androidide/models/ArtifactType.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import com.google.gson.annotations.SerializedName

class ArtifactType {
  @SerializedName("type") var type: String? = null
  @SerializedName("kind") var kind: String? = null

  companion object {
    var TYPE_APK = "APK"
  }

  override fun toString(): String {
    return "ArtifactType(type=$type, kind=$kind)"
  }

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is ArtifactType) return false

    if (type != other.type) return false
    if (kind != other.kind) return false

    return true
  }

  override fun hashCode(): Int {
    var result = type?.hashCode() ?: 0
    result = 31 * result + (kind?.hashCode() ?: 0)
    return result
  }
}


================================================
File: java/com/itsaky/androidide/models/Checkable.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

/**
 * Holds data that can be checked/unchecked.
 *
 * @author Akash Yadav
 */
data class Checkable<T>(var isChecked: Boolean, val data: T)



================================================
File: java/com/itsaky/androidide/models/DefaultOnboardingItem.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import kotlinx.parcelize.Parcelize

/**
 * Default implementation of [OnboardingItem].
 *
 * @author Akash Yadav
 */
@Parcelize
data class DefaultOnboardingItem(
  override val key: String,
  override val title: CharSequence,
  override val description: CharSequence = "",
  override val icon: Int = 0,
  override val iconTint: Int = 0,
  override val isClickable: Boolean = false,
  override val isLongClickable: Boolean = false
) : OnboardingItem



================================================
File: java/com/itsaky/androidide/models/DiagnosticGroup.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/
package com.itsaky.androidide.models;

import com.itsaky.androidide.lsp.models.DiagnosticItem;
import java.io.File;
import java.util.List;

public class DiagnosticGroup {
  public int icon;
  public String text;
  public File file;
  public List<DiagnosticItem> diagnostics;

  public DiagnosticGroup(int icon, File file, List<DiagnosticItem> diagnostics) {
    this.icon = icon;
    this.file = file;
    this.text = file.getName();
    this.diagnostics = diagnostics;
  }
}



================================================
File: java/com/itsaky/androidide/models/FileExtension.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import androidx.annotation.DrawableRes
import com.blankj.utilcode.util.ImageUtils
import com.itsaky.androidide.resources.R
import java.io.File

/**
 * Info about file extensions in the file tree view.
 *
 * @author Akash Yadav
 */
enum class FileExtension(val extension: String, @DrawableRes val icon: Int) {
  JAVA("java", R.drawable.ic_language_java),
  JAR("jar", R.drawable.ic_language_java),
  KT("kt", R.drawable.ic_language_kotlin),
  KTS("kts", R.drawable.ic_language_kts),
  XML("xml", R.drawable.ic_language_xml),
  GRADLE("gradle", R.drawable.ic_gradle),
  JSON("json", R.drawable.ic_language_json),
  PROPERTIES("properties", R.drawable.ic_language_properties),
  APK("apk", R.drawable.ic_file_apk),
  TXT("txt", R.drawable.ic_file_txt),
  LOG("log", R.drawable.ic_file_txt),
  CPP("cpp", R.drawable.ic_language_cpp),
  H("h", R.drawable.ic_language_cpp),
  BAT("bat", R.drawable.ic_terminal),
  DIRECTORY("", R.drawable.ic_folder),
  IMAGE("", R.drawable.ic_file_image),
  GRADLEW("", R.drawable.ic_terminal),
  UNKNOWN("", R.drawable.ic_file_unknown);

  /** Factory class for getting [FileExtension] instances. */
  class Factory {
    companion object {

      /** Get [FileExtension] for the given file. */
      @JvmStatic
      fun forFile(file: File?): FileExtension {
        return if (file?.isDirectory == true) DIRECTORY
          else if (ImageUtils.isImage(file)) IMAGE
          else if ("gradlew" == file?.name) GRADLEW
          else forExtension(file?.extension)
      }

      /** Get [FileExtension] for the given extension. */
      @JvmStatic
      fun forExtension(extension: String?): FileExtension {
        // To not assign IMAGE, GRADLEW and DIRECTORY in case of an empty extension,
        // we check if an extension is empty here
        if (extension.isNullOrEmpty()) {
          return UNKNOWN
        }
        
        for (value in entries) {
          if (value.extension == extension) {
            return value
          }
        }

        return UNKNOWN
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/models/HyperlinkedOnboardingItem.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import kotlinx.parcelize.Parcelize

/**
 * Implementation of [OnboardingItem] which also contains a link to be opened on click.
 *
 * @property hyperlink The hyperlink.
 * @author Akash Yadav
 */
@Parcelize
data class HyperlinkedOnboardingItem(
  override val key: String,
  override val title: CharSequence,
  val hyperlink: String,
  override val description: CharSequence = "",
  override val icon: Int = 0,
  override val iconTint: Int = 0,
  override val isClickable: Boolean = false,
  override val isLongClickable: Boolean = false
) : OnboardingItem


================================================
File: java/com/itsaky/androidide/models/IdeSetupArguments.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

/**
 * Configuration options for IDESetup
 *
 * @property argumentName The name of the argument.
 * @property requiresValue Whether the argument must have a value.
 * @author Akash Yadav
 */
enum class IdeSetupArgument(val argumentName: String, val requiresValue: Boolean = false) {
  INSTALL_DIR("--install-dir", true),
  WITH_GIT("--with-git"),
  ASSUME_YES("--assume-yes"),
  WITH_OPENSSH("--with-openssh"),
  SDK_VERSION("--sdk", true),
  JDK_VERSION("--jdk", true),
  OFFLINE_MODE("--offline-mode"),
  CACHE_DIR("--cache-dir"),
  ABI_FOLDER("--arch", true)
}



================================================
File: java/com/itsaky/androidide/models/MainScreenAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import android.view.View
import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import com.itsaky.androidide.resources.R
import java.util.Collections

/**
 * An action button shown on the main screen.
 *
 * @author Akash Yadav
 */
data class MainScreenAction
@JvmOverloads
constructor(
    val id: Int,
    @StringRes val text: Int,
    @DrawableRes val icon: Int,
    var onClick: ((MainScreenAction, View) -> Unit)? = null,
    var onLongClick: ((MainScreenAction, View) -> Boolean)? = null,
    var view: View? = null
) {

    companion object {

        const val ACTION_CREATE_PROJECT = 100
        const val ACTION_OPEN_PROJECT = 110
        const val ACTION_CLONE_REPO = 120
        const val ACTION_OPEN_TERMINAL = 130
        const val ACTION_PREFERENCES = 140
        const val ACTION_DONATE = 150
        const val ACTION_DOCS = 160
        const val ACTION_DELETE_PROJECT = 170

        /**
         * Get all main screen actions.
         */

        val createProject = MainScreenAction(
            ACTION_CREATE_PROJECT,
            R.string.create_project,
            R.drawable.ic_add
        )

        val openProject = MainScreenAction(
            ACTION_OPEN_PROJECT,
            R.string.msg_open_existing_project,
            R.drawable.ic_folder
        )

        val deleteProject = MainScreenAction(
            ACTION_DELETE_PROJECT,
            R.string.msg_delete_existing_project,
            R.drawable.ic_delete
        )

        val cloneGitRepository = MainScreenAction(
            ACTION_CLONE_REPO,
            R.string.git_clone_repo,
            R.drawable.ic_git
        )

        val openTerminal = MainScreenAction(
            ACTION_OPEN_TERMINAL,
            R.string.title_terminal,
            R.drawable.ic_terminal
        )

        val preferences = MainScreenAction(
            ACTION_PREFERENCES,
            R.string.msg_preferences,
            R.drawable.ic_settings
        )

        val donate = MainScreenAction(
            ACTION_DONATE,
            R.string.btn_donate,
            R.drawable.ic_heart
        )

        val docs = MainScreenAction(
            ACTION_DOCS,
            R.string.btn_docs,
            R.drawable.ic_docs
        )

        private val allActions: List<MainScreenAction> = listOf(
            createProject,
            openProject,
            deleteProject,
            cloneGitRepository,
            openTerminal,
            preferences,
            donate,
            docs
        )

        private val mainActions = allActions.minus(donate)

        @JvmStatic
        fun all(): List<MainScreenAction> {
            return allActions
        }

        @JvmStatic
        fun mainScreen(): List<MainScreenAction> {
            return mainActions
        }
    }
}



================================================
File: java/com/itsaky/androidide/models/MetadataElement.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import com.google.gson.annotations.SerializedName

class MetadataElement {
  @SerializedName("type") var type: String? = null
  @SerializedName("filters") var filters: List<Any>? = null
  @SerializedName("attributes") var attributes: List<Any>? = null
  @SerializedName("versionCode") var versionCode = 0
  @SerializedName("versionName") var versionName: String? = null
  @SerializedName("outputFile") var outputFile: String? = null
  
  override fun toString(): String {
    return "Element(type=$type, filters=$filters, attributes=$attributes, versionCode=$versionCode, versionName=$versionName, outputFile=$outputFile)"
  }

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is MetadataElement) return false

    if (type != other.type) return false
    if (filters != other.filters) return false
    if (attributes != other.attributes) return false
    if (versionCode != other.versionCode) return false
    if (versionName != other.versionName) return false
    if (outputFile != other.outputFile) return false

    return true
  }

  override fun hashCode(): Int {
    var result = type?.hashCode() ?: 0
    result = 31 * result + (filters?.hashCode() ?: 0)
    result = 31 * result + (attributes?.hashCode() ?: 0)
    result = 31 * result + versionCode
    result = 31 * result + (versionName?.hashCode() ?: 0)
    result = 31 * result + (outputFile?.hashCode() ?: 0)
    return result
  }
}


================================================
File: java/com/itsaky/androidide/models/NewProjectDetails.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/
package com.itsaky.androidide.models;

public class NewProjectDetails {

  public String name;
  public String packageName;
  public int minSdk;
  public int targetSdk;
  public String language;
  public String savePath;
  public String cppFlags;

  public NewProjectDetails() {}

  public NewProjectDetails(
      String name,
      String packageName,
      int minSdk,
      int targetSdk,
      String language,
      String cppFlags,
      String savePath) {
    this.name = name;
    this.packageName = packageName;
    this.minSdk = minSdk;
    this.targetSdk = targetSdk;
    this.language = language;
    this.cppFlags = cppFlags;
    this.savePath = savePath;
  }

  public String getName() {
    return name;
  }

  public NewProjectDetails setName(String name) {
    this.name = name;
    return this;
  }

  public String getPackageName() {
    return packageName;
  }

  public NewProjectDetails setPackageName(String packageName) {
    this.packageName = packageName;
    return this;
  }

  public int getMinSdk() {
    return minSdk;
  }

  public NewProjectDetails setMinSdk(int minSdk) {
    this.minSdk = minSdk;
    return this;
  }

  public int getTargetSdk() {
    return targetSdk;
  }

  public NewProjectDetails setTargetSdk(int targetSdk) {
    this.targetSdk = targetSdk;
    return this;
  }

  public String getCppFlags() {
    return cppFlags;
  }

  public NewProjectDetails setCppFlags(String cppFlags) {
    this.cppFlags = cppFlags;
    return this;
  }
}



================================================
File: java/com/itsaky/androidide/models/OnboardingItem.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import android.os.Parcelable
import androidx.annotation.ColorInt
import androidx.annotation.DrawableRes

/**
 * Item that is shown on the onboarding fragment.
 *
 * @author Akash Yadav
 */
interface OnboardingItem : Parcelable {

  /**
   * The key for the item.
   */
  val key: String

  /**
   * Title for the item.
   */
  val title: CharSequence

  /**
   * Short description (or subtitle) for the item.
   */
  val description: CharSequence

  /**
   * Icon for the item.
   */
  @get:DrawableRes
  val icon: Int

  /**
   * Icon tint for the item.
   */
  @get:ColorInt
  val iconTint: Int

  /**
   * Whether is item is clickable.
   */
  val isClickable: Boolean

  /**
   * Whether the item is long clickable.
   */
  val isLongClickable: Boolean
}


================================================
File: java/com/itsaky/androidide/models/OnboardingPermissionItem.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import androidx.annotation.StringRes

/**
 * @author Akash Yadav
 */
data class OnboardingPermissionItem(
  val permission: String,

  @StringRes
  val title: Int,

  @StringRes
  val description: Int,
  var isGranted: Boolean,

  var isOptional: Boolean = false
)


================================================
File: java/com/itsaky/androidide/models/OpenedFile.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.google.gson.stream.JsonReader
import org.slf4j.LoggerFactory

/**
 * A file that is opened in editor.
 *
 * @author Akash Yadav
 */
data class OpenedFile(
  @SerializedName(KEY_FILE) val filePath: String,
  @SerializedName(KEY_SELECTION) var selection: Range
) {

  companion object {

    private const val KEY_FILE = "file"
    private const val KEY_SELECTION = "selection"
    private val log = LoggerFactory.getLogger(OpenedFile::class.java)

    fun readFrom(reader: JsonReader): OpenedFile? {
      return try {
//        reader.beginObject()
//        var path = ""
//        var selection = Range.NONE
//        while(reader.hasNext()) {
//          val name = reader.nextName()
//          if (name == KEY_FILE) {
//            path = reader.nextString()
//          } else if (name == KEY_SELECTION) {
//            selection = Gson().fromJson(reader, Range::class.java)
//          }
//        }
//        reader.endObject()
//
//        OpenedFile(path, selection)
        Gson().fromJson(reader, OpenedFile::class.java)
      } catch (err: Exception) {
        log.error("Failed to read opened file", err)
        null
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/models/OpenedFilesCache.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import com.google.gson.stream.JsonReader
import org.slf4j.LoggerFactory
import java.io.Reader

/**
 * @author Akash Yadav
 */
data class OpenedFilesCache(@SerializedName(KEY_SELECTED_FILE) val selectedFile: String,
  @SerializedName(KEY_ALL_FILES) val allFiles: List<OpenedFile>) {

  companion object {

    private const val KEY_SELECTED_FILE = "selectedFile"
    private const val KEY_ALL_FILES = "allFiles"
    private val log = LoggerFactory.getLogger(OpenedFilesCache::class.java)

    @JvmStatic
    fun parse(contentReader: Reader): OpenedFilesCache? {
      return try {
        JsonReader(contentReader).use { reader ->
          if (!reader.hasNext()) {
            return@use null
          }

          reader.beginObject()
          var selectedFile = ""
          var allFiles = emptyList<OpenedFile>()
          while (reader.hasNext()) {
            val name = reader.nextName()

            if (name == KEY_SELECTED_FILE) {
              selectedFile = reader.nextString()
            } else if (name == KEY_ALL_FILES) {
              allFiles = Gson().fromJson(reader, object : TypeToken<List<OpenedFile>>() {})
            }
          }
          reader.endObject()

          return@use OpenedFilesCache(selectedFile, allFiles)
        }
      } catch (err: Exception) {
        log.error("Failed to parse opened files cache", err)
        null
      }
    }
  }
}


================================================
File: java/com/itsaky/androidide/models/ProjectTemplate.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/
package com.itsaky.androidide.models;

import android.content.Context;
import androidx.annotation.DrawableRes;
import androidx.annotation.StringRes;

public class ProjectTemplate {

  private int id;
  private String name;
  private String description;
  private boolean isSupportJava;
  private boolean isSupportKotlin;
  private boolean isCpp;

  @DrawableRes private int imageId;

  public ProjectTemplate() {}

  public ProjectTemplate(int id, String name, String description, int imageId) {
    this.id = id;
    this.name = name;
    this.description = description;
    this.imageId = imageId;
  }

  public int getId() {
    return id;
  }

  public ProjectTemplate setId(int id) {
    this.id = id;
    return this;
  }

  public ProjectTemplate setName(Context ctx, @StringRes int name) {
    return setName(ctx.getString(name));
  }

  public String getName() {
    return name;
  }

  public ProjectTemplate setName(String name) {
    this.name = name;
    return this;
  }

  public ProjectTemplate setDescription(Context ctx, @StringRes int desc) {
    return setDescription(ctx.getString(desc));
  }

  public String getDescription() {
    return description;
  }

  public ProjectTemplate setDescription(String description) {
    this.description = description;
    return this;
  }

  public int getImageId() {
    return imageId;
  }

  public ProjectTemplate setImageId(@DrawableRes int imageId) {
    this.imageId = imageId;
    return this;
  }

  public boolean isSupportJava() {
    return this.isSupportJava;
  }

  public ProjectTemplate setSupportJava(boolean isSupportJava) {
    this.isSupportJava = isSupportJava;
    return this;
  }

  public boolean isSupportKotlin() {
    return this.isSupportKotlin;
  }

  public ProjectTemplate setSupportKotlin(boolean isSupportKotlin) {
    this.isSupportKotlin = isSupportKotlin;
    return this;
  }

  public boolean isCpp() {
    return this.isCpp;
  }

  public ProjectTemplate setIsCpp(boolean isCpp) {
    this.isCpp = isCpp;
    return this;
  }
}



================================================
File: java/com/itsaky/androidide/models/RunTasksCategory.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.models

import androidx.annotation.StringRes
import com.itsaky.androidide.tooling.api.models.GradleTask

/** @author Akash Yadav */
data class RunTasksCategory(@StringRes val title: Int, val tasks: List<Checkable<GradleTask>>)



================================================
File: java/com/itsaky/androidide/models/SearchResult.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/
package com.itsaky.androidide.models;

import java.io.File;

public class SearchResult extends Range {
  public File file;
  public String line;
  public String match;

  public SearchResult(Range src, File file, String line, String match) {
    super(src.getStart(), src.getEnd());
    this.file = file;
    this.line = line;
    this.match = match;
  }
}



================================================
File: java/com/itsaky/androidide/models/Symbol.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.models

/**
 * A symbol that is shown in the [SymbolInputView][com.itsaky.androidide.ui.SymbolInputView].
 *
 * @author Akash Yadav
 */
open class Symbol @JvmOverloads constructor(
  open val label: String,
  open val commit: String,
  open val offset: Int = 1,
  open val description: String = label
) {
  @JvmOverloads
  constructor(both: String, offset: Int = 1) : this(both, both, offset)

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is Symbol) return false

    if (label != other.label) return false
    if (commit != other.commit) return false
    if (offset != other.offset) return false
    if (description != other.description) return false

    return true
  }

  override fun hashCode(): Int {
    var result = label.hashCode()
    result = 31 * result + commit.hashCode()
    result = 31 * result + offset
    result = 31 * result + description.hashCode()
    return result
  }

  override fun toString(): String {
    return "Symbol(label='$label', commit='$commit', offset=$offset, description='$description')"
  }
}


================================================
File: java/com/itsaky/androidide/preferences/GitHubPreferences.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import androidx.preference.Preference
import com.google.android.material.textfield.TextInputLayout
import com.itsaky.androidide.preferences.internal.GITHUB_USERNAME
import com.itsaky.androidide.preferences.internal.GITHUB_EMAIL
import com.itsaky.androidide.preferences.internal.GITHUB_PAT
import com.itsaky.androidide.preferences.internal.githubEmail
import com.itsaky.androidide.preferences.internal.githubPAT
import com.itsaky.androidide.preferences.internal.githubUsername
import com.itsaky.androidide.resources.R
import kotlinx.parcelize.IgnoredOnParcel
import kotlinx.parcelize.Parcelize

//@Parcelize
//    class GithubPreferences(
//        override val key: String = "idepref_github",
//        override val title: Int = R.string.title_github,
//        override val summary: Int? = R.string.idepref_github_summary,
//        override val children: List<IPreference> = mutableListOf()
//    ) : IPreferenceScreen() {
//
//        init {
//            addPreference(GithubConfig())
//        }
//    }
//
//    @Parcelize
//    class GithubConfig(
//        override val key: String = "idepref_github_interface",
//        override val title: Int = R.string.title_github,
//        override val children: List<IPreference> = mutableListOf(),
//    ) : IPreferenceGroup() {
//
//        init {
//            addPreference(Username())
//            addPreference(Email())
//            addPreference(PersonalAccessToken())
//        }
//    }
//
//@Parcelize
//class Username(
//    override val key: String = GITHUB_USERNAME,
//    override val title: Int = com.itsaky.androidide.R.string.idepref_github_username,
//    override val summary: Int? = com.itsaky.androidide.R.string.idepref_github_username_summary,
//    override val icon: Int? = com.itsaky.androidide.R.drawable.ic_github
//) : EditTextPreference() {
//
//    @IgnoredOnParcel
//    override val dialogCancellable = true
//
//    override fun onPreferenceChanged(preference: Preference, newValue: Any?): Boolean {
//        githubUsername = newValue as String? ?: ""
//        return true
//    }
//
//    override fun onConfigureTextInput(input: TextInputLayout) {
//        input.setStartIconDrawable(R.drawable.ic_gradle)
//        input.setHint(R.string.msg_github_username)
//        input.isCounterEnabled = false
//        input.editText!!.setText("")
//    }
//}
//
//@Parcelize
//class Email(
//    override val key: String = GITHUB_EMAIL,
//    override val title: Int = com.itsaky.androidide.R.string.idepref_github_email,
//    override val summary: Int? = com.itsaky.androidide.R.string.idepref_github_email_summary,
//    override val icon: Int? = com.itsaky.androidide.R.drawable.ic_github
//) : EditTextPreference() {
//
//    @IgnoredOnParcel
//    override val dialogCancellable = true
//
//    override fun onPreferenceChanged(preference: Preference, newValue: Any?): Boolean {
//        githubEmail = newValue as String? ?: ""
//        return true
//    }
//
//    override fun onConfigureTextInput(input: TextInputLayout) {
//        input.setStartIconDrawable(R.drawable.ic_gradle)
//        input.setHint(R.string.msg_github_email)
//        input.isCounterEnabled = false
//        input.editText!!.setText("")
//    }
//}
//
//@Parcelize
//    class PersonalAccessToken(
//        override val key: String = GITHUB_PAT,
//        override val title: Int = com.itsaky.androidide.R.string.idepref_github_pat,
//        override val summary: Int? = com.itsaky.androidide.R.string.idepref_github_pat_summary,
//        override val icon: Int? = com.itsaky.androidide.R.drawable.ic_github
//    ) : EditTextPreference() {
//
//        @IgnoredOnParcel
//        override val dialogCancellable = true
//
//        override fun onPreferenceChanged(preference: Preference, newValue: Any?): Boolean {
//            githubPAT = newValue as String? ?: ""
//            return true
//        }
//
//        override fun onConfigureTextInput(input: TextInputLayout) {
//            input.setStartIconDrawable(R.drawable.ic_gradle)
//            input.setHint(R.string.msg_github_pat)
//            input.isCounterEnabled = false
//            input.editText!!.setText("")
//        }
//    }
//
//
//



================================================
File: java/com/itsaky/androidide/preferences/aboutPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import android.content.Intent
import com.itsaky.androidide.activities.AboutActivity
import com.itsaky.androidide.app.IDEApplication
import com.itsaky.androidide.resources.R

private const val KEY_CHANGELOG = "idepref_changelog"
private const val KEY_ABOUT = "idepref_about"

val changelog =
  SimpleClickablePreference(
    key = KEY_CHANGELOG,
    title = R.string.pref_changelog,
    summary = R.string.idepref_changelog_summary
  ) {
    IDEApplication.instance.showChangelog()
    true
  }
val about =
  SimpleClickablePreference(
    key = KEY_ABOUT,
    title = R.string.idepref_about_title,
    summary = R.string.idepref_about_summary
  ) {
    it.context.startActivity(Intent(it.context, AboutActivity::class.java))
    true
  }


================================================
File: java/com/itsaky/androidide/preferences/buildAndRunPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import com.itsaky.androidide.R
import com.itsaky.androidide.preferences.internal.BuildPreferences.GRADLE_COMMANDS
import com.itsaky.androidide.preferences.internal.BuildPreferences.LAUNCH_APP_AFTER_INSTALL
import com.itsaky.androidide.preferences.internal.BuildPreferences.isBuildCacheEnabled
import com.itsaky.androidide.preferences.internal.BuildPreferences.isDebugEnabled
import com.itsaky.androidide.preferences.internal.BuildPreferences.isInfoEnabled
import com.itsaky.androidide.preferences.internal.BuildPreferences.isOfflineEnabled
import com.itsaky.androidide.preferences.internal.BuildPreferences.isScanEnabled
import com.itsaky.androidide.preferences.internal.BuildPreferences.isStacktraceEnabled
import com.itsaky.androidide.preferences.internal.BuildPreferences.isWarningModeAllEnabled
import com.itsaky.androidide.preferences.internal.BuildPreferences.launchAppAfterInstall
import com.itsaky.androidide.resources.R.drawable
import com.itsaky.androidide.resources.R.string
import kotlinx.parcelize.Parcelize
import kotlin.reflect.KMutableProperty0

@Parcelize
class BuildAndRunPreferences(
    override val key: String = "idepref_build_n_run",
    override val title: Int = string.idepref_build_title,
    override val summary: Int? = string.idepref_buildnrun_summary,
    override val children: List<IPreference> = mutableListOf(),
) : IPreferenceScreen() {

    init {
        addPreference(GradleOptions())
        addPreference(RunOptions())
    }
}

@Parcelize
private class GradleOptions(
    override val key: String = "idepref_build_gradle",
    override val title: Int = string.gradle,
    override val children: List<IPreference> = mutableListOf(),
) : IPreferenceGroup() {

  init {
    addPreference(GradleCommands())
  }
}

@Parcelize
private class GradleCommands(
    override val key: String = GRADLE_COMMANDS,
    override val title: Int = string.idepref_build_customgradlecommands_title,
    override val summary: Int? = string.idepref_build_customgradlecommands_summary,
    override val icon: Int? = drawable.ic_bash_commands,
) : PropertyBasedMultiChoicePreference() {

    override fun getProperties(): Map<String, KMutableProperty0<Boolean>> {
        return linkedMapOf(
            "--stacktrace" to ::isStacktraceEnabled,
            "--info" to ::isInfoEnabled,
            "--debug" to ::isDebugEnabled,
            "--scan" to ::isScanEnabled,
            "--warning-mode all" to ::isWarningModeAllEnabled,
            "--build-cache" to ::isBuildCacheEnabled,
            "--offline" to ::isOfflineEnabled,
        )
    }
}


@Parcelize
private class RunOptions(
    override val key: String = "ide.build.runOptions",
    override val title: Int = R.string.title_run_options,
    override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

    init {
        addPreference(LaunchAppAfterInstall())
    }
}

@Parcelize
private class LaunchAppAfterInstall(
    override val key: String = LAUNCH_APP_AFTER_INSTALL,
    override val title: Int = R.string.idepref_launchAppAfterInstall_title,
    override val summary: Int? = R.string.idepref_launchAppAfterInstall_summary,
    override val icon: Int? = drawable.ic_open_external
) :
  SwitchPreference(setValue = ::launchAppAfterInstall::set, getValue = ::launchAppAfterInstall::get)



================================================
File: java/com/itsaky/androidide/preferences/commonPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import androidx.preference.Preference
import com.itsaky.androidide.utils.uncheckedCast
import kotlin.reflect.KMutableProperty0

internal abstract class PropertyBasedMultiChoicePreference : MultiChoicePreference() {

  abstract fun getProperties(): Map<String, KMutableProperty0<Boolean>>

  override fun getEntries(preference: Preference): Array<PreferenceChoices.Entry> {
    val properties = getProperties()
    val entries = Array(properties.size) { PreferenceChoices.Entry.EMPTY }

    var index = 0
    properties.forEach { (key, property) ->
      entries[index] = PreferenceChoices.Entry(key, property.get(), property)
      ++index
    }

    return entries
  }

  override fun onChoicesConfirmed(
    preference: Preference,
    entries: Array<PreferenceChoices.Entry>
  ) {
    entries.forEach { entry ->
      uncheckedCast<KMutableProperty0<Boolean>>(entry.data).set(entry.isChecked)
    }
  }
}


================================================
File: java/com/itsaky/androidide/preferences/developerOptionsPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import com.itsaky.androidide.R
import com.itsaky.androidide.preferences.internal.DevOpsPreferences
import kotlinx.parcelize.Parcelize

@Parcelize
internal class DeveloperOptionsScreen(
  override val key: String = DevOpsPreferences.KEY_DEVOPTS,
  override val title: Int = R.string.title_developer_options,
  override val summary: Int? = R.string.idepref_devOptions_summary,
  override val children: List<IPreference> = mutableListOf()) : IPreferenceScreen() {

  init {
    addPreference(DebuggingPreferences())
  }
}

@Parcelize
internal class DebuggingPreferences(
  override val key: String = DevOpsPreferences.KEY_DEVOPTS_DEBUGGING,
  override val title: Int = R.string.idepref_group_debugging,
  override val children: List<IPreference> = mutableListOf()) : IPreferenceGroup() {

  init {
    addPreference(DumpLogsPreference())
    addPreference(EnableLogSenderPreference())
  }
}

@Parcelize
internal class DumpLogsPreference(
  override val key: String = DevOpsPreferences.KEY_DEVOPTS_DEBUGGING_DUMPLOGS,
  override val title: Int = R.string.idepref_devOptions_dumpLogs_title,
  override val summary: Int? = R.string.idepref_devOptions_dumpLogs_summary) :
  SwitchPreference(setValue = DevOpsPreferences::dumpLogs::set,
    getValue = DevOpsPreferences::dumpLogs::get)

@Parcelize
internal class EnableLogSenderPreference(
  override val key: String = DevOpsPreferences.KEY_DEVOPTS_DEBUGGING_ENABLE_LOGSENDER,
  override val title: Int = R.string.idepref_devOptions_enableLogsender_title,
  override val summary: Int? = R.string.idepref_devOptions_enableLogsender_summary) :
  SwitchPreference(setValue = DevOpsPreferences::logsenderEnabled::set,
    getValue = DevOpsPreferences::logsenderEnabled::get)


================================================
File: java/com/itsaky/androidide/preferences/editorPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import android.view.LayoutInflater
import androidx.preference.Preference
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.itsaky.androidide.R
import com.itsaky.androidide.databinding.LayoutTextSizeSliderBinding
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.editor.schemes.IDEColorSchemeProvider
import com.itsaky.androidide.preferences.internal.EditorPreferences
import com.itsaky.androidide.preferences.internal.EditorPreferences.AUTO_SAVE
import com.itsaky.androidide.preferences.internal.EditorPreferences.COLOR_SCHEME
import com.itsaky.androidide.preferences.internal.EditorPreferences.COMPLETIONS_MATCH_LOWER
import com.itsaky.androidide.preferences.internal.EditorPreferences.DEFAULT_COLOR_SCHEME
import com.itsaky.androidide.preferences.internal.EditorPreferences.DELETE_EMPTY_LINES
import com.itsaky.androidide.preferences.internal.EditorPreferences.DELETE_TABS_ON_BACKSPACE
import com.itsaky.androidide.preferences.internal.EditorPreferences.FLAG_PASSWORD
import com.itsaky.androidide.preferences.internal.EditorPreferences.FONT_LIGATURES
import com.itsaky.androidide.preferences.internal.EditorPreferences.FONT_SIZE
import com.itsaky.androidide.preferences.internal.EditorPreferences.PIN_LINE_NUMBERS
import com.itsaky.androidide.preferences.internal.EditorPreferences.PRINTABLE_CHARS
import com.itsaky.androidide.preferences.internal.EditorPreferences.STICKY_SCROLL_ENABLED
import com.itsaky.androidide.preferences.internal.EditorPreferences.TAB_SIZE
import com.itsaky.androidide.preferences.internal.EditorPreferences.USE_CUSTOM_FONT
import com.itsaky.androidide.preferences.internal.EditorPreferences.USE_ICU
import com.itsaky.androidide.preferences.internal.EditorPreferences.USE_MAGNIFER
import com.itsaky.androidide.preferences.internal.EditorPreferences.USE_SOFT_TAB
import com.itsaky.androidide.preferences.internal.EditorPreferences.WORD_WRAP
import com.itsaky.androidide.resources.R.drawable
import com.itsaky.androidide.resources.R.string
import kotlinx.parcelize.IgnoredOnParcel
import kotlinx.parcelize.Parcelize
import kotlin.reflect.KMutableProperty0

@Parcelize
class EditorPreferencesScreen(
  override val key: String = "idepref_editor",
  override val title: Int = string.idepref_editor_title,
  override val summary: Int? = string.idepref_editor_summary,
  override val children: List<IPreference> = mutableListOf(),
) : IPreferenceScreen() {

  init {
    addPreference(CommonConfigurations())
    addPreference(JavaCodeConfigurations())
    addPreference(XMLPreferencesScreen())
  }
}

@Parcelize
private class CommonConfigurations(
  override val key: String = "idepref_editor_common",
  override val title: Int = string.idepref_editor_category_common,
  override val children: List<IPreference> = mutableListOf(),
) : IPreferenceGroup() {

  init {
    addPreference(TextSize())
    addPreference(TabSize())
    addPreference(NonPrintablePaintingFlags())
    addPreference(UseSoftTab())
    addPreference(WordWrap())
    addPreference(UseMagnifier())
    addPreference(UseICU())
    addPreference(AutoSave())
    addPreference(DeleteEmptyLines())
    addPreference(DeleteTabs())
    addPreference(StickyScrollEnabled())
    addPreference(PinLineNumbersEnabled())
    addPreference(CompletionsMatchLower())
  }
}

@Parcelize
private class TextSize(
  override val key: String = FONT_SIZE,
  override val title: Int = string.idepref_editor_fontsize_title,
  override val summary: Int? = string.idepref_editor_fontsize_summary,
  override val icon: Int? = drawable.ic_text_size,
  override val dialogTitle: Int = string.title_change_text_size,
  override val dialogMessage: Int? = string.msg_editor_font_size,
) : DialogPreference() {

  override fun onConfigureDialog(preference: Preference, dialog: MaterialAlertDialogBuilder) {
    val binding = LayoutTextSizeSliderBinding.inflate(LayoutInflater.from(preference.context))
    var size = EditorPreferences.fontSize
    if (size < 6 || size > 32) {
      size = 14f
    }
    changeTextSize(binding, size)
    binding.slider.setLabelFormatter { it.toString() }

    dialog.setView(binding.root)
    dialog.setPositiveButton(android.R.string.ok) { iface, _ ->
      iface.dismiss()
      changeTextSize(binding, binding.slider.value)
    }
    dialog.setNegativeButton(android.R.string.cancel, null)
    dialog.setNeutralButton(string.reset) { iface, _ ->
      iface.dismiss()
      changeTextSize(binding, 14f)
    }
  }

  private fun changeTextSize(binding: LayoutTextSizeSliderBinding, size: Float) {
    EditorPreferences.fontSize = size
    binding.slider.value = size
  }
}

@Parcelize
private class UseSoftTab(
  override val key: String = USE_SOFT_TAB,
  override val title: Int = string.idepref_editor_useSoftTabs_title,
  override val summary: Int? = string.idepref_editor_useSoftTabs_summary,
  override val icon: Int? = drawable.ic_space,
) : SwitchPreference(setValue = EditorPreferences::useSoftTab::set,
  getValue = EditorPreferences::useSoftTab::get)

@Parcelize
private class TabSize(
  override val key: String = TAB_SIZE,
  override val title: Int = string.title_tab_size,
  override val summary: Int? = string.msg_tab_size,
  override val icon: Int? = drawable.ic_tab,
) : SingleChoicePreference() {

  @IgnoredOnParcel
  override val dialogCancellable = true

  @IgnoredOnParcel
  private val tabSizes = intArrayOf(2, 4, 6, 8)

  override fun getEntries(preference: Preference): Array<PreferenceChoices.Entry> {
    val currentTabSize = EditorPreferences.tabSize
    return Array(tabSizes.size) { index ->
      PreferenceChoices.Entry(
        label = tabSizes[index].toString(),
        _isChecked = currentTabSize == tabSizes[index],
        data = tabSizes[index]
      )
    }
  }

  override fun onChoiceConfirmed(
    preference: Preference,
    entry: PreferenceChoices.Entry?,
    position: Int
  ) {
    EditorPreferences.tabSize = (entry?.data as? Int?) ?: 4
  }
}

@Parcelize
private class NonPrintablePaintingFlags(
  override val key: String = PRINTABLE_CHARS,
  override val title: Int = string.idepref_editor_paintingflags_title,
  override val summary: Int? = string.idepref_editor_paintingflags_summary,
  override val icon: Int? = drawable.ic_drawing,
) : PropertyBasedMultiChoicePreference() {

  override fun getProperties(): Map<String, KMutableProperty0<Boolean>> {
    return linkedMapOf(
      "Leading" to EditorPreferences::drawLeadingWs,
      "Trailing" to EditorPreferences::drawTrailingWs,
      "Inner" to EditorPreferences::drawInnerWs,
      "Empty lines" to EditorPreferences::drawEmptyLineWs,
      "Line breaks" to EditorPreferences::drawLineBreak
    )
  }
}

@Parcelize
private class WordWrap(
  override val key: String = WORD_WRAP,
  override val title: Int = string.idepref_editor_word_wrap_title,
  override val summary: Int? = string.idepref_editor_word_wrap_summary,
  override val icon: Int? = drawable.ic_wrap_text,
) : SwitchPreference(setValue = EditorPreferences::wordwrap::set,
  getValue = EditorPreferences::wordwrap::get)

@Parcelize
private class UseMagnifier(
  override val key: String = USE_MAGNIFER,
  override val title: Int = string.idepref_editor_use_magnifier_title,
  override val summary: Int? = string.idepref_editor_use_magnifier_summary,
  override val icon: Int? = drawable.ic_loupe,
) : SwitchPreference(setValue = EditorPreferences::useMagnifier::set,
  getValue = EditorPreferences::useMagnifier::get)

@Parcelize
private class AutoSave(
  override val key: String = AUTO_SAVE,
  override val title: Int = string.idepref_editor_autoSave_title,
  override val summary: Int? = string.idepref_editor_autoSave_summary,
  override val icon: Int? = drawable.ic_save,
) : SwitchPreference(setValue = EditorPreferences::autoSave::set,
  getValue = EditorPreferences::autoSave::get)

@Parcelize
private class CompletionsMatchLower(
  override val key: String = COMPLETIONS_MATCH_LOWER,
  override val title: Int = string.idepref_java_matchLower_title,
  override val summary: Int? = string.idepref_java_matchLower_summary,
  override val icon: Int? = drawable.ic_text_lower,
) : SwitchPreference(
  setValue = EditorPreferences::completionsMatchLower::set,
  getValue = EditorPreferences::completionsMatchLower::get
)

@Parcelize
private class UseICU(
  override val key: String = USE_ICU,
  override val title: Int = string.idepref_useIcu_title,
  override val summary: Int? = string.idepref_useIcu_summary,
  override val icon: Int? = drawable.ic_expand_selection,
) : SwitchPreference(setValue = EditorPreferences::useIcu::set,
  getValue = EditorPreferences::useIcu::get)

@Parcelize
private class DeleteEmptyLines(
  override val key: String = DELETE_EMPTY_LINES,
  override val title: Int = R.string.idepref_deleteEmptyLines_title,
  override val summary: Int? = R.string.idepref_deleteEmptyLines_summary,
  override val icon: Int? = drawable.ic_backspace
) : SwitchPreference(setValue = EditorPreferences::deleteEmptyLines::set,
  getValue = EditorPreferences::deleteEmptyLines::get)

@Parcelize
private class DeleteTabs(
  override val key: String = DELETE_TABS_ON_BACKSPACE,
  override val title: Int = R.string.idepref_deleteTabs_title,
  override val summary: Int? = R.string.idepref_deleteTabs_summary,
  override val icon: Int? = drawable.ic_backspace
) :
  SwitchPreference(setValue = EditorPreferences::deleteTabsOnBackspace::set,
    getValue = EditorPreferences::deleteTabsOnBackspace::get)

@Parcelize
private class StickyScrollEnabled(
  override val key: String = STICKY_SCROLL_ENABLED,
  override val title: Int = R.string.idepref_editor_stickScroll_title,
  override val summary: Int? = R.string.idepref_editor_stickyScroll_summary,
  override val icon: Int? = drawable.ic_sticky_scroll
) : SwitchPreference(setValue = EditorPreferences::stickyScrollEnabled::set,
  getValue = EditorPreferences::stickyScrollEnabled::get)

@Parcelize
private class PinLineNumbersEnabled(
  override val key: String = PIN_LINE_NUMBERS,
  override val title: Int = R.string.idepref_editor_pinLineNumbers_title,
  override val summary: Int? = R.string.idepref_editor_pinLineNumbers_summary,
  override val icon: Int? = drawable.ic_pin
) : SwitchPreference(setValue = EditorPreferences::pinLineNumbers::set,
  getValue = EditorPreferences::pinLineNumbers::get)



================================================
File: java/com/itsaky/androidide/preferences/generalPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import android.content.Context
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.content.ContextCompat
import androidx.preference.Preference
import com.itsaky.androidide.R
import com.itsaky.androidide.preferences.internal.GeneralPreferences
import com.itsaky.androidide.resources.R.drawable
import com.itsaky.androidide.resources.R.string
import com.itsaky.androidide.resources.localization.LocaleProvider
import com.itsaky.androidide.ui.themes.IDETheme
import com.itsaky.androidide.ui.themes.IThemeManager
import kotlinx.parcelize.IgnoredOnParcel
import kotlinx.parcelize.Parcelize

@Parcelize
class GeneralPreferencesScreen(
  override val key: String = "idepref_general",
  override val title: Int = string.title_general,
  override val summary: Int? = string.idepref_general_summary,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceScreen() {

  init {
    addPreference(InterfaceConfig())
    addPreference(ProjectConfig())
  }
}

@Parcelize
class InterfaceConfig(
  override val key: String = "idepref_general_interface",
  override val title: Int = string.title_interface,
  override val children: List<IPreference> = mutableListOf(),
) : IPreferenceGroup() {

  init {
    addPreference(UiMode())
    addPreference(LocaleSelector())
  }
}

@Parcelize
class ProjectConfig(
  override val key: String = "idepref_general_project",
  override val title: Int = R.string.idepref_general_projectConfig,
  override val children: List<IPreference> = mutableListOf(),
) : IPreferenceGroup() {

  init {
    addPreference(OpenLastProject())
    addPreference(ConfirmProjectOpen())
  }
}

@Parcelize
class UiMode(
  override val key: String = GeneralPreferences.UI_MODE,
  override val title: Int = R.string.idepref_general_uiMode,
  override val summary: Int? = R.string.idepref_general_uiMode_summary,
  override val icon: Int? = R.drawable.ic_ui_mode
) : SingleChoicePreference() {

  @IgnoredOnParcel
  override val dialogCancellable = true

  override fun getEntries(preference: Preference): Array<PreferenceChoices.Entry> {
    val context = preference.context
    val currentUiMode = GeneralPreferences.uiMode

    return Array(3) { index ->
      val (label, mode) = when (index) {
        0 -> context.getString(R.string.uiMode_light) to AppCompatDelegate.MODE_NIGHT_NO
        1 -> context.getString(R.string.uiMode_dark) to AppCompatDelegate.MODE_NIGHT_YES
        2 -> context.getString(R.string.uiMode_system) to AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM
        else -> throw IllegalStateException("Invalid index")
      }

      PreferenceChoices.Entry(label, currentUiMode == mode, mode)
    }
  }

  override fun onChoiceConfirmed(
    preference: Preference,
    entry: PreferenceChoices.Entry?,
    position: Int
  ) {
    GeneralPreferences.uiMode = (entry?.data as? Int?) ?: AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM
  }
}

@Parcelize
class LocaleSelector(
  override val key: String = GeneralPreferences.SELECTED_LOCALE,
  override val title: Int = R.string.idepref_general_localeSelector_title,
  override val summary: Int? = R.string.idepref_general_localeSelector_summary,
  override val icon: Int? = R.drawable.ic_translate
) : SingleChoicePreference() {

  override fun getEntries(preference: Preference): Array<PreferenceChoices.Entry> {
    val context = preference.context
    val currentLocale = GeneralPreferences.selectedLocale
    val supportedLocales = LocaleProvider.SUPPORTED_LOCALES.keys.toList()
    return Array(supportedLocales.size + 1) { index ->
      if (index == 0) {
        PreferenceChoices.Entry(
          label = ContextCompat.getString(context, R.string.locale_system_default),
          _isChecked = GeneralPreferences.selectedLocale == null,
          data = 0
        )
      } else {
        val localeKey = supportedLocales[index - 1]
        val locale = LocaleProvider.getLocale(localeKey)!!
        PreferenceChoices.Entry(
          label = locale.getDisplayName(locale),
          _isChecked = currentLocale == localeKey,
          data = localeKey
        )
      }
    }
  }

  override fun onChoiceConfirmed(
    preference: Preference,
    entry: PreferenceChoices.Entry?,
    position: Int
  ) {
    GeneralPreferences.selectedLocale = entry?.data?.let { localeKey ->
      if (localeKey is Int) null else localeKey as String
    }
  }
}

@Parcelize
class OpenLastProject(
  override val key: String = GeneralPreferences.OPEN_PROJECTS,
  override val title: Int = string.title_open_projects,
  override val summary: Int? = string.msg_open_projects,
  override val icon: Int? = drawable.ic_open_project
) : SwitchPreference() {

  override fun onCreatePreference(context: Context): Preference {
    val pref = super.onCreatePreference(context) as androidx.preference.SwitchPreference
    pref.isChecked = GeneralPreferences.autoOpenProjects
    return pref
  }

  override fun onPreferenceChanged(preference: Preference, newValue: Any?): Boolean {
    GeneralPreferences.autoOpenProjects = newValue as Boolean?
      ?: GeneralPreferences.autoOpenProjects
    return true
  }
}

@Parcelize
class ConfirmProjectOpen(
  override val key: String = GeneralPreferences.CONFIRM_PROJECT_OPEN,
  override val title: Int = string.title_confirm_project_open,
  override val summary: Int? = string.msg_confirm_project_open,
  override val icon: Int? = drawable.ic_open_project
) : SwitchPreference() {

  override fun onCreatePreference(context: Context): Preference {
    val pref = super.onCreatePreference(context) as androidx.preference.SwitchPreference
    pref.isChecked = GeneralPreferences.confirmProjectOpen
    return pref
  }

  override fun onPreferenceChanged(preference: Preference, newValue: Any?): Boolean {
    GeneralPreferences.confirmProjectOpen = newValue as Boolean?
      ?: GeneralPreferences.confirmProjectOpen
    return true
  }
}

@Parcelize
class UseSytemShell(
  override val key: String = GeneralPreferences.TERMINAL_USE_SYSTEM_SHELL,
  override val title: Int = string.title_default_shell,
  override val summary: Int? = string.msg_default_shell,
  override val icon: Int? = drawable.ic_bash_commands
) : SwitchPreference() {

  override fun onCreatePreference(context: Context): Preference {
    val pref = super.onCreatePreference(context) as androidx.preference.SwitchPreference
    pref.isChecked = GeneralPreferences.useSystemShell
    return pref
  }

  override fun onPreferenceChanged(preference: Preference, newValue: Any?): Boolean {
    GeneralPreferences.useSystemShell = newValue as Boolean? ?: GeneralPreferences.useSystemShell
    return true
  }
}



================================================
File: java/com/itsaky/androidide/preferences/javaPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import com.itsaky.androidide.R
import com.itsaky.androidide.preferences.internal.JavaPreferences
import com.itsaky.androidide.resources.R.drawable
import com.itsaky.androidide.resources.R.string
import kotlinx.parcelize.Parcelize

@Parcelize
internal class JavaCodeConfigurations(
  override val key: String = "idepref_editor_java",
  override val title: Int = string.idepref_editor_category_java,
  override val children: List<IPreference> = mutableListOf(),
) : IPreferenceGroup() {

  init {
    addPreference(GoogleCodeStyle())
  }
}

/** @author Akash Yadav */
@Parcelize
private class GoogleCodeStyle(
  override val key: String = JavaPreferences.GOOGLE_CODE_STYLE,
  override val title: Int = string.idepref_java_useGoogleStyle_title,
  override val summary: Int? = string.idepref_java_useGoogleStyle_summary,
  override val icon: Int? = drawable.ic_format_code,
) : SwitchPreference(getValue = JavaPreferences::googleCodeStyle::get,
  setValue = JavaPreferences::googleCodeStyle::set)



================================================
File: java/com/itsaky/androidide/preferences/rootPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import com.itsaky.androidide.resources.R.string
import kotlinx.parcelize.Parcelize

internal fun IDEPreferences.addRootPreferences() {
  addPreference(ConfigurationPreferences())
  addPreference(GitHubPreferences())
  addPreference(PrivacyPreferences())
  addPreference(DeveloperOptionsPreferences())
  addPreference(AboutPreferences())
}

@Parcelize
class ConfigurationPreferences(
  override val key: String = "idepref_configure",
  override val title: Int = string.configure,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    addPreference(GeneralPreferencesScreen())
    addPreference(EditorPreferencesScreen())
    addPreference(BuildAndRunPreferences())
    addPreference(TermuxPreferences())
  }
}

@Parcelize
class PrivacyPreferences(
  override val key: String = "idepref_privacy",
  override val title: Int = string.title_privacy,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
//    addPreference(StatPreferencesScreen())
  }
}

@Parcelize
class DeveloperOptionsPreferences(
  override val key: String = "idepref_devOpts",
  override val title: Int = string.title_developer_options,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    addPreference(DeveloperOptionsScreen())
  }
}

@Parcelize
class AboutPreferences(
  override val key: String = "idepref_category_about",
  override val title: Int = string.about,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    addPreference(changelog)
    addPreference(about)
  }
}

@Parcelize
class GitHubPreferences(
  override val key: String = "idepref_category_github",
  override val title: Int = string.github,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    //addPreference(GithubPreferences())
  }
}



================================================
File: java/com/itsaky/androidide/preferences/statPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *  
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import android.content.Context
import androidx.preference.Preference
import com.itsaky.androidide.preferences.internal.StatPreferences
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.stats.AndroidIDEStats
import com.itsaky.androidide.stats.StatUploadWorker
import kotlinx.parcelize.Parcelize

//@Parcelize
//class StatPreferencesScreen(
//  override val key: String = "idepref_stats",
//  override val title: Int = R.string.title_androidide_statistics,
//  override val summary: Int? = R.string.summary_anonymous_usage_stats,
//  override val children: List<IPreference> = mutableListOf()
//) : IPreferenceScreen() {
//
//  init {
//    addPreference(StatsCollection())
//    addPreference(PreviewDataPreferences())
//  }
//}
//
//@Parcelize
//class StatsCollection(
//  override val key: String = StatPreferences.STAT_OPT_IN,
//  override val title: Int = R.string.idepref_stats_optIn_title,
//  override val summary: Int? = R.string.idepref_stats_optIn_summary,
//  override val icon: Int? = null
//) : SwitchPreference(setValue = StatPreferences::statOptIn::set,
//  getValue = StatPreferences::statOptIn::get)
//
//@Parcelize
//class PreviewDataPreferences(
//  override val key: String = "idepref_privacy",
//  override val title: Int = R.string.title_preview_data,
//  override val children: List<IPreference> = mutableListOf()
//) : IPreferenceGroup() {
//
//  init {
//    addPreference(UniqueID())
//    addPreference(DeviceName())
//    addPreference(AndroidVersion())
//    addPreference(AppVersion())
//    addPreference(CpuArch())
//    addPreference(Country())
//  }
//}
//
//private abstract class StatDataPreference(
//  private val getValue: () -> String
//) : SimplePreference() {
//
//  override val summary: Int? = null
//  override val icon: Int? = null
//
//  override fun onCreatePreference(context: Context): Preference {
//    return super.onCreatePreference(context).apply {
//      summary = getValue()
//    }
//  }
//}
//
//@Parcelize
//private class UniqueID(
//  override val key: String = StatUploadWorker.KEY_DEVICE_ID,
//  override val title: Int = R.string.title_unique_id,
//) : StatDataPreference({ AndroidIDEStats.uniqueDeviceId })
//
//@Parcelize
//private class DeviceName(
//  override val key: String = StatUploadWorker.KEY_DEVICE_NAME,
//  override val title: Int = R.string.title_device
//) : StatDataPreference({ AndroidIDEStats.deviceModel })
//
//@Parcelize
//private class AndroidVersion(
//  override val key: String = StatUploadWorker.KEY_ANDROID_VERSION,
//  override val title: Int = R.string.title_android_version
//) : StatDataPreference({ AndroidIDEStats.androidVersion.toString() })
//
//@Parcelize
//private class AppVersion(
//  override val key: String = StatUploadWorker.KEY_APP_VERSION,
//  override val title: Int = R.string.title_app_version
//) : StatDataPreference({ AndroidIDEStats.appVersion })
//
//@Parcelize
//private class Country(
//  override val key: String = StatUploadWorker.KEY_DEVICE_COUNTRY,
//  override val title: Int = R.string.title_country
//) : StatDataPreference({ AndroidIDEStats.country })
//
//@Parcelize
//private class CpuArch(
//  override val key: String = StatUploadWorker.KEY_APP_CPU_ARCH,
//  override val title: Int = R.string.title_cpu_arch
//) : StatDataPreference({ AndroidIDEStats.cpuArch })


================================================
File: java/com/itsaky/androidide/preferences/termuxPrefsExt.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import android.content.Context
import androidx.annotation.StringRes
import androidx.core.content.ContextCompat
import androidx.preference.Preference
import com.itsaky.androidide.R
import com.itsaky.androidide.app.IDEApplication
import com.termux.shared.logger.Logger
import com.termux.shared.termux.settings.preferences.TermuxAppSharedPreferences
import kotlinx.parcelize.Parcelize
import kotlin.reflect.KMutableProperty0

private const val KEY_TERMUX_PREFERENCES = "ide.preferences.terminal"
private const val KEY_TERMUX_DEBUGGING_PREFERENCES = "${KEY_TERMUX_PREFERENCES}.debugging"
private const val KEY_TERMUX_DEBUGGING_LOG_LEVEL_PREFERENCE = "${KEY_TERMUX_DEBUGGING_PREFERENCES}.logLevel"
private const val KEY_TERMUX_DEBUGGING_TERMINAL_VIEW_KEY_LOGGING_PREFERENCE = "${KEY_TERMUX_DEBUGGING_PREFERENCES}.terminalViewKeyLogging"
private const val KEY_TERMUX_DEBUGGING_CRASH_REPORT_NOTIFICATIONS_PREFERENCE = "${KEY_TERMUX_DEBUGGING_PREFERENCES}.crashReportNotifications"
private const val KEY_TERMUX_KBD_PREFERENCES = "${KEY_TERMUX_PREFERENCES}.keyboard"
private const val KEY_TERMUX_KBD_SOFT_KDB_ENABLED_PREFERENCE = "${KEY_TERMUX_KBD_PREFERENCES}.softKeyboardEnabled"
private const val KEY_TERMUX_KBD_SOFT_KDB_ONLY_IF_NO_HARD_KBD_PREFERENCE = "${KEY_TERMUX_KBD_PREFERENCES}.softKbdOnlyIfNoHardKbd"
private const val KEY_TERMUX_VIEW_PREFERENCES = "${KEY_TERMUX_PREFERENCES}.view"
private const val KEY_TERMUX_VIEW_MARGIN_ADJUSTMENT_ENABLED_PREFERENCE = "${KEY_TERMUX_VIEW_PREFERENCES}.marginAdjustment"

abstract class TermuxSwitchPreference(
  @StringRes private val summaryOn: Int,
  @StringRes private val summaryOff: Int,
  property: KMutableProperty0<Boolean>
) : SwitchPreference(property) {

  override fun onCreatePreference(context: Context): Preference {
    return super.onCreatePreference(context).also { preference ->
      updateSummary(preference)
    }
  }

  override fun onPreferenceChanged(preference: Preference, newValue: Any?): Boolean {
    return super.onPreferenceChanged(preference, newValue).also {
      updateSummary(preference)
    }
  }

  private fun updateSummary(preference: Preference) {
    preference.summary = (if (getValue?.invoke() == true) {
      summaryOn
    } else {
      summaryOff
    }).let { summary ->
      ContextCompat.getString(preference.context, summary)
    }
  }
}

@Parcelize
class TermuxPreferences(
  override val key: String = KEY_TERMUX_PREFERENCES,
  override val title: Int = R.string.termux_preferences_title,
  override val summary: Int? = R.string.termux_preferences_summary,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceScreen() {

  init {
    addPreference(TermuxDebuggingPreferences())
    addPreference(TermuxKeyboardPreferences())
    addPreference(TermuxViewPreferences())
  }
}

@Parcelize
class TermuxDebuggingPreferences(
  override val key: String = KEY_TERMUX_DEBUGGING_PREFERENCES,
  override val title: Int = R.string.termux_debugging_preferences_title,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    addPreference(TermuxDebuggingLogLevelPreference())
    addPreference(TermuxDebuggingTerminalViewKeyLoggingPreference())
    addPreference(TermuxDebuggingCrashReportNotificationsPreference())
  }
}

@Parcelize
class TermuxDebuggingLogLevelPreference(
  override val key: String = KEY_TERMUX_DEBUGGING_LOG_LEVEL_PREFERENCE,
  override val title: Int = R.string.log_level_title,
  override val icon: Int? = R.drawable.ic_bug
) : SingleChoicePreference() {

  override fun getEntries(preference: Preference): Array<PreferenceChoices.Entry> {
    val logLevels = Logger.getLogLevelsArray()
    val logLevelLabels = Logger.getLogLevelLabelsArray(preference.context, logLevels, true)
    val currentLogLevel = TermuxAppSharedPreferences.build(preference.context, false)?.logLevel
      ?: Logger.DEFAULT_LOG_LEVEL
    return Array(logLevels.size) {
      PreferenceChoices.Entry(logLevelLabels[it], currentLogLevel == logLevels[it],
        logLevels[it])
    }
  }

  override fun onChoiceConfirmed(
    preference: Preference,
    entry: PreferenceChoices.Entry?,
    position: Int
  ) {
    val newLevel = (entry?.data as? Int?) ?: Logger.DEFAULT_LOG_LEVEL
    TermuxAppSharedPreferences.build(preference.context, false)
      ?.setLogLevel(preference.context, newLevel)

    preference.summary = Logger.getLogLevelLabel(preference.context, newLevel, true)
  }

  override fun onCreatePreference(context: Context): Preference {
    return super.onCreatePreference(context).also { preference ->
      val currentLogLevel = TermuxAppSharedPreferences.build(preference.context, false)?.logLevel
        ?: Logger.DEFAULT_LOG_LEVEL
      preference.summary = Logger.getLogLevelLabel(context, currentLogLevel, true)
    }
  }
}

private var isTerminalViewKeyLoggingEnabled: Boolean
  get() = TermuxAppSharedPreferences.build(IDEApplication.instance,
    true).isTerminalViewKeyLoggingEnabled
  set(value) {
    TermuxAppSharedPreferences.build(IDEApplication.instance,
      true).isTerminalViewKeyLoggingEnabled = value
  }

@Parcelize
class TermuxDebuggingTerminalViewKeyLoggingPreference(
  override val key: String = KEY_TERMUX_DEBUGGING_TERMINAL_VIEW_KEY_LOGGING_PREFERENCE,
  override val title: Int = R.string.termux_terminal_view_key_logging_enabled_title,
  override val icon: Int? = R.drawable.ic_keyboard,
) : TermuxSwitchPreference(
  summaryOn = R.string.termux_terminal_view_key_logging_enabled_on,
  summaryOff = R.string.termux_terminal_view_key_logging_enabled_off,
  property = ::isTerminalViewKeyLoggingEnabled
)

private var isTerminalCrashReportNotificationsEnabled: Boolean
  get() = TermuxAppSharedPreferences.build(IDEApplication.instance,
    true).areCrashReportNotificationsEnabled(false)
  set(value) {
    TermuxAppSharedPreferences.build(IDEApplication.instance,
      true).setCrashReportNotificationsEnabled(value)
  }

@Parcelize
class TermuxDebuggingCrashReportNotificationsPreference(
  override val key: String = KEY_TERMUX_DEBUGGING_CRASH_REPORT_NOTIFICATIONS_PREFERENCE,
  override val title: Int = R.string.termux_crash_report_notifications_enabled_title,
  override val icon: Int? = R.drawable.ic_bell,
) : TermuxSwitchPreference(
  summaryOn = R.string.termux_crash_report_notifications_enabled_on,
  summaryOff = R.string.termux_crash_report_notifications_enabled_off,
  property = ::isTerminalCrashReportNotificationsEnabled
)

@Parcelize
class TermuxKeyboardPreferences(
  override val key: String = KEY_TERMUX_KBD_PREFERENCES,
  override val title: Int = R.string.termux_keyboard_header,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    addPreference(TermuxKbdSoftKbdEnabledPreference())
    addPreference(TermuxKbdSoftKbdOnlyIfNoHardKbdEnabledPreference())
  }
}

private var isSoftKbdEnabled: Boolean
  get() = TermuxAppSharedPreferences.build(IDEApplication.instance,
    true).isSoftKeyboardEnabled
  set(value) {
    TermuxAppSharedPreferences.build(IDEApplication.instance,
      true).isSoftKeyboardEnabled = value
  }

@Parcelize
class TermuxKbdSoftKbdEnabledPreference(
  override val key: String = KEY_TERMUX_KBD_SOFT_KDB_ENABLED_PREFERENCE,
  override val title: Int = R.string.termux_soft_keyboard_enabled_title,
  override val icon: Int? = R.drawable.ic_keyboard_soft,
) : TermuxSwitchPreference(
  summaryOn = R.string.termux_soft_keyboard_enabled_on,
  summaryOff = R.string.termux_soft_keyboard_enabled_off,
  property = ::isSoftKbdEnabled
)

private var isSoftKbdOnlyIfNoHardKbdEnabled: Boolean
  get() = TermuxAppSharedPreferences.build(IDEApplication.instance,
    true).isSoftKeyboardEnabledOnlyIfNoHardware
  set(value) {
    TermuxAppSharedPreferences.build(IDEApplication.instance,
      true).isSoftKeyboardEnabledOnlyIfNoHardware = value
  }

@Parcelize
class TermuxKbdSoftKbdOnlyIfNoHardKbdEnabledPreference(
  override val key: String = KEY_TERMUX_KBD_SOFT_KDB_ONLY_IF_NO_HARD_KBD_PREFERENCE,
  override val title: Int = R.string.termux_soft_keyboard_enabled_only_if_no_hardware_title,
  override val icon: Int? = R.drawable.ic_keyboard,
) : TermuxSwitchPreference(
  summaryOn = R.string.termux_soft_keyboard_enabled_only_if_no_hardware_on,
  summaryOff = R.string.termux_soft_keyboard_enabled_only_if_no_hardware_off,
  property = ::isSoftKbdOnlyIfNoHardKbdEnabled
)

@Parcelize
class TermuxViewPreferences(
  override val key: String = KEY_TERMUX_VIEW_PREFERENCES,
  override val title: Int = R.string.termux_terminal_view_view_header,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    addPreference(TermuxViewMarginAdjustmentEnabledPreference())
  }
}

private var isViewMarginAdjustmentEnabled: Boolean
  get() = TermuxAppSharedPreferences.build(IDEApplication.instance,
    true).isTerminalMarginAdjustmentEnabled
  set(value) {
    TermuxAppSharedPreferences.build(IDEApplication.instance,
      true).setTerminalMarginAdjustment(value)
  }

@Parcelize
class TermuxViewMarginAdjustmentEnabledPreference(
  override val key: String = KEY_TERMUX_VIEW_MARGIN_ADJUSTMENT_ENABLED_PREFERENCE,
  override val title: Int = R.string.termux_terminal_view_terminal_margin_adjustment_title,
  override val icon: Int? = R.drawable.ic_space,
) : TermuxSwitchPreference(
  summaryOn = R.string.termux_terminal_view_terminal_margin_adjustment_on,
  summaryOff = R.string.termux_terminal_view_terminal_margin_adjustment_off,
  property = ::isViewMarginAdjustmentEnabled
)


================================================
File: java/com/itsaky/androidide/preferences/xmlPrefExts.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.preferences

import androidx.preference.Preference
import com.itsaky.androidide.preferences.internal.XmlPreferences
import com.itsaky.androidide.resources.R.string
import kotlinx.parcelize.IgnoredOnParcel
import kotlinx.parcelize.Parcelize
import org.eclipse.lemminx.dom.builder.EmptyElements

@Parcelize
class XMLPreferencesScreen(
  override val key: String = "idepref_editor_xml",
  override val title: Int = string.xml,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceGroup() {

  init {
    addPreference(XMLFormattingOptions())
  }
}

@Parcelize
private class XMLFormattingOptions(
  override val key: String = "idepref_xml_formattingOptions",
  override val title: Int = string.xml_formatting_options,
  override val summary: Int? = string.xml_formatting_options_summary,
  override val children: List<IPreference> = mutableListOf()
) : IPreferenceScreen() {

  init {
    addPreference(TrimFinalNewLines())
    addPreference(InsertFinalNewLine())
    addPreference(SplitAttributes())
    addPreference(JoinCDataLines())
    addPreference(JoinCommentLines())
    addPreference(JoinContentLines())
    addPreference(SpaceBeforeEmptyCloseTag())
    addPreference(PreserveEmptyContent())
    addPreference(PreserveAttributeLineBreaks())
    addPreference(ClosingBracketNewLine())
    addPreference(TrimTrailingWhitespace())
    addPreference(MaxLineWidth())
    addPreference(PreservedNewLines())
    addPreference(SplitAttributesIndentSize())
    addPreference(EmptyElementsBehavior())
  }
}

@Parcelize
private class TrimFinalNewLines(
  override val key: String = XmlPreferences.TRIM_FINAL_NEW_LINE,
  override val title: Int = string.idepref_xml_trimFinalNewLine_title,
  override val summary: Int? = string.idepref_xml_trimFinalNewLine_summary
) : SwitchPreference(setValue = XmlPreferences::trimFinalNewLine::set,
  getValue = XmlPreferences::trimFinalNewLine::get)

@Parcelize
private class InsertFinalNewLine(
  override val key: String = XmlPreferences.INSERT_FINAL_NEW_LINE,
  override val title: Int = string.idepref_xml_insertFinalNewLine_title,
  override val summary: Int? = string.idepref_xml_insertFinalNewLine_summary
) : SwitchPreference(setValue = XmlPreferences::insertFinalNewLine::set,
  getValue = XmlPreferences::insertFinalNewLine::get)

@Parcelize
private class SplitAttributes(
  override val key: String = XmlPreferences.SPLIT_ATTRIBUTES,
  override val title: Int = string.idepref_xml_splitAttributes_title,
  override val summary: Int? = string.idepref_xml_splitAttributes_summary
) : SwitchPreference(setValue = XmlPreferences::splitAttributes::set,
  getValue = XmlPreferences::splitAttributes::get)

@Parcelize
private class JoinCDataLines(
  override val key: String = XmlPreferences.JOIN_CDATA_LINES,
  override val title: Int = string.idepref_xml_joinCDataLines_title,
  override val summary: Int? = string.idepref_xml_joinCDataLines_summary
) : SwitchPreference(setValue = XmlPreferences::joinCDataLines::set,
  getValue = XmlPreferences::joinCDataLines::get)

@Parcelize
private class JoinCommentLines(
  override val key: String = XmlPreferences.JOIN_COMMENT_LINES,
  override val title: Int = string.idepref_xml_joinComment_title,
  override val summary: Int? = string.idepref_xml_joinComment_summary
) : SwitchPreference(setValue = XmlPreferences::joinCommentLines::set,
  getValue = XmlPreferences::joinCommentLines::get)

@Parcelize
private class JoinContentLines(
  override val key: String = XmlPreferences.JOIN_CONTENT_LINES,
  override val title: Int = string.idepref_xml_joinContent_title,
  override val summary: Int? = string.idepref_xml_joinContent_summary
) : SwitchPreference(setValue = XmlPreferences::joinContentLines::set,
  getValue = XmlPreferences::joinContentLines::get)

@Parcelize
private class SpaceBeforeEmptyCloseTag(
  override val key: String = XmlPreferences.SPACE_BEFORE_EMPTY_CLOSE_TAG,
  override val title: Int = string.idepref_xml_spaceBeforeEmptyClose_title,
  override val summary: Int? = string.idepref_xml_spaceBeforeEmptyClose_summary
) :
  SwitchPreference(
    setValue = XmlPreferences::spaceBeforeEmptyCloseTag::set,
    getValue = XmlPreferences::spaceBeforeEmptyCloseTag::get
  )

@Parcelize
private class PreserveEmptyContent(
  override val key: String = XmlPreferences.PRESERVE_EMPTY_CONTENT,
  override val title: Int = string.idepref_xml_preserveEmptyContent_title,
  override val summary: Int? = string.idepref_xml_preserveEmptyContent_summary
) :
  SwitchPreference(setValue = XmlPreferences::preserveEmptyContent::set,
    getValue = XmlPreferences::preserveEmptyContent::get)

@Parcelize
private class PreserveAttributeLineBreaks(
  override val key: String = XmlPreferences.PRESERVE_ATTRIBUTE_LINE_BREAKS,
  override val title: Int = string.idepref_xml_preserveAttrLineBreaks_title,
  override val summary: Int? = string.idepref_xml_preserveAttrLineBreaks_summary
) :
  SwitchPreference(
    setValue = XmlPreferences::preserveAttributeLineBreaks::set,
    getValue = XmlPreferences::preserveAttributeLineBreaks::get
  )

@Parcelize
private class ClosingBracketNewLine(
  override val key: String = XmlPreferences.CLOSING_BRACKET_NEW_LINE,
  override val title: Int = string.idepref_xml_closingBrackNewLine_title,
  override val summary: Int? = string.idepref_xml_closingBrackNewLine_summary
) :
  SwitchPreference(
    setValue = XmlPreferences::closingBracketNewLine::set,
    getValue = XmlPreferences::closingBracketNewLine::get
  )

@Parcelize
private class TrimTrailingWhitespace(
  override val key: String = XmlPreferences.TRIM_TRAILING_WHITESPACE,
  override val title: Int = string.idepref_xml_trimTrailingWs_title,
  override val summary: Int? = string.idepref_xml_trimTrailingWs_summary
) :
  SwitchPreference(
    setValue = XmlPreferences::trimTrailingWhitespace::set,
    getValue = XmlPreferences::trimTrailingWhitespace::get
  )

@Parcelize
private class MaxLineWidth(
  override val key: String = XmlPreferences.MAX_LINE_WIDTH,
  override val title: Int = string.idepref_maxLineWidth_title,
  override val summary: Int? = string.idepref_maxLineWidth_summary
) :
  NumberInputEditTextPreference(
    hint = string.idepref_maxLineWidth_title,
    setValue = XmlPreferences::maxLineWidth::set,
    getValue = XmlPreferences::maxLineWidth::get
  )

@Parcelize
private class PreservedNewLines(
  override val key: String = XmlPreferences.PRESERVED_NEW_LINES,
  override val title: Int = string.idepref_preservedNewLines_title,
  override val summary: Int? = string.idepref_preservedNewLines_summary
) :
  NumberInputEditTextPreference(
    hint = string.idepref_preservedNewLines_title,
    setValue = XmlPreferences::preservedNewLines::set,
    getValue = XmlPreferences::preservedNewLines::get
  )

@Parcelize
private class SplitAttributesIndentSize(
  override val key: String = XmlPreferences.SPLIT_ATTRIBUTES_INDENT_SIZE,
  override val title: Int = string.idepref_splitAttrIndentSize_title,
  override val summary: Int? = string.idepref_splitAttrIndentSize_summary
) :
  NumberInputEditTextPreference(
    hint = string.idepref_splitAttrIndentSize_title,
    setValue = XmlPreferences::splitAttributesIndentSize::set,
    getValue = XmlPreferences::splitAttributesIndentSize::get
  )

@Parcelize
private class EmptyElementsBehavior(
  override val key: String = XmlPreferences.EMPTY_ELEMENTS_BEHAVIOR,
  override val title: Int = string.idepref_emptyElements_title,
  override val summary: Int? = string.idepref_emptyElements_summary
) : SingleChoicePreference() {

  @IgnoredOnParcel
  override val dialogCancellable = true

  override fun getEntries(preference: Preference): Array<PreferenceChoices.Entry> {
    val entries = EmptyElements.entries
    val currentBehavior = EmptyElements.valueOf(XmlPreferences.emptyElementsBehavior)

    return Array(entries.size) { index ->
      PreferenceChoices.Entry(
        label = entries[index].toString(),
        _isChecked = currentBehavior == entries[index],
        data = entries[index]
      )
    }
  }

  override fun onChoiceConfirmed(
    preference: Preference,
    entry: PreferenceChoices.Entry?,
    position: Int
  ) {
    XmlPreferences.emptyElementsBehavior = (entry?.data as? EmptyElements?)?.toString()
      ?: "Collapse"
  }
}



================================================
File: java/com/itsaky/androidide/provider/IDEDocumentsProvider.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.provider;

import android.content.res.AssetFileDescriptor;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.graphics.Point;
import android.os.CancellationSignal;
import android.os.ParcelFileDescriptor;
import android.provider.DocumentsContract.Document;
import android.provider.DocumentsContract.Root;
import android.provider.DocumentsProvider;
import android.webkit.MimeTypeMap;
import androidx.annotation.NonNull;
import com.itsaky.androidide.resources.R;
import com.itsaky.androidide.utils.Environment;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Locale;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A document provider for the Storage Access Framework which exposes the files in the $HOME/
 * directory to other apps.
 *
 * <p>Note that this replaces providing an activity matching the ACTION_GET_CONTENT intent:
 *
 * <p>"A document provider and ACTION_GET_CONTENT should be considered mutually exclusive. If you
 * support both of them simultaneously, your app will appear twice in the system picker UI, offering
 * two different ways of accessing your stored data. This would be confusing for users." -
 * http://developer.android.com/guide/topics/providers/document-provider.html#43
 *
 * @see <a
 * href="https://github.com/termux/termux-app/blob/master/app/src/main/java/com/termux/filepicker/TermuxDocumentsProvider.java">TermuxDocumentsProvider</a>
 */
public class IDEDocumentsProvider extends DocumentsProvider {

  private static final String ALL_MIME_TYPES = "*/*";
  private static final Logger LOG = LoggerFactory.getLogger(IDEDocumentsProvider.class);
  private static final File BASE_DIR = getBaseDir();
  // The default columns to return information about a root if no specific
  // columns are requested in a query.
  private static final String[] DEFAULT_ROOT_PROJECTION =
      new String[]{
          Root.COLUMN_ROOT_ID,
          Root.COLUMN_MIME_TYPES,
          Root.COLUMN_FLAGS,
          Root.COLUMN_ICON,
          Root.COLUMN_TITLE,
          Root.COLUMN_SUMMARY,
          Root.COLUMN_DOCUMENT_ID,
          Root.COLUMN_AVAILABLE_BYTES
      };
  // The default columns to return information about a document if no specific
  // columns are requested in a query.
  private static final String[] DEFAULT_DOCUMENT_PROJECTION =
      new String[]{
          Document.COLUMN_DOCUMENT_ID,
          Document.COLUMN_MIME_TYPE,
          Document.COLUMN_DISPLAY_NAME,
          Document.COLUMN_LAST_MODIFIED,
          Document.COLUMN_FLAGS,
          Document.COLUMN_SIZE
      };

  @NonNull
  private static File getBaseDir() {
    if (Environment.HOME != null) {
      return Environment.HOME;
    }

    return new File(Environment.DEFAULT_HOME);
  }

  @Override
  public boolean onCreate() {
    return true;
  }

  @Override
  public boolean isChildDocument(String parentDocumentId, String documentId) {
    return documentId.startsWith(parentDocumentId);
  }

  @Override
  public String createDocument(String parentDocumentId, String mimeType, String displayName)
      throws FileNotFoundException {
    File newFile = new File(parentDocumentId, displayName);
    int noConflictId = 2;
    while (newFile.exists()) {
      newFile = new File(parentDocumentId, displayName + " (" + noConflictId++ + ")");
    }
    try {
      boolean succeeded;
      if (Document.MIME_TYPE_DIR.equals(mimeType)) {
        succeeded = newFile.mkdir();
      } else {
        succeeded = newFile.createNewFile();
      }
      if (!succeeded) {
        throw new FileNotFoundException("Failed to create document with id " + newFile.getPath());
      }
    } catch (IOException e) {
      throw new FileNotFoundException("Failed to create document with id " + newFile.getPath());
    }
    return newFile.getPath();
  }

  @Override
  public void deleteDocument(String documentId) throws FileNotFoundException {
    File file = getFileForDocId(documentId);
    if (!file.delete()) {
      throw new FileNotFoundException("Failed to delete document with id " + documentId);
    }
  }

  @Override
  public Cursor queryRoots(String[] projection) {
    final MatrixCursor result =
        new MatrixCursor(projection != null ? projection : DEFAULT_ROOT_PROJECTION);
    final String applicationName = getContext().getString(R.string.app_name);

    final MatrixCursor.RowBuilder row = result.newRow();
    LOG.debug("queryRoots() before all add");
    row.add(Root.COLUMN_ROOT_ID, getDocIdForFile(BASE_DIR));
    LOG.debug("queryRoots() before all add, 1");
    row.add(Root.COLUMN_DOCUMENT_ID, getDocIdForFile(BASE_DIR));
    LOG.debug("queryRoots() before all add, 2");
    row.add(Root.COLUMN_SUMMARY, null);
    LOG.debug("queryRoots() before all add, 3");
    row.add(
        Root.COLUMN_FLAGS,
        Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH | Root.FLAG_SUPPORTS_IS_CHILD);
    LOG.debug("queryRoots() before all add, 4");
    row.add(Root.COLUMN_TITLE, applicationName);
    LOG.debug("queryRoots() before all add, 5");
    row.add(Root.COLUMN_MIME_TYPES, ALL_MIME_TYPES);
    LOG.debug("queryRoots() before all add, 6");
    row.add(Root.COLUMN_AVAILABLE_BYTES, BASE_DIR.getFreeSpace());
    LOG.debug("queryRoots() before all add, 7");
    row.add(Root.COLUMN_ICON, R.drawable.ic_launcher_foreground);
    LOG.debug("queryRoots() before all add");
    return result;
  }

  /**
   * Get the document id given a file. This document id must be consistent across time as other
   * applications may save the ID and use it to reference documents later.
   *
   * <p>The reverse of @{link #getFileForDocId}.
   */
  private static String getDocIdForFile(File file) {
    return file.getAbsolutePath();
  }

  @Override
  public Cursor queryDocument(String documentId, String[] projection) throws FileNotFoundException {
    final MatrixCursor result =
        new MatrixCursor(projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION);
    includeFile(result, documentId, null);
    return result;
  }

  @Override
  public Cursor queryChildDocuments(String parentDocumentId, String[] projection, String sortOrder)
      throws FileNotFoundException {
    final MatrixCursor result =
        new MatrixCursor(projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION);
    final File parent = getFileForDocId(parentDocumentId);
    for (File file : parent.listFiles()) {
      includeFile(result, null, file);
    }
    return result;
  }

  @Override
  public Cursor querySearchDocuments(String rootId, String query, String[] projection)
      throws FileNotFoundException {
    final MatrixCursor result =
        new MatrixCursor(projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION);
    final File parent = getFileForDocId(rootId);

    // This example implementation searches file names for the query and doesn't rank search
    // results, so we can stop as soon as we find a sufficient number of matches.  Other
    // implementations might rank results and use other data about files, rather than the file
    // name, to produce a match.
    final LinkedList<File> pending = new LinkedList<>();
    pending.add(parent);

    final int MAX_SEARCH_RESULTS = 50;
    while (!pending.isEmpty() && result.getCount() < MAX_SEARCH_RESULTS) {
      final File file = pending.removeFirst();
      // Avoid directories outside the $HOME directory linked with symlinks (to avoid e.g.
      // search
      // through the whole SD card).
      boolean isInsideHome;
      try {
        isInsideHome = file.getCanonicalPath().startsWith(Environment.HOME.getAbsolutePath());
      } catch (IOException e) {
        isInsideHome = true;
      }
      if (isInsideHome) {
        if (file.isDirectory()) {
          Collections.addAll(pending, file.listFiles());
        } else {
          if (file.getName().toLowerCase(Locale.ROOT).contains(query)) {
            includeFile(result, null, file);
          }
        }
      }
    }

    return result;
  }

  @Override
  public String getDocumentType(String documentId) throws FileNotFoundException {
    File file = getFileForDocId(documentId);
    return getMimeType(file);
  }

  @Override
  public ParcelFileDescriptor openDocument(
      final String documentId, String mode, CancellationSignal signal)
      throws FileNotFoundException {
    final File file = getFileForDocId(documentId);
    final int accessMode = ParcelFileDescriptor.parseMode(mode);
    return ParcelFileDescriptor.open(file, accessMode);
  }

  @Override
  public AssetFileDescriptor openDocumentThumbnail(
      String documentId, Point sizeHint, CancellationSignal signal) throws FileNotFoundException {
    final File file = getFileForDocId(documentId);
    final ParcelFileDescriptor pfd =
        ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
    return new AssetFileDescriptor(pfd, 0, file.length());
  }

  /**
   * Add a representation of a file to a cursor.
   *
   * @param result the cursor to modify
   * @param docId  the document ID representing the desired file (may be null if given file)
   * @param file   the File object representing the desired file (may be null if given docID)
   */
  private void includeFile(MatrixCursor result, String docId, File file)
      throws FileNotFoundException {
    if (docId == null) {
      docId = getDocIdForFile(file);
    } else {
      file = getFileForDocId(docId);
    }

    int flags = 0;
    if (file.isDirectory()) {
      if (file.canWrite()) {
        flags |= Document.FLAG_DIR_SUPPORTS_CREATE;
      }
    } else if (file.canWrite()) {
      flags |= Document.FLAG_SUPPORTS_WRITE;
    }
    if (file.getParentFile().canWrite()) {
      flags |= Document.FLAG_SUPPORTS_DELETE;
    }

    final String displayName = file.getName();
    final String mimeType = getMimeType(file);
    if (mimeType.startsWith("image/")) {
      flags |= Document.FLAG_SUPPORTS_THUMBNAIL;
    }

    final MatrixCursor.RowBuilder row = result.newRow();
    row.add(Document.COLUMN_DOCUMENT_ID, docId);
    row.add(Document.COLUMN_DISPLAY_NAME, displayName);
    row.add(Document.COLUMN_SIZE, file.length());
    row.add(Document.COLUMN_MIME_TYPE, mimeType);
    row.add(Document.COLUMN_LAST_MODIFIED, file.lastModified());
    row.add(Document.COLUMN_FLAGS, flags);
    row.add(Document.COLUMN_ICON, R.mipmap.ic_launcher);
  }

  /**
   * Get the file given a document id (the reverse of {@link #getDocIdForFile(File)}).
   */
  private static File getFileForDocId(String docId) throws FileNotFoundException {
    final File f = new File(docId);
    if (!f.exists()) {
      throw new FileNotFoundException(f.getAbsolutePath() + " not found");
    }
    return f;
  }

  private static String getMimeType(File file) {
    if (file.isDirectory()) {
      return Document.MIME_TYPE_DIR;
    } else {
      final String name = file.getName();
      final int lastDot = name.lastIndexOf('.');
      if (lastDot >= 0) {
        final String extension = name.substring(lastDot + 1).toLowerCase(Locale.ROOT);
        final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
        if (mime != null) {
          return mime;
        }
      }
      return "application/octet-stream";
    }
  }
}



================================================
File: java/com/itsaky/androidide/provider/IDEFileProvider.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.provider

import androidx.core.content.FileProvider

/**
 * AndroidIDE file provider.
 *
 * @author Akash Yadav
 */
class IDEFileProvider : FileProvider()



================================================
File: java/com/itsaky/androidide/roomData/recentproject/RecentProject.kt
================================================
package com.itsaky.androidide.roomData.recentproject

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "recent_project_table")
data class RecentProject(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id") val id: Int = 0,
    @ColumnInfo(name = "name") val name: String,
    @ColumnInfo(name = "create_at") val createdAt: String,
    @ColumnInfo(name = "location") val location: String,
)




================================================
File: java/com/itsaky/androidide/roomData/recentproject/RecentProjectDao.kt
================================================
package com.itsaky.androidide.roomData.recentproject

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query

@Dao
interface RecentProjectDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(project: RecentProject)

    @Query("DELETE FROM recent_project_table WHERE name = :name")
    suspend fun deleteByName(name: String)

    @Query("SELECT * FROM recent_project_table order by create_at DESC")
    suspend fun dumpAll(): List<RecentProject>?

    @Query("SELECT * FROM recent_project_table WHERE name = :name LIMIT 1")
    suspend fun getProjectByName(name: String): RecentProject?


    @Query("DELETE FROM recent_project_table")
    suspend fun deleteAll()

    @Query("DELETE FROM recent_project_table WHERE name IN (:names)")
    suspend fun deleteByNames(names: List<String>)

    @Query("UPDATE recent_project_table SET name = :newName, location = :newLocation WHERE name = :oldName")
    suspend fun updateNameAndLocation(oldName: String, newName: String, newLocation: String)

    @Query("SELECT COUNT(*) FROM recent_project_table")
    suspend fun getCount(): Int
}



================================================
File: java/com/itsaky/androidide/roomData/recentproject/RecentProjectRoomDatabase.kt
================================================
package com.itsaky.androidide.roomData.recentproject

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import kotlinx.coroutines.CoroutineScope

@Database(entities = [RecentProject::class], version = 1, exportSchema = false)
abstract class RecentProjectRoomDatabase : RoomDatabase() {

    abstract fun recentProjectDao(): RecentProjectDao

    private class RecentProjectRoomDatabaseCallback(
        private val context: Context,
        private val scope: CoroutineScope
    ) : Callback() {

    }

    companion object {
        @Volatile
        private var INSTANCE: RecentProjectRoomDatabase? = null

        fun getDatabase(context: Context, scope: CoroutineScope): RecentProjectRoomDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,
                    RecentProjectRoomDatabase::class.java,
                    "RecentProject_database"
                )
                    .addCallback(RecentProjectRoomDatabaseCallback(context, scope))
                    .build()
                    .also { INSTANCE = it }
            }
        }
    }
}



================================================
File: java/com/itsaky/androidide/services/InstallationResultReceiver.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import com.itsaky.androidide.events.InstallationResultEvent
import org.greenrobot.eventbus.EventBus

/**
 * Receives status events for APK installation process.
 *
 * @author Akash Yadav
 */
class InstallationResultReceiver : BroadcastReceiver() {
  override fun onReceive(context: Context, intent: Intent) {
    EventBus.getDefault().post(InstallationResultEvent(intent))
  }
}



================================================
File: java/com/itsaky/androidide/services/ToolingServerAlreadyStartedException.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services;

/**
 * Thrown when trying to start Tooling API server but another instance is already running.
 *
 * @author Akash Yadav
 */
public class ToolingServerAlreadyStartedException extends IllegalStateException {

  public ToolingServerAlreadyStartedException() {
    this("Tooling API server is already started");
  }

  public ToolingServerAlreadyStartedException(final String s) {
    super(s);
  }
}



================================================
File: java/com/itsaky/androidide/services/ToolingServerNotStartedException.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services;

/**
 * Thrown when a build is requested but the tooling API server is not started.
 *
 * @author Akash Yadav
 */
public class ToolingServerNotStartedException extends IllegalStateException {

  public ToolingServerNotStartedException() {
    this("Tooling API server has not been started");
  }

  public ToolingServerNotStartedException(final String s) {
    super(s);
  }
}



================================================
File: java/com/itsaky/androidide/services/builder/BuildInProgressException.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.builder;

/**
 * Thrown when a build is requested but another build is already in progress.
 *
 * @author Akash Yadav
 */
public class BuildInProgressException extends IllegalStateException {

  public BuildInProgressException() {
    this("A build is already running!");
  }

  public BuildInProgressException(final String s) {
    super(s);
  }
}



================================================
File: java/com/itsaky/androidide/services/builder/GradleBuildService.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.services.builder

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.os.IBinder
import android.text.TextUtils
import androidx.core.app.NotificationManagerCompat
import com.blankj.utilcode.util.ResourceUtils
import com.blankj.utilcode.util.ZipUtils
import com.itsaky.androidide.BuildConfig
import com.itsaky.androidide.R.*
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.managers.ToolsManager
import com.itsaky.androidide.preferences.internal.BuildPreferences
import com.itsaky.androidide.preferences.internal.DevOpsPreferences
import com.itsaky.androidide.projects.ProjectManagerImpl
import com.itsaky.androidide.projects.builder.BuildService
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.services.ToolingServerNotStartedException
import com.itsaky.androidide.services.builder.ToolingServerRunner.OnServerStartListener
import com.itsaky.androidide.tasks.ifCancelledOrInterrupted
import com.itsaky.androidide.tasks.runOnUiThread
import com.itsaky.androidide.tooling.api.ForwardingToolingApiClient
import com.itsaky.androidide.tooling.api.IProject
import com.itsaky.androidide.tooling.api.IToolingApiClient
import com.itsaky.androidide.tooling.api.IToolingApiServer
import com.itsaky.androidide.tooling.api.LogSenderConfig.PROPERTY_LOGSENDER_AAR
import com.itsaky.androidide.tooling.api.LogSenderConfig.PROPERTY_LOGSENDER_ENABLED
import com.itsaky.androidide.tooling.api.messages.InitializeProjectParams
import com.itsaky.androidide.tooling.api.messages.LogMessageParams
import com.itsaky.androidide.tooling.api.messages.TaskExecutionMessage
import com.itsaky.androidide.tooling.api.messages.result.BuildCancellationRequestResult
import com.itsaky.androidide.tooling.api.messages.result.BuildInfo
import com.itsaky.androidide.tooling.api.messages.result.BuildResult
import com.itsaky.androidide.tooling.api.messages.result.GradleWrapperCheckResult
import com.itsaky.androidide.tooling.api.messages.result.InitializeResult
import com.itsaky.androidide.tooling.api.messages.result.TaskExecutionResult
import com.itsaky.androidide.tooling.api.models.ToolingServerMetadata
import com.itsaky.androidide.tooling.events.ProgressEvent
import com.itsaky.androidide.utils.Environment
import com.termux.shared.termux.shell.command.environment.TermuxShellEnvironment
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import org.slf4j.LoggerFactory
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.util.Objects
import java.util.concurrent.CompletableFuture
import java.util.concurrent.CompletionException
import java.util.concurrent.TimeUnit

/**
 * A foreground service that handles interaction with the Gradle Tooling API.
 *
 * @author Akash Yadav
 */
class GradleBuildService : Service(), BuildService, IToolingApiClient,
  ToolingServerRunner.Observer {

  private var mBinder: GradleServiceBinder? = null
  private var isToolingServerStarted = false
  override var isBuildInProgress = false
    private set

  /**
   * We do not provide direct access to GradleBuildService instance to the Tooling API launcher as
   * it may cause memory leaks. Instead, we create another client object which forwards all calls to
   * us. So, when the service is destroyed, we release the reference to the service from this
   * client.
   */
  private var _toolingApiClient: ForwardingToolingApiClient? = null
  private var toolingServerRunner: ToolingServerRunner? = null
  private var outputReaderJob: Job? = null
  private var notificationManager: NotificationManager? = null
  private var server: IToolingApiServer? = null
  private var eventListener: EventListener? = null

  private val buildServiceScope = CoroutineScope(
    Dispatchers.Default + CoroutineName("GradleBuildService"))

  private val isGradleWrapperAvailable: Boolean
    get() {
      val projectManager = ProjectManagerImpl.getInstance()
      val projectDir = projectManager.projectDirPath
      if (TextUtils.isEmpty(projectDir)) {
        return false
      }

      val projectRoot = Objects.requireNonNull(projectManager.projectDir)
      if (!projectRoot.exists()) {
        return false
      }

      val gradlew = File(projectRoot, "gradlew")
      val gradleWrapperJar = File(projectRoot, "gradle/wrapper/gradle-wrapper.jar")
      val gradleWrapperProps = File(projectRoot, "gradle/wrapper/gradle-wrapper.properties")
      return gradlew.exists() && gradleWrapperJar.exists() && gradleWrapperProps.exists()
    }

  companion object {

    private val log = LoggerFactory.getLogger(GradleBuildService::class.java)
    private val NOTIFICATION_ID = R.string.app_name
    private val SERVER_System_err = LoggerFactory.getLogger("ToolingApiErrorStream")

    private const val ERROR_GRADLE_ENTERPRISE_PLUGIN = "gradle-enterprise-gradle-plugin"
    private const val ERROR_COULD_NOT_FIND_GRADLE = "Could not find com.gradle"

    private const val MESSAGE_SCAN_REQUIRES_PLUGIN = "The --scan option requires the Gradle Enterprise plugin."
    private const val MESSAGE_OPTION_DISABLED = "This option has been disabled."
    private const val MESSAGE_EXCEPTION_SCAN_DISABLED = "Disabled --scan option due to missing Gradle Enterprise plugin"
  }

  override fun onCreate() {
    notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
    showNotification(getString(R.string.build_status_idle), false)
    Lookup.getDefault().update(BuildService.KEY_BUILD_SERVICE, this)
  }

  override fun isToolingServerStarted(): Boolean {
    return isToolingServerStarted && server != null
  }

  private fun showNotification(message: String,
    @Suppress("SameParameterValue") isProgress: Boolean) {
    log.info("Showing notification to user...")
    createNotificationChannels()
    startForeground(NOTIFICATION_ID, buildNotification(message, isProgress))
  }

  private fun createNotificationChannels() {
    val buildNotificationChannel = NotificationChannel(
      BaseApplication.NOTIFICATION_GRADLE_BUILD_SERVICE,
      getString(string.title_gradle_service_notification_channel),
      NotificationManager.IMPORTANCE_LOW)
    NotificationManagerCompat.from(this)
      .createNotificationChannel(buildNotificationChannel)
  }

  private fun buildNotification(message: String, isProgress: Boolean): Notification {
    val ticker = getString(R.string.title_gradle_service_notification_ticker)
    val title = getString(R.string.title_gradle_service_notification)
    val launch = packageManager.getLaunchIntentForPackage(BuildConfig.APPLICATION_ID)
    val intent = PendingIntent.getActivity(this, 0, launch, PendingIntent.FLAG_UPDATE_CURRENT)
    val builder = Notification.Builder(this, BaseApplication.NOTIFICATION_GRADLE_BUILD_SERVICE)
      .setSmallIcon(R.drawable.ic_launcher_fg_vector).setTicker(ticker)
      .setWhen(System.currentTimeMillis()).setContentTitle(title).setContentText(message)
      .setContentIntent(intent)

    // Checking whether to add a ProgressBar to the notification
    if (isProgress) {
      // Add ProgressBar to Notification
      builder.setProgress(100, 0, true)
    }
    return builder.build()
  }

  override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
    // No point in restarting the service if it really gets killed.
    return START_NOT_STICKY
  }

  override fun onDestroy() {
    mBinder?.release()
    mBinder = null

    log.info("Service is being destroyed. Dismissing the shown notification...")
    notificationManager!!.cancel(NOTIFICATION_ID)

    val lookup = Lookup.getDefault()
    lookup.unregister(BuildService.KEY_BUILD_SERVICE)
    lookup.unregister(BuildService.KEY_PROJECT_PROXY)

    server?.also { server ->
      try {
        log.info("Shutting down Tooling API server...")
        // send the shutdown request but do not wait for the server to respond
        // the service should not block the onDestroy call in order to avoid timeouts
        // the tooling server must release resources and exit automatically
        server.shutdown().get(1, TimeUnit.SECONDS)
      } catch (e: Throwable) {
        log.error("Failed to shutdown Tooling API server", e)
      }
    }

    log.debug("Cancelling tooling server runner...")
    toolingServerRunner?.release()
    toolingServerRunner = null

    _toolingApiClient?.client = null
    _toolingApiClient = null

    log.debug("Cancelling tooling server output reader job...")
    outputReaderJob?.cancel()
    outputReaderJob = null

    isToolingServerStarted = false
  }

  override fun onBind(intent: Intent): IBinder? {
    if (mBinder == null) {
      mBinder = GradleServiceBinder(this)
    }
    return mBinder
  }

  override fun onListenerStarted(
    server: IToolingApiServer,
    projectProxy: IProject,
    errorStream: InputStream
  ) {
    startServerOutputReader(errorStream)
    this.server = server
    Lookup.getDefault().update(BuildService.KEY_PROJECT_PROXY, projectProxy)
    isToolingServerStarted = true
  }

  override fun onServerExited(exitCode: Int) {
    log.warn("Tooling API process terminated with exit code: {}", exitCode)
    stopForeground(STOP_FOREGROUND_REMOVE)
  }

  override fun getClient(): IToolingApiClient {
    if (_toolingApiClient == null) {
      _toolingApiClient = ForwardingToolingApiClient(this)
    }
    return _toolingApiClient!!
  }

  override fun logMessage(params: LogMessageParams) {
    val logger = LoggerFactory.getLogger(params.tag)
    when (params.level) {
      'D' -> logger.debug(params.message)
      'W' -> logger.warn(params.message)
      'E' -> logger.error(params.message)
      'I' -> logger.info(params.message)

      else -> logger.trace(params.message)
    }
  }

  override fun logOutput(line: String) {
    eventListener?.onOutput(line)
  }

  override fun prepareBuild(buildInfo: BuildInfo) {
    updateNotification(getString(R.string.build_status_in_progress), true)
    eventListener?.prepareBuild(buildInfo)
  }

  override fun onBuildSuccessful(result: BuildResult) {
    updateNotification(getString(R.string.build_status_sucess), false)
    eventListener?.onBuildSuccessful(result.tasks)
  }

  override fun onBuildFailed(result: BuildResult) {
    updateNotification(getString(R.string.build_status_failed), false)
    eventListener?.onBuildFailed(result.tasks)
  }

  override fun onProgressEvent(event: ProgressEvent) {
    eventListener?.onProgressEvent(event)
  }

  override fun getBuildArguments(): CompletableFuture<List<String>> {
    val extraArgs = ArrayList<String>()
    extraArgs.add("--init-script")
    extraArgs.add(Environment.INIT_SCRIPT.absolutePath)

    // Override AAPT2 binary
    // The one downloaded from Maven is not built for Android
    extraArgs.add("-Pandroid.aapt2FromMavenOverride=${Environment.AAPT2.absolutePath}")
    extraArgs.add("-P${PROPERTY_LOGSENDER_ENABLED}=${DevOpsPreferences.logsenderEnabled}")
    extraArgs.add("-P${PROPERTY_LOGSENDER_AAR}=${Environment.LOGSENDER_AAR.absolutePath}")

    if (BuildPreferences.isStacktraceEnabled) {
      extraArgs.add("--stacktrace")
    }
    if (BuildPreferences.isInfoEnabled) {
      extraArgs.add("--info")
    }
    if (BuildPreferences.isDebugEnabled) {
      extraArgs.add("--debug")
    }
    if (BuildPreferences.isWarningModeAllEnabled) {
      extraArgs.add("--warning-mode")
      extraArgs.add("all")
    }
    if (BuildPreferences.isBuildCacheEnabled) {
      extraArgs.add("--build-cache")
    }
    if (BuildPreferences.isOfflineEnabled) {
      extraArgs.add("--offline")
    }
    if (BuildPreferences.isScanEnabled) {
      if (isGradleEnterprisePluginAvailable()) {
        extraArgs.add("--scan")
      } else {
        log.warn("Gradle Enterprise plugin is not available. The --scan option has been disabled for this build.")
      }
    }
    return CompletableFuture.completedFuture(extraArgs)
  }

  override fun checkGradleWrapperAvailability(): CompletableFuture<GradleWrapperCheckResult> {
    return if (isGradleWrapperAvailable) CompletableFuture.completedFuture(
      GradleWrapperCheckResult(true)) else installWrapper()
  }

  internal fun setServerListener(listener: OnServerStartListener?) {
    if (toolingServerRunner != null) {
      toolingServerRunner!!.setListener(listener)
    }
  }

  private fun installWrapper(): CompletableFuture<GradleWrapperCheckResult> {
    eventListener?.also { eventListener ->
      eventListener.onOutput("-------------------- NOTE --------------------")
      eventListener.onOutput(getString(R.string.msg_installing_gradlew))
      eventListener.onOutput("----------------------------------------------")
    }
    return CompletableFuture.supplyAsync { doInstallWrapper() }
  }

  private fun doInstallWrapper(): GradleWrapperCheckResult {
    val extracted = File(Environment.TMP_DIR, "gradle-wrapper.zip")
    if (!ResourceUtils.copyFileFromAssets(ToolsManager.getCommonAsset("gradle-wrapper.zip"),
        extracted.absolutePath)
    ) {
      log.error("Unable to extract gradle-plugin.zip from IDE resources.")
      return GradleWrapperCheckResult(false)
    }
    try {
      val projectDir = ProjectManagerImpl.getInstance().projectDir
      val files = ZipUtils.unzipFile(extracted, projectDir)
      if (files != null && files.isNotEmpty()) {
        return GradleWrapperCheckResult(true)
      }
    } catch (e: IOException) {
      log.error("An error occurred while extracting Gradle wrapper", e)
    }
    return GradleWrapperCheckResult(false)
  }

  private fun updateNotification(message: String, isProgress: Boolean) {
    runOnUiThread { doUpdateNotification(message, isProgress) }
  }

  private fun doUpdateNotification(message: String, isProgress: Boolean) {
    (getSystemService(NOTIFICATION_SERVICE) as NotificationManager).notify(NOTIFICATION_ID,
      buildNotification(message, isProgress))
  }

  override fun metadata(): CompletableFuture<ToolingServerMetadata> {
    checkServerStarted()
    return server!!.metadata()
  }

  override fun initializeProject(
    params: InitializeProjectParams): CompletableFuture<InitializeResult> {
    checkServerStarted()
    Objects.requireNonNull(params)
    return try {
      performBuildTasks(server!!.initialize(params))
    } catch (e: ScanPluginMissingException) {
      log.info("Retrying initialization without --scan option...")
      initializeProject(params)
    }
  }

  override fun executeTasks(message: TaskExecutionMessage): CompletableFuture<TaskExecutionResult> {
    checkServerStarted()

    val future = performBuildTasks(server!!.executeTasks(message))

    return future.handle { result, exception ->
      if (exception != null) {
        val cause = exception.cause
        if (cause is ScanPluginMissingException) {
          log.info("Retrying build without --scan option...")
          return@handle executeTasks(message).get()
        }
        throw CompletionException(exception)
      }
      return@handle result
    }
  }

  override fun cancelCurrentBuild(): CompletableFuture<BuildCancellationRequestResult> {
    checkServerStarted()
    return server!!.cancelCurrentBuild()
  }

  private fun <T> performBuildTasks(future: CompletableFuture<T>): CompletableFuture<T> {
    return CompletableFuture.runAsync(this::onPrepareBuildRequest).handleAsync { _, _ ->
      try {
        return@handleAsync future.get()
      } catch (e: Throwable) {
        if (BuildPreferences.isScanEnabled &&
          (e.toString().contains(ERROR_GRADLE_ENTERPRISE_PLUGIN) ||
                  e.toString().contains(ERROR_COULD_NOT_FIND_GRADLE))) {

          BuildPreferences.isScanEnabled = false

          eventListener?.onOutput(MESSAGE_SCAN_REQUIRES_PLUGIN)
          eventListener?.onOutput(MESSAGE_OPTION_DISABLED)

          throw ScanPluginMissingException(MESSAGE_EXCEPTION_SCAN_DISABLED)
        }

        throw CompletionException(e)
      }
    }.handle(this::markBuildAsFinished)
  }

  class ScanPluginMissingException(message: String) : Exception(message)

  private fun isGradleEnterprisePluginAvailable(): Boolean {
    val projectDir = ProjectManagerImpl.getInstance().projectDir ?: return false

    val settingsFiles = listOf(
      File(projectDir, "settings.gradle"),
      File(projectDir, "settings.gradle.kts")
    )

    for (file in settingsFiles) {
      if (file.exists()) {
        try {
          val content = file.readText()
          if (content.contains("com.gradle.enterprise")) {
            return true
          }
        } catch (e: Exception) {
          log.error("Error reading settings file: ${file.name}", e)
        }
      }
    }

    return false
  }

  private fun onPrepareBuildRequest() {
    checkServerStarted()
    ensureTmpdir()
    if (isBuildInProgress) {
      logBuildInProgress()
      throw BuildInProgressException()
    }
    isBuildInProgress = true
  }

  @Throws(ToolingServerNotStartedException::class)
  private fun checkServerStarted() {
    if (!isToolingServerStarted()) {
      throw ToolingServerNotStartedException()
    }
  }

  private fun ensureTmpdir() {
    Environment.mkdirIfNotExits(Environment.TMP_DIR)
  }

  private fun logBuildInProgress() {
    log.warn("A build is already in progress!")
  }

  @Suppress("UNUSED_PARAMETER")
  private fun <T> markBuildAsFinished(result: T, throwable: Throwable?): T {
    isBuildInProgress = false
    return result
  }

  internal fun startToolingServer(listener: OnServerStartListener?) {
    if (toolingServerRunner?.isStarted != true) {
      val envs = TermuxShellEnvironment().getEnvironment(this, false)
      toolingServerRunner = ToolingServerRunner(listener, this).also { it.startAsync(envs) }
      return
    }

    if (toolingServerRunner!!.isStarted && listener != null) {
      listener.onServerStarted(toolingServerRunner!!.pid!!)
    } else {
      setServerListener(listener)
    }
  }

  fun setEventListener(eventListener: EventListener?): GradleBuildService {
    if (eventListener == null) {
      this.eventListener = null
      return this
    }
    this.eventListener = wrap(eventListener)
    return this
  }

  private fun wrap(listener: EventListener?): EventListener? {
    return if (listener == null) {
      null
    } else object : EventListener {
      override fun prepareBuild(buildInfo: BuildInfo) {
        runOnUiThread { listener.prepareBuild(buildInfo) }
      }

      override fun onBuildSuccessful(tasks: List<String?>) {
        runOnUiThread { listener.onBuildSuccessful(tasks) }
      }

      override fun onProgressEvent(event: ProgressEvent) {
        runOnUiThread { listener.onProgressEvent(event) }
      }

      override fun onBuildFailed(tasks: List<String?>) {
        runOnUiThread { listener.onBuildFailed(tasks) }
      }

      override fun onOutput(line: String?) {
        runOnUiThread { listener.onOutput(line) }
      }
    }
  }

  private fun startServerOutputReader(input: InputStream) {
    if (outputReaderJob?.isActive == true) {
      return
    }

    outputReaderJob = buildServiceScope.launch(
      Dispatchers.IO + CoroutineName("ToolingServerErrorReader")
    ) {
      val reader = input.bufferedReader()
      try {
        reader.forEachLine { line ->
          SERVER_System_err.error(line)
        }
      } catch (e: Throwable) {
        e.ifCancelledOrInterrupted(suppress = true) {
          // will be suppressed
          return@launch
        }

        // log the error and fail silently
        log.error("Failed to read tooling server output", e)
      }
    }
  }

  /**
   * Handles events received from a Gradle build.
   */
  interface EventListener {

    /**
     * Called just before a build is started.
     *
     * @param buildInfo The information about the build to be executed.
     * @see IToolingApiClient.prepareBuild
     */
    fun prepareBuild(buildInfo: BuildInfo)

    /**
     * Called when a build is successful.
     *
     * @param tasks The tasks that were run.
     * @see IToolingApiClient.onBuildSuccessful
     */
    fun onBuildSuccessful(tasks: List<String?>)

    /**
     * Called when a progress event is received from the Tooling API server.
     *
     * @param event The event model describing the event.
     */
    fun onProgressEvent(event: ProgressEvent)

    /**
     * Called when a build fails.
     *
     * @param tasks The tasks that were run.
     * @see IToolingApiClient.onBuildFailed
     */
    fun onBuildFailed(tasks: List<String?>)

    /**
     * Called when the output line is received.
     *
     * @param line The line of the build output.
     */
    fun onOutput(line: String?)
  }
}


================================================
File: java/com/itsaky/androidide/services/builder/GradleBuildServiceConnnection.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.builder

import android.content.ComponentName
import android.content.ServiceConnection
import android.os.IBinder
import org.slf4j.LoggerFactory

/**
 * [ServiceConnection] for [GradleBuildService].
 *
 * @author Akash Yadav
 */
class GradleBuildServiceConnnection : ServiceConnection {

  internal var onConnected: ((GradleBuildService) -> Unit)? = null

  companion object {

    private val log = LoggerFactory.getLogger(GradleBuildServiceConnnection::class.java)
  }

  override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
    val serviceBinder = service as GradleServiceBinder
    onConnected?.invoke(serviceBinder.service!!)
  }

  override fun onServiceDisconnected(name: ComponentName?) {
    onConnected = null
    log.info("Disconnected from Gradle build service")
  }
}


================================================
File: java/com/itsaky/androidide/services/builder/GradleServiceBinder.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.services.builder

import android.os.Binder

/**
 * [Binder] implementation for [GradleBuildService] which provides instance of the
 * service.
 *
 * @author Akash Yadav
 */
internal class GradleServiceBinder(service: GradleBuildService?) : Binder() {

  var service: GradleBuildService? = service
    private set

  fun release() {
    service = null
  }
}



================================================
File: java/com/itsaky/androidide/services/builder/ToolingServerRunner.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.builder

import ch.qos.logback.core.CoreConstants
import com.itsaky.androidide.shell.executeProcessAsync
import com.itsaky.androidide.tasks.cancelIfActive
import com.itsaky.androidide.tasks.ifCancelledOrInterrupted
import com.itsaky.androidide.tooling.api.IProject
import com.itsaky.androidide.tooling.api.IToolingApiClient
import com.itsaky.androidide.tooling.api.IToolingApiServer
import com.itsaky.androidide.tooling.api.util.ToolingApiLauncher
import com.itsaky.androidide.utils.Environment
import com.termux.shared.reflection.ReflectionUtils
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.joinAll
import kotlinx.coroutines.launch
import org.slf4j.LoggerFactory
import java.io.InputStream
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Runner thread for the Tooling API.
 *
 * @author Akash Yadav
 */
internal class ToolingServerRunner(
  private var listener: OnServerStartListener?,
  private var observer: Observer?,
) {

  internal var pid: Int? = null
  private var _job: Job? = null
  private var _isStarted = AtomicBoolean(false)

  var isStarted: Boolean
    get() = _isStarted.get()
    private set(value) {
      _isStarted.set(value)
    }

  private val runnerScope = CoroutineScope(Dispatchers.IO + CoroutineName("ToolingServerRunner"))

  companion object {

    private val log = LoggerFactory.getLogger(ToolingServerRunner::class.java)
  }

  fun setListener(listener: OnServerStartListener?) {
    this.listener = listener
  }

  fun startAsync(envs: Map<String, String>) = runnerScope.launch {
    var process: Process?
    try {
      log.info("Starting tooling API server...")
      val command = listOf(
        Environment.JAVA.absolutePath, // The 'java' binary executable
        // Allow reflective access to private members of classes in the following
        // packages:
        // - java.lang
        // - java.io
        // - java.util
        //
        // If any of the model classes in 'tooling-api-model' module send/receive
        // objects from the JDK, their package name must be declared here with
        // '--add-opens' to prevent InaccessibleObjectException.
        // For example, some of the model classes has members of type java.io.File.
        // When sending/receiving these type of objects using LSP4J, members of
        // these objects are reflectively accessed by Gson. If we do no specify
        // '--add-opens' for 'java.io' (for java.io.File) package, JVM will throw an
        // InaccessibleObjectException.
        "--add-opens", "java.base/java.lang=ALL-UNNAMED", "--add-opens",
        "java.base/java.util=ALL-UNNAMED", "--add-opens",
        "java.base/java.io=ALL-UNNAMED", // The JAR file to run
        "-D${CoreConstants.STATUS_LISTENER_CLASS_KEY}=com.itsaky.androidide.tooling.impl.util.LogbackStatusListener",
        "-jar", Environment.TOOLING_API_JAR.absolutePath
      )

      process = executeProcessAsync {
        this.command = command

        // input and output is used for communication to the tooling server
        // error stream is used to read the server logs
        this.redirectErrorStream = false
        this.workingDirectory = null // HOME
        this.environment = envs
      }

      pid = ReflectionUtils.getDeclaredField(process::class.java, "pid")?.get(process) as Int?
      pid ?: throw IllegalStateException("Unable to get process ID")

      val inputStream = process.inputStream
      val outputStream = process.outputStream
      val errorStream = process.errorStream

      val processJob = launch(Dispatchers.IO) {
        try {
          process?.waitFor()
          log.info("Tooling API process exited with code : {}", process?.exitValue() ?: "<unknown>")
          process = null
        } finally {
          log.info("Destroying Tooling API process...")
          process?.destroyForcibly()
        }
      }

      val launcher = ToolingApiLauncher.newClientLauncher(
        observer!!.getClient(),
        inputStream,
        outputStream
      )

      val future = launcher.startListening()
      observer?.onListenerStarted(
        server = launcher.remoteProxy as IToolingApiServer,
        projectProxy = launcher.remoteProxy as IProject,
        errorStream = errorStream
      )

      isStarted = true

      listener?.onServerStarted(pid!!)

      // we don't need the listener anymore
      // also, this might be a reference to the activity
      // release to prevent memory leak
      listener = null

      // Wait(block) until the process terminates
      val serverJob = launch(Dispatchers.IO) {
        try {
          future.get()
        } catch (err: Throwable) {
          err.ifCancelledOrInterrupted {
            log.info("ToolingServerThread has been cancelled or interrupted.")
          }

          // rethrow the error
          throw err
        }
      }

      processJob.join()
      joinAll(serverJob, processJob)
    } catch (e: Throwable) {
      if (e !is CancellationException) {
        log.error("Unable to start tooling API server", e)
      }
    }
  }.also {
    _job = it
  }

  fun release() {
    this.listener = null
    this.observer = null
    this._job?.cancel(CancellationException("Cancellation was requested"))
    this.runnerScope.cancelIfActive("Cancellation was requested")
  }

  interface Observer {

    fun onListenerStarted(
      server: IToolingApiServer,
      projectProxy: IProject,
      errorStream: InputStream,
    )

    fun onServerExited(exitCode: Int)

    fun getClient(): IToolingApiClient
  }

  /** Callback to listen for Tooling API server start event.  */
  fun interface OnServerStartListener {

    /** Called when the tooling API server has been successfully started.  */
    fun onServerStarted(pid: Int)
  }
}



================================================
File: java/com/itsaky/androidide/services/builder/util.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.builder

import com.itsaky.androidide.preferences.internal.BuildPreferences
import com.itsaky.androidide.tooling.api.messages.GradleDistributionParams

/**
 * The distribution params. This considers [gradleInstallationDir] preference as well.
 */
val gradleDistributionParams: GradleDistributionParams
  get() {
    if (BuildPreferences.gradleInstallationDir.isBlank()) {
      return GradleDistributionParams.WRAPPER
    }

    return GradleDistributionParams.forInstallationDir(BuildPreferences.gradleInstallationDir)
  }


================================================
File: java/com/itsaky/androidide/services/debug/DebugOverlayManager.kt
================================================
package com.itsaky.androidide.services.debug

import android.content.Context
import android.graphics.PixelFormat
import android.view.ContextThemeWrapper
import android.view.Gravity
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.ViewConfiguration
import android.view.WindowManager
import androidx.core.content.ContextCompat
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.databinding.DebuggerActionsWindowBinding
import com.itsaky.androidide.lsp.IDEDebugClientImpl
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import kotlin.math.abs

/**
 * Manages interaction with the actions shown in the debugger overlay window.
 *
 * @author Akash Yadav
 */
class DebugOverlayManager private constructor(
    private val windowManager: WindowManager,
    private val binding: DebuggerActionsWindowBinding,
    private val touchSlop: Int = ViewConfiguration.get(binding.root.context).scaledTouchSlop,
) {
    private var initialWindowX = 0
    private var initialWindowY = 0
    private var initialTouchX = 0f
    private var initialTouchY = 0f
    private var isDragging = false

    init {
        binding.dragHandle.root.icon = ContextCompat.getDrawable(binding.root.context, R.drawable.ic_drag_handle)

        binding.dragHandle.root.setOnTouchListener { v, event ->
            when(event.action) {
                MotionEvent.ACTION_DOWN -> {
                    initialWindowX = overlayLayoutParams.x
                    initialWindowY = overlayLayoutParams.y
                    initialTouchX = event.rawX
                    initialTouchY = event.rawY
                    true
                }

                MotionEvent.ACTION_MOVE -> {
                    val deltaX = (event.rawX - initialTouchX).toInt()
                    val deltaY = (event.rawY - initialTouchY).toInt()
                    if (isDragging || deltaX > touchSlop || deltaY > touchSlop) {
                        isDragging = true
                        overlayLayoutParams.x = initialWindowX + deltaX
                        overlayLayoutParams.y = initialWindowY + deltaY
                        windowManager.updateViewLayout(binding.root, overlayLayoutParams)
                        true
                    } else false
                }

                MotionEvent.ACTION_UP -> {
                    isDragging = false
                    val deltaX = abs(event.rawX - initialTouchX)
                    val deltaY = abs(event.rawY - initialTouchY)
                    if (deltaX < touchSlop && deltaY < touchSlop) {
                        v.performClick()
                    }
                    true
                }

                else -> false
            }
        }
    }

    private var isShown = false
    private val overlayLayoutParams by lazy {
        WindowManager.LayoutParams(
            /* w = */ WindowManager.LayoutParams.WRAP_CONTENT,
            /* h = */ WindowManager.LayoutParams.WRAP_CONTENT,
            /* _type = */ WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,
            /* _flags = */ WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
            /* _format = */ PixelFormat.TRANSLUCENT
        ).apply {
            gravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL
        }
    }

    fun show() {
        if (isShown) {
            return
        }

        windowManager.addView(binding.root, overlayLayoutParams)
        isShown = true
    }

    fun hide() {
        if (!isShown) {
            return
        }

        windowManager.removeView(binding.root)
        isShown = false
    }

    companion object {

        private val logger = LoggerFactory.getLogger(DebugOverlayManager::class.java)

        /**
         * Create a new [DebugOverlayManager] from the given [Context].
         *
         * @param ctx The [Context] to use for creating the [DebugOverlayManager].
         * @return A new [DebugOverlayManager].
         */
        fun create(
            scope: CoroutineScope,
            ctx: Context
        ): DebugOverlayManager {
            // IMPORTANT!
            // Wrap the context with a theme, so we could use MaterialButtons!
            val context = ContextThemeWrapper(ctx, R.style.Theme_AndroidIDE)
            val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
            val inflater = LayoutInflater.from(context)

            // noinspection InflateParams
            val layout = DebuggerActionsWindowBinding.inflate(inflater)

            val actionsRegistry = ActionsRegistry.getInstance()
            val debuggerActions = actionsRegistry.getActions(ActionItem.Location.DEBUGGER_ACTIONS)

            val actions = debuggerActions.values.toList()
            val adapter = DebuggerActionsOverlayAdapter(actions)
            layout.actions.adapter = adapter

            scope.launch {
                IDEDebugClientImpl.requireInstance().connectionStateFlow
                    .collectLatest {
                        logger.debug("connection state updated to: {}", it)
                        withContext(Dispatchers.Main) {
                            // noinspection NotifyDataSetChanged
                            adapter.notifyDataSetChanged()
                        }
                    }
            }

            return DebugOverlayManager(
                windowManager,
                layout,
            )
        }
    }
}


================================================
File: java/com/itsaky/androidide/services/debug/DebuggerActionsOverlayAdapter.kt
================================================
package com.itsaky.androidide.services.debug

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.appcompat.widget.TooltipCompat
import androidx.recyclerview.widget.RecyclerView
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.actions.internal.DefaultActionsRegistry
import com.itsaky.androidide.editor.databinding.LayoutPopupMenuItemBinding

/**
 * @author Akash Yadav
 */
class DebuggerActionsOverlayAdapter(
    actions: List<ActionItem>,
): RecyclerView.Adapter<DebuggerActionsOverlayAdapter.VH>() {

    private val actions = actions.sortedBy { action -> action.order }
    private val actionsRegister = ActionsRegistry.getInstance() as DefaultActionsRegistry

    class VH(
        val binding: LayoutPopupMenuItemBinding
    ): RecyclerView.ViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
        val inflater = LayoutInflater.from(parent.context)
        val binding = LayoutPopupMenuItemBinding.inflate(inflater, parent, false)
        return VH(binding)
    }

    override fun getItemCount() = actions.size

    override fun onBindViewHolder(holder: VH, position: Int) {
        val binding = holder.binding
        val action = actions[position]
        val data = ActionData.create(binding.root.context)

        action.prepare(data)

        binding.root.icon = action.icon
        binding.root.isEnabled = action.enabled
        binding.root.alpha = if (action.enabled) 1f else 0.5f
        TooltipCompat.setTooltipText(binding.root, action.label)

        binding.root.setOnClickListener {
            actionsRegister.executeAction(action, data)
        }
    }
}


================================================
File: java/com/itsaky/androidide/services/debug/DebuggerService.kt
================================================
package com.itsaky.androidide.services.debug

import android.app.Service
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.IBinder
import androidx.core.content.ContextCompat
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.actions.debug.SuspendResumeVmAction
import com.itsaky.androidide.actions.debug.RestartVmAction
import com.itsaky.androidide.actions.debug.StepIntoAction
import com.itsaky.androidide.actions.debug.StepOutAction
import com.itsaky.androidide.actions.debug.StepOverAction
import com.itsaky.androidide.actions.debug.KillVmAction
import com.itsaky.androidide.buildinfo.BuildInfo
import com.itsaky.androidide.tasks.cancelIfActive
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import org.slf4j.LoggerFactory

/**
 * @author Akash Yadav
 */
class DebuggerService : Service() {

    inner class Binder : android.os.Binder() {
        fun getService(): DebuggerService = this@DebuggerService
    }

    private val actionsRegistry = ActionsRegistry.getInstance()
    private lateinit var actionsList: List<ActionItem>
    private lateinit var overlayManager: DebugOverlayManager
    private val binder = Binder()
    private val serviceScope = CoroutineScope(Dispatchers.Default)

    internal var targetPackage: String? = null

    private var foregroundAppReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent?) {
            if (intent?.action != ForegroundDetectionService.ACTION_FOREGROUND_APP_CHANGED) {
                return
            }

            val packageName = intent.getStringExtra(ForegroundDetectionService.EXTRA_PACKAGE_NAME)
            logger.debug("onReceive: packageName={} targetPackage={}", packageName, targetPackage)
            if (packageName == BuildInfo.PACKAGE_NAME || (targetPackage != null && packageName == targetPackage)) {
                showOverlay()
            } else {
                hideOverlay()
            }
        }
    }

    companion object {
        private val logger = LoggerFactory.getLogger(DebuggerService::class.java)
    }

    override fun onCreate() {
        logger.debug("onCreate()")
        super.onCreate()

        val context = this
        actionsList = mutableListOf<ActionItem>().apply {
            add(SuspendResumeVmAction(context))
            add(StepOverAction(context))
            add(StepIntoAction(context))
            add(StepOutAction(context))
            add(KillVmAction(context))
            add(RestartVmAction(context))
        }

        this.actionsList.forEach(actionsRegistry::registerAction)
        this.overlayManager = DebugOverlayManager.create(serviceScope, this)

        ContextCompat.registerReceiver(
            this,
            foregroundAppReceiver,
            IntentFilter(ForegroundDetectionService.ACTION_FOREGROUND_APP_CHANGED),
            ContextCompat.RECEIVER_NOT_EXPORTED,
        )
    }

    override fun onDestroy() {
        logger.debug("onDestroy()")
        targetPackage = null
        serviceScope.cancelIfActive("DebuggerService is being destroyed")

        try {
            overlayManager.hide()
        } catch (err: Throwable) {
            logger.error("Failed to hide debugger overlay", err)
        }

        super.onDestroy()

        unregisterReceiver(foregroundAppReceiver)
        actionsList.forEach(actionsRegistry::unregisterAction)
    }

    fun showOverlay() {
        logger.debug("showOverlay()")
        this.overlayManager.show()
    }

    fun hideOverlay() {
        logger.debug("hideOverlay()")
        this.overlayManager.hide()
    }

    override fun onBind(intent: Intent?): IBinder =
        this.binder

    override fun onStartCommand(
        intent: Intent?,
        flags: Int,
        startId: Int
    ): Int {
        logger.debug("onStartCommand()")
        // if the service is killed by the system, there is no point in restarting it
        return START_NOT_STICKY
    }
}


================================================
File: java/com/itsaky/androidide/services/debug/DebuggerStatusProvider.kt
================================================
package com.itsaky.androidide.services.debug

import android.content.ContentProvider
import android.content.ContentValues
import android.database.Cursor
import android.database.MatrixCursor
import android.net.Uri
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.lsp.IDEDebugClientImpl
import org.slf4j.LoggerFactory

class DebuggerStatusProvider : ContentProvider() {

    companion object {
        private val logger = LoggerFactory.getLogger(DebuggerStatusProvider::class.java)
    }

    override fun onCreate(): Boolean = false

    override fun query(
        uri: Uri,
        projection: Array<out String>?,
        selection: String?,
        selectionArgs: Array<out String>?,
        sortOrder: String?
    ): Cursor? {
        if (uri.authority != "org.adfa.cogo.debugger") {
            logger.error("Invalid authority: ${uri.authority}")
            return null
        }

        val debugClient = Lookup.getDefault().lookup(IDEDebugClientImpl::class.java)
        if (debugClient == null) {
            logger.error("Unable to find debug client")
            return null
        }

        var status = "active"
        if (debugClient.isVmConnected()) {
            status = "connected"
        }

        val cursor = MatrixCursor(arrayOf("status"))
        cursor.addRow(arrayOf(status))
        return cursor
    }

    override fun getType(uri: Uri): String? = null

    override fun insert(uri: Uri, values: ContentValues?): Uri? = null

    override fun delete(uri: Uri, selection: String?, selectionArgs: Array<out String>?): Int = 0

    override fun update(
        uri: Uri,
        values: ContentValues?,
        selection: String?,
        selectionArgs: Array<out String>?
    ): Int = 0
}


================================================
File: java/com/itsaky/androidide/services/debug/ForegroundDetectorService.kt
================================================
package com.itsaky.androidide.services.debug

import android.accessibilityservice.AccessibilityService
import android.content.Intent
import android.view.accessibility.AccessibilityEvent
import com.itsaky.androidide.buildinfo.BuildInfo
import org.slf4j.LoggerFactory

class ForegroundDetectionService : AccessibilityService() {

    /**
     * The package name of the application that is currently in foreground.
     */
    private var currentForegroundApp = ""

    companion object {
        const val ACTION_FOREGROUND_APP_CHANGED = "${BuildInfo.PACKAGE_NAME}.foreground_app"
        const val EXTRA_PACKAGE_NAME = "$ACTION_FOREGROUND_APP_CHANGED.package_name"
        const val EXTRA_CLASS_NAME = "$ACTION_FOREGROUND_APP_CHANGED.class_name"

        const val PERMISSION_RECEIVE_FOREGROUND_WINDOW_UPDATES = "org.adfa.cogo.permission.RECEIVE_FOREGROUND_WINDOW_UPDATES"

        private val logger = LoggerFactory.getLogger(ForegroundDetectionService::class.java)
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent) {
        if (event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) {
            val packageName = if (event.packageName != null) event.packageName.toString() else ""
            val className = if (event.className != null) event.className.toString() else ""
            if (packageName != currentForegroundApp) {
                currentForegroundApp = packageName
                notifyListeners(packageName, className)
            }
        }
    }

    private fun notifyListeners(
        packageName: String,
        className: String
    ) {
        sendOrderedBroadcast(Intent().apply {
            action = ACTION_FOREGROUND_APP_CHANGED
            putExtra(EXTRA_PACKAGE_NAME, packageName)
            putExtra(EXTRA_CLASS_NAME, className)
        }, PERMISSION_RECEIVE_FOREGROUND_WINDOW_UPDATES)
    }

    override fun onInterrupt() {
        // ignored
    }
}


================================================
File: java/com/itsaky/androidide/services/log/CachingLogSender.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import com.itsaky.androidide.logsender.ILogSender

/**
 * An implementation of [ILogSender] which caches the ID, PID and package name from the provided sender.
 *
 * @author Akash Yadav
 */
class CachingLogSender(
  private val sender: ILogSender,
  internal val port: Int,
  internal var isStarted: Boolean
) : ILogSender by sender {

  private var cachedPid: Int = -1
  private var cachedId: String? = null
  private var cachedPckName: String? = null

  override fun getPid(): Int {
    if (this.cachedPid != -1) {
      return this.cachedPid
    }
    return sender.pid.also { this.cachedPid = it }
  }

  override fun getPackageName(): String {
    return this.cachedPckName ?: sender.packageName.also { this.cachedPckName = it }
  }

  override fun getId(): String {
    return this.cachedId ?: sender.id.also { this.cachedId = it }
  }
}


================================================
File: java/com/itsaky/androidide/services/log/ConnectionObserverParams.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import android.content.Intent
import android.os.Bundle

/**
 * Arguments passed to a connection observer from [LogReceiverImpl].
 *
 * @property clientId The unique identifier for the client that was connected or disconnected.
 * @property totalConnections The total number of connections after this client was connected/disconnected.
 * @author Akash Yadav
 */
data class ConnectionObserverParams(val clientId: String, val totalConnections: Int) {

  companion object {

    const val KEY_CLIENT_ID = "com.itsaky.androidide.logreceiver.connectedClientId"
    const val KEY_CONNECTION_COUNT = "com.itsaky.androidide.logreceiver.connectionCount"

    @JvmStatic
    internal fun from(intent: Intent?): ConnectionObserverParams? {
      val clientId = intent?.getStringExtra(KEY_CLIENT_ID) ?: return null
      val connectionCount = intent.getIntExtra(KEY_CONNECTION_COUNT, -1)
      if (connectionCount == -1) {
        return null
      }

      return ConnectionObserverParams(clientId, connectionCount)
    }
  }

  internal fun bundle(): Bundle {
    return Bundle().apply {
      putString(KEY_CLIENT_ID, clientId)
      putInt(KEY_CONNECTION_COUNT, totalConnections)
    }
  }
}



================================================
File: java/com/itsaky/androidide/services/log/LogReceiverImpl.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import android.util.Log
import com.itsaky.androidide.logsender.ILogReceiver
import com.itsaky.androidide.logsender.ILogSender
import com.itsaky.androidide.models.LogLine
import com.itsaky.androidide.tasks.executeAsyncProvideError
import org.slf4j.LoggerFactory
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

/**
 * Handles IPC connections from other proceses.
 *
 * @author Akash Yadav
 */
class LogReceiverImpl(consumer: ((LogLine) -> Unit)? = null) : ILogReceiver.Stub(), AutoCloseable {

  private val senderHandler = MultiLogSenderHandler()
  private val senders = LogSendersRegistry()
  private val consumerLock = ReentrantLock(true)
  private val shouldStartReaders = AtomicBoolean(false)

  internal var connectionObserver: ((ConnectionObserverParams) -> Unit)? = null

  internal var consumer: ((LogLine) -> Unit)? = consumer
    set(value) {
      field = value
      senderHandler.consumer = value?.let { synchronizeConsumer(value) }
    }

  companion object {

    private val log = LoggerFactory.getLogger(LogReceiverImpl::class.java)
  }

  private fun synchronizeConsumer(consumer: (LogLine) -> Unit): (LogLine) -> Unit {
    return { line -> consumerLock.withLock { consumer(line) } }
  }

  fun acceptSenders() {
    if (senderHandler.isAlive()) {
      return
    }

    log.info("Starting log sender handler..")
    senderHandler.start()
  }

  override fun ping() {
    doAsync("ping") {
      Log.d("LogRecevier", "ping: Received a ping request")
    }
  }

  override fun connect(sender: ILogSender?) {
    doAsync("connect") {
      val port = senderHandler.getPort()
      if (port == -1) {
        log.error("A log sender is trying to connect, but log receiver is not started")
        return@doAsync
      }

      val caching = sender?.let { CachingLogSender(it, port, false) } ?: return@doAsync

      val existingSender = senders.getByPackage(caching.packageName)

      if (existingSender != null) {
        senderHandler.removeClient(existingSender.id)
      }

      if (existingSender?.isAlive() == true) {
        log.warn(
          "Client '${existingSender.packageName}' has been restarted with process ID '${caching.pid}'" +
              " Previous connection with process ID '${existingSender.pid}' will be closed...")
        existingSender.onDisconnect()
      }

      connectSender(caching, port)
    }
  }

  private fun connectSender(caching: CachingLogSender, port: Int) {
    // logging this also makes sure that the package name, pid and sender ID are
    // cached when the sender binds to the service
    // these fields are then used on disconnectAll()
    log.info("Connecting to client {}:{}:{}", caching.packageName, caching.pid, caching.id)

    this.senders.put(caching)

    if (shouldStartReaders.get()) {
      caching.startReader(port)
      caching.isStarted = true
    }

    logTotalConnected()

    notifyConnectionObserver(caching.id)
  }

  internal fun startReaders() {
    this.shouldStartReaders.set(true)

    doAsync("startReaders") {
      senders.getPendingSenders().forEach { sender ->
        log.info("Notifying sender '{}' to start reading logs...", sender.packageName)
        sender.startReader(sender.port)
      }
    }
  }

  override fun disconnect(packageName: String, senderId: String) {
    doAsync("disconnect") {
      val port = senderHandler.getPort()
      if (port == -1) {
        return@doAsync
      }

      if (!senders.containsKey(packageName)) {
        log.warn(
          "Received disconnect request from a log sender which is not connected: '${packageName}'")
        return@doAsync
      }

      disconnectSender(packageName, senderId)
    }
  }

  internal fun disconnectAll() {
    log.debug("Disconnecting from all senders...")
    this.senders.forEach { sender ->
      try {
        sender.onDisconnect()
        disconnectSender(sender.packageName, sender.id)
      } catch (e: Exception) {
        log.error("Failed to disconnect from sender", e)
      }
    }
  }

  private fun disconnectSender(packageName: String, senderId: String) {
    log.info("Disconnecting from client: '{}'", packageName)
    this.senderHandler.removeClient(senderId)
    this.senders.remove(packageName)
    logTotalConnected()

    notifyConnectionObserver(senderId)
  }

  override fun close() {
    // TODO : Send close request to clients
    senderHandler.close()
    consumer = null
    connectionObserver = null
    senders.clear()
  }

  private fun doAsync(actionName: String, action: () -> Unit) {
    executeAsyncProvideError(action::invoke) { _, error ->
      if (error != null) {
        log.error("Failed to perform action '{}'", actionName, error)
      }
    }
  }

  private fun notifyConnectionObserver(senderId: String) {
    connectionObserver?.invoke(ConnectionObserverParams(senderId, this.senders.size))
  }

  private fun logTotalConnected() {
    log.info("Total clients connected: {}", senders.size)
  }
}


================================================
File: java/com/itsaky/androidide/services/log/LogReceiverService.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import android.app.Service
import android.content.Intent
import android.os.IBinder
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import com.itsaky.androidide.logsender.LogSender
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.models.LogLine
import com.itsaky.androidide.preferences.internal.DevOpsPreferences
import org.slf4j.LoggerFactory
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Service for handling log lines that are sent by the client applications.
 *
 * @author Akash Yadav
 */
class LogReceiverService : Service() {

  private val binder = LogReceiverImpl()
  private val started = AtomicBoolean(false)
  private val isBoundToConsumer = AtomicBoolean(false)

  private val scheduledExecutor = Executors.newSingleThreadScheduledExecutor()

  companion object {

    private val log = LoggerFactory.getLogger(LogReceiverService::class.java)

    internal const val ACTION_CONNECT_LOG_CONSUMER = "com.itsaky.androidide.logrecevier.CONNECT_LOG_CONSUMER"
    internal const val ACTION_CONNECTION_UPDATE = "com.itsaky.androidide.logreceiver.CONNECTION_UPDATE"

    private const val LOG_CONSUMER_WAIT_DURATION = 10 // seconds

    @JvmStatic
    internal val LOOKUP_KEY = Lookup.Key<LogReceiverService>()
  }

  override fun onCreate() {
    super.onCreate()
    Lookup.getDefault().update(LOOKUP_KEY, this)
    log.info("LogReceiverService has been created")
  }

  override fun onBind(intent: Intent?): IBinder? {
    log.debug("Received bind request: {}", intent)

    if (!DevOpsPreferences.logsenderEnabled) {
      log.debug("Rejecting bind request. LogReceiver is disabled.")
      return null
    }

    if (intent?.action == ACTION_CONNECT_LOG_CONSUMER) {
      if (isBoundToConsumer.get()) {
        log.warn("LogReceiverService is limited to one consumer only.")
        return null
      }

      log.info("Log consumer has been bound")
      return startBinderAndGet().also { binder ->
        binder.startReaders()
        isBoundToConsumer.set(true)
      }
    }

    if (intent?.action != LogSender.SERVICE_ACTION) {
      log.debug("Rejecting bind request: action={}", intent?.action)
      return null
    }

    log.debug("Accepting bind request...")
    return startBinderAndGet().also {
      if (!isBoundToConsumer.get()) {
        // listen for consumers to bind to the service for next LOG_CONSUMER_WAIT_DURATION
        // if the consumer still does not connect, disconnect from all senders and stop the service
        listenForConsumer()
      }
    }
  }

  override fun onUnbind(intent: Intent?): Boolean {
    return super.onUnbind(intent)
  }

  private fun startBinderAndGet(): LogReceiverImpl {
    return binder.also {
      if (!started.getAndSet(true)) {
        binder.acceptSenders()
        binder.connectionObserver = this::onConnectionUpdated
      }
    }
  }

  override fun onDestroy() {
    super.onDestroy()
    log.debug("LogReceiverService is being destroyed...")
    binder.close()
    started.set(false)
    try {
      scheduledExecutor.shutdownNow()
    } catch (e: Exception) {
      // ignored
    }
    Lookup.getDefault().unregister(LOOKUP_KEY)
  }

  fun setConsumer(consumer: ((LogLine) -> Unit)?) {
    binder.consumer = consumer
  }

  private fun onConnectionUpdated(params: ConnectionObserverParams) {
    val intent = Intent(ACTION_CONNECTION_UPDATE)
    intent.putExtras(params.bundle())
    LocalBroadcastManager.getInstance(this).sendBroadcastSync(intent)
  }

  private fun listenForConsumer() {
    log.debug("Waiting for log consumer...")
    scheduledExecutor.schedule({
      if (!isBoundToConsumer.get()) {
        // ask senders to disconnect
        log.debug("No log consumer has been bound to the log receiver service")
        binder.disconnectAll()
      }
    }, LOG_CONSUMER_WAIT_DURATION.toLong(), TimeUnit.SECONDS)
  }

  /**
   * Disconnects all connected log senders. Disconnecting all senders will eventually lead
   * to this service being destroyed.
   */
  internal fun disconnectAll() {
    if (started.get()) {
      binder.disconnectAll()
    }
  }
}

/**
 * Lookup the instance of [LogReceiverService] in the [Lookup] registry.
 *
 * @return The [LogReceiverService] instance or `null` it the service is not registered.
 */
fun lookupLogService(): LogReceiverService? {
  return Lookup.getDefault().lookup(LogReceiverService.LOOKUP_KEY)
}



================================================
File: java/com/itsaky/androidide/services/log/LogReceiverServiceConnection.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import android.content.ComponentName
import android.content.ServiceConnection
import android.os.IBinder

/**
 * [ServiceConnection] for [LogReceiverService].
 *
 * @author Akash Yadav
 */
class LogReceiverServiceConnection(var onConnected: ((binder: LogReceiverImpl?) -> Unit)? = null) : ServiceConnection {

  override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
    onConnected?.invoke(service as? LogReceiverImpl?)
  }

  override fun onServiceDisconnected(name: ComponentName?) {
    onConnected = null
  }
}



================================================
File: java/com/itsaky/androidide/services/log/LogSenderHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import com.itsaky.androidide.logsender.socket.SenderInfoCommand
import com.itsaky.androidide.models.LogLine
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import java.net.Socket
import java.net.SocketException

/**
 * Handles a single log sender.
 *
 * @author Akash Yadav
 */
class LogSenderHandler(private val sender: SenderInfoCommand, private val socket: Socket,
  internal var consumer: ((LogLine) -> Unit)? = null,
  private var onClose: ((String) -> Unit)? = null) : AutoCloseable {

  private var manuallyClosed = false

  companion object {

    private val log = LoggerFactory.getLogger(LogSenderHandler::class.java)
  }

  suspend fun startAsync() = withContext(Dispatchers.IO) {
    try {
      socket.getInputStream().bufferedReader().use { reader ->
        while (!socket.isClosed) {
          try {
            LogLine.forLogString(reader.readLine())?.let { line -> consumer?.invoke(line) }
          } catch (cancellation: CancellationException) {
            break
          }
        }
      }
    } catch (err: SocketException) {
      if (!manuallyClosed) {
        log.error("An error occurred while reading from socket", err)
      }
    } finally {
      close()
    }
  }

  override fun close() {
    try {
      manuallyClosed = true

      if (!socket.isClosed) {
        log.debug("Closing log sender handler...")
        socket.close()
      }
    } catch (err: Throwable) {
      log.error("Failed to close socket", err)
    } finally {
      onClose?.invoke(this.sender.senderId)
      this.consumer = null
      this.onClose = null
    }
  }
}



================================================
File: java/com/itsaky/androidide/services/log/LogSendersRegistry.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import java.util.concurrent.ConcurrentHashMap

/**
 * @author Akash Yadav
 */
internal class LogSendersRegistry {

  private val senders = ConcurrentHashMap<String, CachingLogSender>()
  private val idToPck = ConcurrentHashMap<String, String>()

  val size: Int
    get() = this.senders.size

  fun getPendingSenders(): List<CachingLogSender> {
    return this.senders.mapNotNull { (_, sender) -> if (sender.isStarted) null else sender }
  }

  fun getByPackage(packageName: String): CachingLogSender? {
    return this.senders[packageName]
  }

  fun containsKey(packageOrId: String): Boolean {
    if (senders.containsKey(packageOrId)) {
      return true
    }

    return getById(packageOrId) != null
  }

  fun getById(senderId: String): CachingLogSender? {
    return this.idToPck[senderId]?.let(senders::get)
  }

  fun put(sender: CachingLogSender) {
    this.senders[sender.packageName] = sender
    this.idToPck[sender.id] = sender.packageName
  }

  fun remove(packageName: String) {
    this.senders.remove(packageName)

    val iterator = this.idToPck.iterator()
    for (entry in iterator) {
      if (entry.value == packageName) {
        iterator.remove()
      }
    }
  }

  fun clear() {
    this.senders.clear()
    this.idToPck.clear()
  }

  fun forEach(action: (CachingLogSender) -> Unit) {
    this.senders.forEachValue(1, action::invoke)
  }
}


================================================
File: java/com/itsaky/androidide/services/log/MultiLogSenderHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import com.itsaky.androidide.logsender.socket.SenderInfoCommand
import com.itsaky.androidide.logsender.socket.SocketCommandParser
import com.itsaky.androidide.models.LogLine
import com.itsaky.androidide.tasks.cancelIfActive
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import java.lang.Thread.currentThread
import java.net.ServerSocket
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger

/**
 * Handles clients that connect to the log receiver.
 *
 * @author Akash Yadav
 */
class MultiLogSenderHandler(consumer: ((LogLine) -> Unit)? = null) : AutoCloseable {

  private val clients = ConcurrentHashMap<String, LogSenderHandler>()
  private val port = AtomicInteger(-1)
  private var isAlive = AtomicBoolean(false)

  private var logHandlerScope = CoroutineScope(
    Dispatchers.IO + CoroutineName("MultiLogSenderHandler"))

  internal var consumer: ((LogLine) -> Unit)? = consumer
    set(value) {
      field = value
      clients.forEach { (_, client) -> client.consumer = value }
    }

  companion object {
    private val log = LoggerFactory.getLogger(MultiLogSenderHandler::class.java)
  }

  fun getPort(): Int {
    return port.get()
  }

  private suspend fun startAsync() = withContext(Dispatchers.IO) {
    val job = coroutineContext[Job]
    val server = try {
      ServerSocket(0)
    } catch (err: Exception) {
      log.error("Failed to start log receiver socket", err)
      return@withContext
    }

    try {
      port.set(server.localPort)
      log.info("Starting log receiver server socket at port {}", getPort())

      while (job?.isCancelled != true && isAlive.get()) {
        val clientSocket = server.accept()

        val senderInfoLine = clientSocket.getInputStream().bufferedReader().readLine()
        val command = SocketCommandParser.parse(senderInfoLine)
        if (command == null || command !is SenderInfoCommand) {
          log.error(
            "Cannot accept log sender client. A sender must send the /sender command first.")
          clientSocket.use {}
          continue
        }

        val handler = LogSenderHandler(command, clientSocket, consumer, ::removeClient)

        log.info("A log sender has been connected")

        clients[command.senderId] = handler

        handler.startAsync()
      }
    } catch (interrupt: InterruptedException) {
      log.warn("MultiLogSenderHandler thread has been interrupted")
      currentThread().interrupt()
    } catch (err: Throwable) {
      log.error("An error occurred while accept log client connections", err)
    } finally {
      this@MultiLogSenderHandler.close()
      server.close()
    }
  }

  internal fun removeClient(senderId: String) {
    clients.remove(senderId)?.closeAndLogError()
  }

  private fun removeAllClients() {
    this.clients.forEach { (_, handler) ->
      handler.closeAndLogError()
    }

    this.clients.clear()
  }

  fun start() {
    isAlive.set(true)
    logHandlerScope.launch {
      startAsync()
    }
  }

  fun isAlive() = isAlive.get()

  override fun close() {
    this.isAlive.set(false)
    this.removeAllClients()
    this.consumer = null
    this.logHandlerScope.cancelIfActive()
  }

  private fun LogSenderHandler.closeAndLogError() {
    try {
      close()
    } catch (e: Exception) {
      log.warn("Failed to close", e)
    }
  }
}



================================================
File: java/com/itsaky/androidide/services/log/utils.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.services.log

import android.os.RemoteException
import com.itsaky.androidide.logsender.ILogSender

fun ILogSender.isAlive() : Boolean {
  return try {
    ping()
    true
  } catch (err: RemoteException) {
    false
  }
}


================================================
File: java/com/itsaky/androidide/tasks/callables/FileTreeCallable.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/

package com.itsaky.androidide.tasks.callables;

import android.content.Context;
import com.itsaky.androidide.adapters.viewholders.FileTreeViewHolder;
import com.unnamed.b.atv.model.TreeNode;
import java.io.File;
import java.io.FileFilter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.concurrent.Callable;

public class FileTreeCallable implements Callable<Boolean> {
  private final Context ctx;
  private final TreeNode parent;
  private final File file;

  public FileTreeCallable(Context ctx, TreeNode parent, File file) {
    this.ctx = ctx;
    this.parent = parent;
    this.file = file;
  }

  @Override
  public Boolean call() throws Exception {
    getNodeFromArray(file.listFiles(/*new HiddenFilesFilter()*/ ), parent);
    return true;
  }

  private void getNodeFromArray(File[] files, TreeNode parent) {
    Arrays.sort(files, new SortFileName());
    Arrays.sort(files, new SortFolder());
    for (File file : files) {
      TreeNode node = new TreeNode(file);
      node.setViewHolder(new FileTreeViewHolder(ctx));
      parent.addChild(node, false);
    }
  }

  public static class HiddenFilesFilter implements FileFilter {

    @Override
    public boolean accept(File p1) {
      return !p1.getName().startsWith(".");
    }
  }

  public static class SortFileName implements Comparator<File> {
    @Override
    public int compare(File f1, File f2) {
      return f1.getName().compareTo(f2.getName());
    }
  }

  public static class SortFolder implements Comparator<File> {
    @Override
    public int compare(File f1, File f2) {
      if (f1.isDirectory() == f2.isDirectory()) return 0;
      else if (f1.isDirectory() && !f2.isDirectory()) return -1;
      else return 1;
    }
  }
}



================================================
File: java/com/itsaky/androidide/tasks/callables/ListDirectoryCallable.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/

package com.itsaky.androidide.tasks.callables;

import android.text.TextUtils;
import com.blankj.utilcode.util.FileUtils;
import java.io.File;
import java.io.FileFilter;

public class ListDirectoryCallable implements java.util.concurrent.Callable<String> {

  private final FileFilter ARCHIVE_FILTER =
      new FileFilter() {

        @Override
        public boolean accept(File p1) {
          return p1.isFile() && (p1.getName().endsWith(".tar.xz") || p1.getName().endsWith(".zip"));
        }
      };
  private File file;

  public ListDirectoryCallable(File file) {
    this.file = file;
  }

  @Override
  public String call() throws Exception {
    return TextUtils.join("\n", FileUtils.listFilesInDirWithFilter(file, ARCHIVE_FILTER, false));
  }
}



================================================
File: java/com/itsaky/androidide/tasks/callables/UnzipCallable.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/

package com.itsaky.androidide.tasks.callables;

import com.blankj.utilcode.util.ZipUtils;
import java.io.File;
import java.util.List;
import java.util.concurrent.Callable;

public final class UnzipCallable implements Callable<List<File>> {

  private File src;
  private File dest;

  public UnzipCallable(File src, File dest) {
    this.src = src;
    this.dest = dest;
  }

  @Override
  public List<File> call() throws Exception {
    return ZipUtils.unzipFile(src, dest);
  }
}



================================================
File: java/com/itsaky/androidide/ui/CodeEditorView.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.ui

import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import androidx.appcompat.widget.LinearLayoutCompat
import androidx.core.view.isVisible
import com.blankj.utilcode.util.SizeUtils
import com.itsaky.androidide.activities.editor.BaseEditorActivity
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.editor.api.IEditor
import com.itsaky.androidide.editor.databinding.LayoutCodeEditorBinding
import com.itsaky.androidide.editor.events.FileUpdateEvent
import com.itsaky.androidide.editor.events.LanguageUpdateEvent
import com.itsaky.androidide.editor.language.IDELanguage
import com.itsaky.androidide.editor.ui.EditorSearchLayout
import com.itsaky.androidide.editor.ui.IDEEditor
import com.itsaky.androidide.editor.ui.IDEEditor.Companion.createInputTypeFlags
import com.itsaky.androidide.editor.utils.ContentReadWrite.readContent
import com.itsaky.androidide.editor.utils.ContentReadWrite.writeTo
import com.itsaky.androidide.eventbus.events.preferences.PreferenceChangeEvent
import com.itsaky.androidide.lsp.BreakpointHandler
import com.itsaky.androidide.lsp.IDEDebugClientImpl
import com.itsaky.androidide.lsp.IDELanguageClientImpl
import com.itsaky.androidide.lsp.api.ILanguageServer
import com.itsaky.androidide.lsp.api.ILanguageServerRegistry
import com.itsaky.androidide.lsp.java.JavaLanguageServer
import com.itsaky.androidide.lsp.xml.XMLLanguageServer
import com.itsaky.androidide.models.Range
import com.itsaky.androidide.preferences.internal.EditorPreferences
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import com.itsaky.androidide.tasks.cancelIfActive
import com.itsaky.androidide.tasks.runOnUiThread
import com.itsaky.androidide.utils.customOrJBMono
import io.github.rosemoe.sora.event.ClickEvent
import io.github.rosemoe.sora.event.InterceptTarget
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.text.LineSeparator
import io.github.rosemoe.sora.util.IntPair
import io.github.rosemoe.sora.widget.CodeEditor
import io.github.rosemoe.sora.widget.DirectAccessProps
import io.github.rosemoe.sora.widget.REGION_LINE_NUMBER
import io.github.rosemoe.sora.widget.component.Magnifier
import io.github.rosemoe.sora.widget.resolveTouchRegion
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.launch
import kotlinx.coroutines.newSingleThreadContext
import kotlinx.coroutines.withContext
import org.greenrobot.eventbus.EventBus
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode
import org.slf4j.LoggerFactory
import java.io.Closeable
import java.io.File

/**
 * A view that handles opened code editor.
 *
 * @author Akash Yadav
 */
@SuppressLint("ViewConstructor")
class CodeEditorView(
  context: Context,
  file: File,
  selection: Range
) : LinearLayoutCompat(context), BreakpointHandler.EventListener, Closeable {

  private var _binding: LayoutCodeEditorBinding? = null
  private var _searchLayout: EditorSearchLayout? = null

  private val codeEditorScope = CoroutineScope(
    Dispatchers.Default + CoroutineName("CodeEditorView"))

  /**
   * The [CoroutineContext][kotlin.coroutines.CoroutineContext] used to reading and writing the file
   * in this editor. We use a separate, single-threaded context assuming that the file will be either
   * read from or written to at a time, but not both. If in future we add support for anything like
   * that, the number of thread should probably be increased.
   */
  @OptIn(DelicateCoroutinesApi::class, ExperimentalCoroutinesApi::class)
  private val readWriteContext = newSingleThreadContext("CodeEditorView")

  private val binding: LayoutCodeEditorBinding
    get() = checkNotNull(_binding) { "Binding has been destroyed" }

  private val searchLayout: EditorSearchLayout
    get() = checkNotNull(_searchLayout) { "Search layout has been destroyed" }

  /**
   * Get the file of this editor.
   */
  val file: File?
    get() = editor?.file

  /**
   * Get the [IDEEditor] instance of this editor view.
   */
  val editor: IDEEditor?
    get() = _binding?.editor

  /**
   * Returns whether the content of the editor has been modified.
   *
   * @see IDEEditor.isModified
   */
  val isModified: Boolean
    get() = editor?.isModified ?: false

  companion object {

    private val log = LoggerFactory.getLogger(CodeEditorView::class.java)
  }

  init {
    val debugClient = IDEDebugClientImpl.requireInstance()
    debugClient.breakpoints.addListener(this)

    _binding = LayoutCodeEditorBinding.inflate(LayoutInflater.from(context))

    binding.editor.apply {
      isHighlightCurrentBlock = true
      dividerWidth = SizeUtils.dp2px(2f).toFloat()
      colorScheme = SchemeAndroidIDE.newInstance(context)
      lineSeparator = LineSeparator.LF

      props.apply {
        autoCompletionOnComposing = true
        drawCustomLineBgOnCurrentLine = true
        cursorLineBgOverlapBehavior = DirectAccessProps.CURSOR_LINE_BG_OVERLAP_MIXED
      }

      subscribeEvent(ClickEvent::class.java) { event, _ ->
        // if the editor is not backed by a file, then there's no point in adding a breakpoint
        val editorFile = this.file ?: return@subscribeEvent
        val region = IntPair.getFirst(resolveTouchRegion(event.causingEvent))
        if (region == REGION_LINE_NUMBER) {
          val language = editorLanguage as? IDELanguage? ?: return@subscribeEvent
          val server = languageServer ?: return@subscribeEvent
          if (server.debugAdapter != null) {
            event.intercept(InterceptTarget.TARGET_EDITOR)

            // If we already have a breakpoint added, we won't have received this event
            // this is because the click is consumed by the SideIconClickEvent for the breakpoint would have consumed this event
            // as a result, it's safe to assume that there aren't any breakpoints on this line
            debugClient.toggleBreakpoint(editorFile, event.line)
            language.toggleBreakpoint(event.line)
            postInvalidate()
          }
        }
      }

      subscribeEvent(LanguageUpdateEvent::class.java) { _, _ ->
        this.file?.also { file ->
          resetBreakpointsInFile(file)
        }
      }

      subscribeEvent(FileUpdateEvent::class.java) { _, _ ->
        this.file?.also { file ->
          resetBreakpointsInFile(file)
        }
      }
    }

    _searchLayout = EditorSearchLayout(context, binding.editor)
    orientation = VERTICAL

    removeAllViews()
    addView(binding.root, LayoutParams(LayoutParams.MATCH_PARENT, 0, 1f))
    addView(searchLayout, LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT))

    readFileAndApplySelection(file, selection)
  }

  override fun onHighlightLine(file: String, line: Int) {
    if (file != this.file?.canonicalPath) {
      return
    }

    (editor?.editorLanguage as? IDELanguage?)?.apply {
      unhighlightLines()
      highlightLine(line)
    }
  }

  override fun onUnhighlight() {
    (editor?.editorLanguage as? IDELanguage?)?.apply {
      unhighlightLines()
    }
  }

  private fun resetBreakpointsInFile(file: File) {
    val handler = IDEDebugClientImpl.requireInstance().breakpoints
    val breakpoints = handler.breakpointsInFile(file.canonicalPath)
    val highlightedLine = handler.highlightedLocation?.takeIf { it.first == file.canonicalPath }?.second
    editor?.apply {
      (editorLanguage as? IDELanguage?)?.apply {
        removeAllBreakpoints()
        addBreakpoints(breakpoints.map { it.line })
        unhighlightLines()
        if (highlightedLine != null) {
          highlightLine(highlightedLine)
        }
      }
    }
  }

  /**
   * Get the file of this editor. Throws [IllegalStateException] if no file is available.
   */
  fun requireFile(): File {
    return checkNotNull(file)
  }

  /**
   * Update the file of this editor. This only updates the file reference of the editor and does
   * not resets the content.
   */
  fun updateFile(file: File) {
    val editor = _binding?.editor ?: return
    editor.file = file
    postRead(file)
  }

  /**
   * Called when the editor has been selected and is visible to the user.
   */
  fun onEditorSelected() {
    _binding?.editor?.onEditorSelected() ?: run {
      log.warn("onEditorSelected() called but no editor instance is available")
    }
  }

  /**
   * Begins search mode and shows the [search layout][EditorSearchLayout].
   */
  fun beginSearch() {
    if (_binding == null || _searchLayout == null) {
      log.warn(
        "Editor layout is null content=$binding, searchLayout=$searchLayout")
      return
    }

    searchLayout.beginSearchMode()
  }

  /**
   * Mark this files as saved. Even if it not saved.
   */
  fun markAsSaved() {
    editor?.markUnmodified()
  }

  /**
   * Saves the content of the editor to the editor's file.
   *
   * @return Whether the save operation was successfully completed or not. If this method returns `false`,
   * it means that there was an error saving the file or the content of the file was not modified and
   * hence the save operation was skipped.
   */
  suspend fun save(): Boolean {
    val file = this.file ?: return false

    if (!isModified && file.exists()) {
      log.info("File was not modified. Skipping save operation for file {}", file.name)
      return false
    }

    val text = _binding?.editor?.text ?: run {
      log.error("Failed to save file. Unable to retrieve the content of editor as it is null.")
      return false
    }

    withContext(Dispatchers.Main.immediate) {

      withEditingDisabled {
        withContext(readWriteContext) {
          // Do not call suspend functions in this scope
          // the writeTo function acquires lock to the Content object before writing and releases
          // the lock after writing
          // if there are any suspend function calls in between, the lock and unlock calls might not
          // be called on the same thread
          text.writeTo(file, this@CodeEditorView::updateReadWriteProgress)
        }
      }

      _binding?.rwProgress?.isVisible = false
    }

    markUnmodified()
    notifySaved()

    return true
  }

  private fun updateReadWriteProgress(progress: Int) {
    val binding = this.binding
    runOnUiThread {
      if (binding.rwProgress.isVisible && (progress < 0 || progress >= 100)) {
        binding.rwProgress.isVisible = false
        return@runOnUiThread
      }

      if (!binding.rwProgress.isVisible) {
        binding.rwProgress.isVisible = true
      }

      binding.rwProgress.progress = progress
    }
  }

  private inline fun <R : Any?> withEditingDisabled(action: () -> R): R {
    return try {
      _binding?.editor?.isEditable = false
      action()
    } finally {
      _binding?.editor?.isEditable = true
    }
  }

  private fun readFileAndApplySelection(file: File, selection: Range) {
    codeEditorScope.launch(Dispatchers.Main.immediate) {
      updateReadWriteProgress(0)

      withEditingDisabled {

        val content = withContext(readWriteContext) {
          selection.validate()
          file.readContent(this@CodeEditorView::updateReadWriteProgress)
        }

        initializeContent(content, file, selection)
        _binding?.rwProgress?.isVisible = false
      }
    }
  }

  private fun initializeContent(content: Content, file: File, selection: Range) {
    val ideEditor = binding.editor
    ideEditor.postInLifecycle {
      val args = Bundle().apply {
        putString(IEditor.KEY_FILE, file.absolutePath)
      }

      ideEditor.setText(content, args)

      // editor.setText(...) sets the modified flag to true
      // but in this case, file is read from disk and hence the contents are not modified at all
      // so the flag must be changed to unmodified
      // TODO: Find a better way to check content modification status
      markUnmodified()
      postRead(file)

      ideEditor.validateRange(selection)
      ideEditor.setSelection(selection)

      configureEditorIfNeeded()
    }
  }

  private fun postRead(file: File) {
    binding.editor.setupLanguage(file)
    binding.editor.setLanguageServer(createLanguageServer(file))

    if (IDELanguageClientImpl.isInitialized()) {
      binding.editor.setLanguageClient(IDELanguageClientImpl.getInstance())
    }

    // File must be set only after setting the language server
    // This will make sure that textDocument/didOpen is sent
    binding.editor.file = file

    // do not pass this editor instance
    // symbol input must be updated for the current editor
    (context as? BaseEditorActivity?)?.refreshSymbolInput()
    (context as? Activity?)?.invalidateOptionsMenu()
  }

  private fun createLanguageServer(file: File): ILanguageServer? {
    if (!file.isFile) {
      return null
    }

    val serverID: String = when (file.extension) {
      "java" -> JavaLanguageServer.SERVER_ID
      "xml" -> XMLLanguageServer.SERVER_ID
      else -> return null
    }

    return ILanguageServerRegistry.getDefault().getServer(serverID)
  }

  private fun configureEditorIfNeeded() {
    onCustomFontPrefChanged()
    onFontSizePrefChanged()
    onFontLigaturesPrefChanged()
    onPrintingFlagsPrefChanged()
    onInputTypePrefChanged()
    onWordwrapPrefChanged()
    onMagnifierPrefChanged()
    onUseIcuPrefChanged()
    onDeleteEmptyLinesPrefChanged()
    onDeleteTabsPrefChanged()
    onStickyScrollEnabeldPrefChanged()
    onPinLineNumbersPrefChanged()
  }

  private fun onMagnifierPrefChanged() {
    binding.editor.getComponent(Magnifier::class.java).isEnabled = EditorPreferences.useMagnifier
  }

  private fun onWordwrapPrefChanged() {
    val enabled = EditorPreferences.wordwrap
    binding.editor.isWordwrap = enabled
  }

  private fun onInputTypePrefChanged() {
    binding.editor.inputType = createInputTypeFlags()
  }

  private fun onPrintingFlagsPrefChanged() {
    var flags = 0
    if (EditorPreferences.drawLeadingWs) {
      flags = flags or CodeEditor.FLAG_DRAW_WHITESPACE_LEADING
    }
    if (EditorPreferences.drawTrailingWs) {
      flags = flags or CodeEditor.FLAG_DRAW_WHITESPACE_TRAILING
    }
    if (EditorPreferences.drawInnerWs) {
      flags = flags or CodeEditor.FLAG_DRAW_WHITESPACE_INNER
    }
    if (EditorPreferences.drawEmptyLineWs) {
      flags = flags or CodeEditor.FLAG_DRAW_WHITESPACE_FOR_EMPTY_LINE
    }
    if (EditorPreferences.drawLineBreak) {
      flags = flags or CodeEditor.FLAG_DRAW_LINE_SEPARATOR
    }
    binding.editor.nonPrintablePaintingFlags = flags
  }

  private fun onFontLigaturesPrefChanged() {
    val enabled = EditorPreferences.fontLigatures
    binding.editor.isLigatureEnabled = enabled
  }

  private fun onFontSizePrefChanged() {
    var textSize = EditorPreferences.fontSize
    if (textSize < 6 || textSize > 32) {
      textSize = 14f
    }
    binding.editor.setTextSize(textSize)
  }

  private fun onUseIcuPrefChanged() {
    binding.editor.props.useICULibToSelectWords = EditorPreferences.useIcu
  }

  private fun onCustomFontPrefChanged() {
    val state = EditorPreferences.useCustomFont
    binding.editor.typefaceText = customOrJBMono(state)
    binding.editor.typefaceLineNumber = customOrJBMono(state)
  }

  private fun onDeleteEmptyLinesPrefChanged() {
    binding.editor.props.deleteEmptyLineFast = EditorPreferences.deleteEmptyLines
  }

  private fun onDeleteTabsPrefChanged() {
    binding.editor.props.deleteMultiSpaces = if (EditorPreferences.deleteTabsOnBackspace) -1 else 1
  }

  private fun onStickyScrollEnabeldPrefChanged() {
    binding.editor.props.stickyScroll = EditorPreferences.stickyScrollEnabled
  }

  private fun onPinLineNumbersPrefChanged() {
    binding.editor.setPinLineNumber(EditorPreferences.pinLineNumbers)
  }

  /**
   * For internal use only!
   *
   *
   * Marks this editor as unmodified. Used only when the activity is being destroyed.
   */
  internal fun markUnmodified() {
    binding.editor.markUnmodified()
  }

  /**
   * For internal use only!
   *
   *
   * Marks this editor as modified.
   */
  internal fun markModified() {
    binding.editor.markModified()
  }

  @Subscribe(threadMode = ThreadMode.MAIN)
  @Suppress("unused")
  fun onPreferenceChanged(event: PreferenceChangeEvent) {
    if (_binding == null) {
      return
    }

    BaseApplication.getBaseInstance().prefManager
    when (event.key) {
      EditorPreferences.FONT_SIZE -> onFontSizePrefChanged()
      EditorPreferences.FONT_LIGATURES -> onFontLigaturesPrefChanged()

      EditorPreferences.FLAG_LINE_BREAK,
      EditorPreferences.FLAG_WS_INNER,
      EditorPreferences.FLAG_WS_EMPTY_LINE,
      EditorPreferences.FLAG_WS_LEADING,
      EditorPreferences.FLAG_WS_TRAILING -> onPrintingFlagsPrefChanged()

      EditorPreferences.FLAG_PASSWORD -> onInputTypePrefChanged()
      EditorPreferences.WORD_WRAP -> onWordwrapPrefChanged()
      EditorPreferences.USE_MAGNIFER -> onMagnifierPrefChanged()
      EditorPreferences.USE_ICU -> onUseIcuPrefChanged()
      EditorPreferences.USE_CUSTOM_FONT -> onCustomFontPrefChanged()
      EditorPreferences.DELETE_EMPTY_LINES -> onDeleteEmptyLinesPrefChanged()
      EditorPreferences.DELETE_TABS_ON_BACKSPACE -> onDeleteTabsPrefChanged()
      EditorPreferences.STICKY_SCROLL_ENABLED -> onStickyScrollEnabeldPrefChanged()
      EditorPreferences.PIN_LINE_NUMBERS -> onPinLineNumbersPrefChanged()
    }
  }

  /**
   * Notifies the editor that its content has been saved.
   */
  private fun notifySaved() {
    binding.editor.dispatchDocumentSaveEvent()
  }

  override fun onAttachedToWindow() {
    super.onAttachedToWindow()
    if (!EventBus.getDefault().isRegistered(this)) {
      EventBus.getDefault().register(this)
    }
  }

  override fun onDetachedFromWindow() {
    super.onDetachedFromWindow()
    EventBus.getDefault().unregister(this)
  }

  override fun close() {
    codeEditorScope.cancelIfActive("Cancellation was requested")
    IDEDebugClientImpl.getInstance()?.breakpoints?.removeListener(this)
    _binding?.editor?.apply {
      notifyClose()
      release()
    }

    readWriteContext.use { }
  }
}


================================================
File: java/com/itsaky/androidide/ui/ContributorsRecyclerView.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.ui

import android.content.Context
import android.util.AttributeSet
import androidx.recyclerview.widget.RecyclerView
import com.google.android.flexbox.FlexDirection
import com.google.android.flexbox.FlexboxLayoutManager
import com.google.android.flexbox.JustifyContent
import com.itsaky.androidide.adapters.ContributorsGridAdapter
import com.itsaky.androidide.utils.FlexboxUtils

class ContributorsRecyclerView @JvmOverloads constructor(
  context: Context,
  attrs: AttributeSet? = null,
  defStyleAttr: Int = 0
) : RecyclerView(context, attrs, defStyleAttr) {

  private var globalLayoutListener = FlexboxUtils.createGlobalLayoutListenerToDistributeFlexboxItemsEvenly(
    { adapter }, { layoutManager as FlexboxLayoutManager }) { adapter, extras ->
    (adapter as ContributorsGridAdapter).fillDiff(extras)
  }

  init {
    layoutManager = FlexboxLayoutManager(context, FlexDirection.ROW).apply {
      justifyContent = JustifyContent.SPACE_EVENLY
    }
    viewTreeObserver.addOnGlobalLayoutListener(globalLayoutListener)
  }
}


================================================
File: java/com/itsaky/androidide/ui/CustomDividerItemDecoration.kt
================================================
package com.itsaky.androidide.ui

import android.content.Context
import android.graphics.Canvas
import android.graphics.Rect
import android.graphics.drawable.Drawable
import android.view.View
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView

class CustomDividerItemDecoration(context: Context, private val drawableResId: Int) :
    RecyclerView.ItemDecoration() {
    private val divider: Drawable? = ContextCompat.getDrawable(context, drawableResId)

    override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
        divider ?: return

        val left = parent.paddingLeft
        val right = parent.width - parent.paddingRight

        // Loop until the second to last child
        val childCount = parent.childCount
        for (i in 0 until childCount - 1) {
            val child = parent.getChildAt(i)
            val params = child.layoutParams as RecyclerView.LayoutParams
            val top = child.bottom + params.bottomMargin
            val bottom = top + divider.intrinsicHeight
            divider.setBounds(left, top, right, bottom)
            divider.draw(c)
        }
    }

    override fun getItemOffsets(
        outRect: Rect, view: View,
        parent: RecyclerView, state: RecyclerView.State
    ) {
        val position = parent.getChildAdapterPosition(view)
        // Only add bottom offset if this is not the last item
        if (position < state.itemCount - 1) {
            outRect.bottom = divider?.intrinsicHeight ?: 0
        } else {
            outRect.bottom = 0
        }
    }
}



================================================
File: java/com/itsaky/androidide/ui/CustomSnackbar.kt
================================================
package com.itsaky.androidide.ui

import android.annotation.SuppressLint
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.widget.Button
import android.widget.TextView
import com.google.android.material.snackbar.Snackbar
import com.itsaky.androidide.R

class CustomSnackbar(private val context: Context, private val rootView: View) {

    private var snackbar: Snackbar? = null

    @SuppressLint("RestrictedApi")
    fun show(
        message: String,
        textFirstAction: String?,
        textSecondaryAction: String?,
        actionFirst: (() -> Unit)? = null,
        actionSecondary: (() -> Unit)? = null
    ) {
        snackbar = Snackbar.make(rootView, "", Snackbar.LENGTH_INDEFINITE)

        val snackbarView = snackbar?.view
        val inflater = LayoutInflater.from(context)

        val customView = inflater.inflate(R.layout.snackbar_custom, null)

        val textView = customView.findViewById<TextView>(R.id.snackbar_message)
        textView.text = message

        val btnFirstAction = customView.findViewById<Button>(R.id.snackbar_action_yes)
        val btnSecondAction = customView.findViewById<Button>(R.id.snackbar_action_no)

        textFirstAction?.let {
            btnFirstAction.text = it
        }
        textSecondaryAction?.let {
            btnSecondAction.text = it
        }

        btnFirstAction.setOnClickListener {
            actionFirst?.invoke()
            snackbar?.dismiss()
        }

        btnSecondAction.setOnClickListener {
            actionSecondary?.invoke()
            snackbar?.dismiss()
        }

        snackbarView?.setPadding(0, 0, 0, 0)
        (snackbarView as? Snackbar.SnackbarLayout)?.apply {
            removeAllViews()
            addView(customView)
        }

        snackbarView?.let { view ->
            view.viewTreeObserver.addOnGlobalLayoutListener {
                val offsetY = context.resources.getDimensionPixelSize(R.dimen.snackbar_offset_bottom)

                view.translationY = -offsetY.toFloat()
            }
        }



        snackbar?.show()
    }

    fun dismiss() {
        snackbar?.dismiss()
    }
}


================================================
File: java/com/itsaky/androidide/ui/EditorBottomSheet.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.ui

import android.app.Activity
import android.content.Context
import android.text.TextUtils
import android.util.AttributeSet
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver
import android.widget.RelativeLayout
import androidx.annotation.GravityInt
import androidx.appcompat.widget.TooltipCompat
import androidx.core.graphics.Insets
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePadding
import androidx.core.view.updatePaddingRelative
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.transition.TransitionManager
import com.blankj.utilcode.util.KeyboardUtils
import com.blankj.utilcode.util.SizeUtils
import com.blankj.utilcode.util.ThreadUtils.runOnUiThread
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.tabs.TabLayout.OnTabSelectedListener
import com.google.android.material.tabs.TabLayout.Tab
import com.google.android.material.tabs.TabLayoutMediator
import com.google.android.material.transition.MaterialSharedAxis
import com.itsaky.androidide.R
import com.itsaky.androidide.adapters.DiagnosticsAdapter
import com.itsaky.androidide.adapters.EditorBottomSheetTabAdapter
import com.itsaky.androidide.adapters.SearchListAdapter
import com.itsaky.androidide.databinding.LayoutEditorBottomSheetBinding
import com.itsaky.androidide.fragments.output.ShareableOutputFragment
import com.itsaky.androidide.idetooltips.IDETooltipItem
import com.itsaky.androidide.models.LogLine
import com.itsaky.androidide.resources.R.string
import com.itsaky.androidide.tasks.TaskExecutor.CallbackWithError
import com.itsaky.androidide.tasks.TaskExecutor.executeAsync
import com.itsaky.androidide.tasks.TaskExecutor.executeAsyncProvideError
import com.itsaky.androidide.utils.IntentUtils.shareFile
import com.itsaky.androidide.utils.Symbols.forFile
import com.itsaky.androidide.utils.TooltipUtils
import com.itsaky.androidide.utils.flashError
import org.slf4j.LoggerFactory
import java.io.File
import java.io.IOException
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardOpenOption.CREATE_NEW
import java.nio.file.StandardOpenOption.WRITE
import java.util.concurrent.Callable
import kotlin.math.roundToInt

/**
 * Bottom sheet shown in editor activity.
 * @author Akash Yadav
 */
class EditorBottomSheet
@JvmOverloads
constructor(
  context: Context,
  attrs: AttributeSet? = null,
  defStyleAttr: Int = 0,
  defStyleRes: Int = 0,
) : RelativeLayout(context, attrs, defStyleAttr, defStyleRes) {

  private val collapsedHeight: Float by lazy {
    val localContext = getContext() ?: return@lazy 0f
    localContext.resources.getDimension(R.dimen.editor_sheet_collapsed_height)
  }
  private val behavior: BottomSheetBehavior<EditorBottomSheet> by lazy {
    BottomSheetBehavior.from(this).apply {
      isFitToContents = false
      skipCollapsed = true
    }
  }

  @JvmField
  var binding: LayoutEditorBottomSheetBinding
  val pagerAdapter: EditorBottomSheetTabAdapter

  private var anchorOffset = 0
  private var isImeVisible = false
  private var windowInsets: Insets? = null

  private val insetBottom: Int
    get() = if (isImeVisible) 0 else windowInsets?.bottom ?: 0

  companion object {

    private val log = LoggerFactory.getLogger(EditorBottomSheet::class.java)
    private const val COLLAPSE_HEADER_AT_OFFSET = 0.5f

    const val CHILD_HEADER = 0
    const val CHILD_SYMBOL_INPUT = 1
    const val CHILD_ACTION = 2
  }

  private fun initialize(context: FragmentActivity) {

    val mediator =
      TabLayoutMediator(binding.tabs, binding.pager, true, true) { tab, position ->
        tab.text = pagerAdapter.getTitle(position)
      }

    mediator.attach()
    binding.pager.isUserInputEnabled = false
    binding.pager.offscreenPageLimit = pagerAdapter.itemCount - 1 // Do not remove any views

    for (i in 0 until binding.tabs.tabCount) {
      val tab = binding.tabs.getTabAt(i) ?: continue
      val tabView = tab.view

      tabView.setOnLongClickListener {
        val title = pagerAdapter.getTitle(i)
        val tooltipMessage = when (title) {
          context.getString(R.string.app_logs) -> context.getString(R.string.app_logs)
          context.getString(R.string.ide_logs) -> context.getString(R.string.ide_logs)
          else -> context.getString(R.string.default_tooltip)
        }
        TooltipUtils.showIDETooltip(
          context,
          tabView,
          0,
          IDETooltipItem(
            tooltipCategory = "ide",
            tooltipTag = tooltipMessage,
            detail = tooltipMessage,
            summary = context.getString(R.string.more_information_about, title),
            buttons = arrayListOf(Pair(context.getString(R.string.learn_more), "~/help_top.html")),
          ),
        )

        true
      }
    }

    binding.tabs.addOnTabSelectedListener(
      object : OnTabSelectedListener {
        override fun onTabSelected(tab: Tab) {
          val fragment: Fragment = pagerAdapter.getFragmentAtIndex(tab.position)
          if (fragment is ShareableOutputFragment) {
            binding.clearFab.show()
            binding.shareOutputFab.show()
          } else {
            binding.clearFab.hide()
            binding.shareOutputFab.hide()
          }
        }

        override fun onTabUnselected(tab: Tab) {}
        override fun onTabReselected(tab: Tab) {}
      }
    )

    binding.shareOutputFab.setOnClickListener {
      val fragment = pagerAdapter.getFragmentAtIndex(binding.tabs.selectedTabPosition)

      if (fragment !is ShareableOutputFragment) {
        log.error("Unknown fragment: {}", fragment)
        return@setOnClickListener
      }

      val filename = fragment.getFilename()

      @Suppress("DEPRECATION")
      val progress = android.app.ProgressDialog.show(context, null,
        context.getString(string.please_wait))
      executeAsync(fragment::getContent) {
        progress.dismiss()
        shareText(it, filename)
      }
    }

    TooltipCompat.setTooltipText(binding.clearFab, context.getString(string.title_clear_output))
    binding.clearFab.setOnClickListener {
      val fragment: Fragment = pagerAdapter.getFragmentAtIndex(binding.tabs.selectedTabPosition)
      if (fragment !is ShareableOutputFragment) {
        log.error("Unknown fragment: {}", fragment)
        return@setOnClickListener
      }
      (fragment as ShareableOutputFragment).clearOutput()
    }

    binding.headerContainer.setOnClickListener {
      if (behavior.state != BottomSheetBehavior.STATE_EXPANDED) {
        behavior.state = BottomSheetBehavior.STATE_EXPANDED
      }
    }

    ViewCompat.setOnApplyWindowInsetsListener(this) { _, insets ->
      this.windowInsets = insets.getInsets(WindowInsetsCompat.Type.mandatorySystemGestures())
      insets
    }
  }

  init {
    if (context !is FragmentActivity) {
      throw IllegalArgumentException("EditorBottomSheet must be set up with a FragmentActivity")
    }

    val inflater = LayoutInflater.from(context)
    binding = LayoutEditorBottomSheetBinding.inflate(inflater)
    pagerAdapter = EditorBottomSheetTabAdapter(context)
    binding.pager.adapter = pagerAdapter

    removeAllViews()
    addView(binding.root)

    initialize(context)
  }

  /**
   * Set whether the input method is visible.
   */
  fun setImeVisible(isVisible: Boolean) {
    isImeVisible = isVisible
    behavior.isGestureInsetBottomIgnored = isVisible
  }

  fun setOffsetAnchor(view: View) {
    val listener =
      object : ViewTreeObserver.OnGlobalLayoutListener {
        override fun onGlobalLayout() {
          view.viewTreeObserver.removeOnGlobalLayoutListener(this)
          anchorOffset = view.height + SizeUtils.dp2px(1f)

          behavior.peekHeight = collapsedHeight.roundToInt()
          behavior.expandedOffset = anchorOffset
          behavior.isGestureInsetBottomIgnored = isImeVisible

          binding.root.updatePadding(bottom = anchorOffset + insetBottom)
          binding.headerContainer.apply {
            updatePaddingRelative(bottom = paddingBottom + insetBottom)
            updateLayoutParams<ViewGroup.LayoutParams> {
              height = (collapsedHeight + insetBottom).roundToInt()
            }
          }
        }
      }

    view.viewTreeObserver.addOnGlobalLayoutListener(listener)
  }

  fun onSlide(sheetOffset: Float) {
    val heightScale = if (sheetOffset >= COLLAPSE_HEADER_AT_OFFSET) {
      ((COLLAPSE_HEADER_AT_OFFSET - sheetOffset) + COLLAPSE_HEADER_AT_OFFSET) * 2f
    } else {
      1f
    }

    val paddingScale = if (!isImeVisible && sheetOffset <= COLLAPSE_HEADER_AT_OFFSET) {
      ((1f - sheetOffset) * 2f) - 1f
    } else {
      0f
    }

    val padding = insetBottom * paddingScale
    binding.headerContainer.apply {
      updateLayoutParams<ViewGroup.LayoutParams> {
        height = ((collapsedHeight + padding) * heightScale).roundToInt()
      }
      updatePaddingRelative(
        bottom = padding.roundToInt()
      )
    }
  }

  fun showChild(index: Int) {
    binding.headerContainer.displayedChild = index
  }

  fun setActionText(text: CharSequence) {
    binding.bottomAction.actionText.text = text
  }

  fun setActionProgress(progress: Int) {
    binding.bottomAction.progress.setProgressCompat(progress, true)
  }

  fun appendApkLog(line: LogLine) {
    pagerAdapter.logFragment?.appendLog(line)
  }

  fun appendBuildOut(str: String?) {
    if (str != null && shouldFilter(str)) return
    pagerAdapter.buildOutputFragment?.appendOutput(str)
  }

  private val suppressedGradleWarnings = listOf(
    "The option setting 'android.aapt2FromMavenOverride=/data/data/com.itsaky.androidide/files/home/.androidide/aapt2' is experimental",
    "The org.gradle.api.plugins.BasePluginConvention type has been deprecated.",
    "The org.gradle.api.plugins.Convention type has been deprecated.",
    "The BasePluginExtension.archivesBaseName property has been deprecated.",
    "The Provider.forUseAtConfigurationTime method has been deprecated.",
    "The BuildIdentifier.getName() method has been deprecated.",
    "Deprecated Gradle features were used in this build"
  )

  private fun shouldFilter(msg: String): Boolean {
    return suppressedGradleWarnings.any { msg.contains(it) }
  }

  fun clearBuildOutput() {
    pagerAdapter.buildOutputFragment?.clearOutput()
  }

  fun handleDiagnosticsResultVisibility(errorVisible: Boolean) {
    runOnUiThread { pagerAdapter.diagnosticsFragment?.isEmpty = errorVisible }
  }

  fun handleSearchResultVisibility(errorVisible: Boolean) {
    runOnUiThread { pagerAdapter.searchResultFragment?.isEmpty = errorVisible }
  }

  fun setDiagnosticsAdapter(adapter: DiagnosticsAdapter) {
    runOnUiThread { pagerAdapter.diagnosticsFragment?.setAdapter(adapter) }
  }

  fun setSearchResultAdapter(adapter: SearchListAdapter) {
    runOnUiThread { pagerAdapter.searchResultFragment?.setAdapter(adapter) }
  }

  fun refreshSymbolInput(editor: CodeEditorView) {
    binding.symbolInput.refresh(editor.editor, forFile(editor.file))
  }

  fun onSoftInputChanged() {
    if (context !is Activity) {
      log.error("Bottom sheet is not attached to an activity!")
      return
    }

    binding.symbolInput.itemAnimator?.endAnimations()

    TransitionManager.beginDelayedTransition(
      binding.root,
      MaterialSharedAxis(MaterialSharedAxis.Y, false)
    )

    val activity = context as Activity
    if (KeyboardUtils.isSoftInputVisible(activity)) {
      binding.headerContainer.displayedChild = CHILD_SYMBOL_INPUT
    } else {
      binding.headerContainer.displayedChild = CHILD_HEADER
    }
  }

  fun setStatus(text: CharSequence, @GravityInt gravity: Int) {
    runOnUiThread {
      binding.buildStatus.let {
        it.statusText.gravity = gravity
        it.statusText.text = text
      }
    }
  }

  private fun shareFile(file: File) {
    shareFile(context, file, "text/plain")
  }

  @Suppress("DEPRECATION")
  private fun shareText(text: String?, type: String) {
    if (text == null || TextUtils.isEmpty(text)) {
      flashError(context.getString(string.msg_output_text_extraction_failed))
      return
    }
    val pd = android.app.ProgressDialog.show(context, null, context.getString(string.please_wait),
      true, false)
    executeAsyncProvideError(
      Callable { writeTempFile(text, type) },
      CallbackWithError<File> { result: File?, error: Throwable? ->
        pd.dismiss()
        if (result == null || error != null) {
          log.warn("Unable to share output", error)
          return@CallbackWithError
        }
        shareFile(result)
      }
    )
  }

  private fun writeTempFile(text: String, type: String): File {
    // use a common name to avoid multiple files
    val file: Path = context.filesDir.toPath().resolve("$type.txt")
    try {
      if (Files.exists(file)) {
        Files.delete(file)
      }
      Files.write(file, text.toByteArray(StandardCharsets.UTF_8), CREATE_NEW, WRITE)
    } catch (e: IOException) {
      log.error("Unable to write output to file", e)
    }
    return file.toFile()
  }
}



================================================
File: java/com/itsaky/androidide/ui/EmptyView.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/

package com.itsaky.androidide.ui;

import android.content.Context;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.widget.RelativeLayout;
import android.widget.TextView;
import androidx.annotation.NonNull;
import com.itsaky.androidide.R;
import com.itsaky.androidide.utils.ContextUtilsKt;

public class EmptyView extends RelativeLayout {

  private static final int MESSAGE_TEXTVIEW = View.generateViewId();

  private CharSequence message = null;

  public EmptyView(Context context) {
    this(context, null);
  }

  public EmptyView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
  }

  public EmptyView(Context context, AttributeSet attrs, int defStyleAttr) {
    this(context, attrs, defStyleAttr, 0);
  }

  public EmptyView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
    super(context, attrs, defStyleAttr, defStyleRes);

    init();
  }

  private void init() {

    removeAllViews();

    TextView text = new TextView(getContext());
    text.setId(MESSAGE_TEXTVIEW);
    text.setText(getMessage());
    text.setTextColor(ContextUtilsKt.resolveAttr(getContext(), R.attr.colorSecondaryVariant));
    text.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14);
    text.setGravity(Gravity.CENTER);

    LayoutParams params = new LayoutParams(-2, -2);
    params.addRule(CENTER_HORIZONTAL);
    params.addRule(ALIGN_PARENT_TOP);

    addView(text, params);
  }

  public void setMessage(CharSequence message) {
    this.message = message;

    final TextView text = findViewById(MESSAGE_TEXTVIEW);
    if (text != null) {
      text.setText(getMessage());
    }
  }

  @NonNull
  public CharSequence getMessage() {
    return TextUtils.isEmpty(message) ? getContext().getString(R.string.msg_empty_view) : message;
  }
}



================================================
File: java/com/itsaky/androidide/ui/ScalableTabLayout.kt
================================================
package com.itsaky.androidide.ui

import android.content.Context
import android.util.AttributeSet
import android.view.ViewGroup
import com.google.android.material.tabs.TabLayout

// https://stackoverflow.com/a/65605542
class ScalableTabLayout : TabLayout {
  constructor(context: Context) : super(context)
  constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)
  constructor(
    context: Context,
    attrs: AttributeSet?,
    defStyleAttr: Int
  ) : super(context, attrs, defStyleAttr)

  override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    val tabLayout = getChildAt(0) as ViewGroup
    val childCount = tabLayout.childCount
    if (childCount > 0) {
      val widthPixels = MeasureSpec.getSize(widthMeasureSpec)
      val tabMinWidth = widthPixels / childCount
      var remainderPixels = widthPixels % childCount
      for (i in 0 until childCount) {
        val it = tabLayout.getChildAt(i)
        if (remainderPixels > 0) {
          it.minimumWidth = tabMinWidth + 1
          remainderPixels--
        } else {
          it.minimumWidth = tabMinWidth
        }
      }
    }
    super.onMeasure(widthMeasureSpec, heightMeasureSpec)
  }
}



================================================
File: java/com/itsaky/androidide/ui/SwipeRevealLayout.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.ui

import android.annotation.SuppressLint
import android.content.Context
import android.util.AttributeSet
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import androidx.annotation.CallSuper
import androidx.annotation.FloatRange
import androidx.annotation.IdRes
import androidx.customview.widget.ViewDragHelper
import com.google.android.material.shape.MaterialShapeDrawable
import com.itsaky.androidide.R
import kotlin.math.max
import kotlin.math.min

/**
 * A layout which can be dragged vertically to reveal a hidden content.
 *
 * @author Akash Yadav
 */
open class SwipeRevealLayout @JvmOverloads constructor(
  context: Context,
  attrs: AttributeSet? = null,
  defStyleAttr: Int = 0,
  defStyleRes: Int = 0,
) : ViewGroup(context, attrs, defStyleAttr, defStyleRes) {

  /**
   * Interface for listening to drag events.
   */
  interface OnDragListener {

    /**
     * Called when the drag state changes.
     */
    fun onDragStateChanged(swipeRevealLayout: SwipeRevealLayout, state: Int)

    /**
     * Called when the drag progress changes.
     */
    fun onDragProgress(swipeRevealLayout: SwipeRevealLayout, progress: Float)
  }

  private val dragHelperCallback = object : ViewDragHelper.Callback() {
    override fun tryCaptureView(child: View, pointerId: Int): Boolean {
      return child === overlappingContent
    }

    override fun onViewPositionChanged(changedView: View, left: Int, top: Int, dx: Int, dy: Int) {
      draggingViewTop = top
      onDragProgress(min(1f, top.toFloat() / dragHeightMax.toFloat()))
    }

    override fun getViewVerticalDragRange(child: View): Int {
      return dragHeightMax
    }

    override fun getOrderedChildIndex(index: Int): Int {
      return OVERLAPPING_CONTENT_INDEX
    }

    override fun clampViewPositionVertical(child: View, top: Int, dy: Int): Int {
      return min(max(top, paddingTop), dragHeightMax)
    }

    override fun onViewDragStateChanged(state: Int) {
      if (state == draggingState) {
        return
      }

      if (isDragging && state == ViewDragHelper.STATE_IDLE) {
        isOpen = draggingViewTop >= dragHeightMax
      }

      onDragStateChanged(state)
    }

    override fun onViewReleased(releasedChild: View, xvel: Float, yvel: Float) {
      if (draggingViewTop == 0) {
        isOpen = false
        return
      }

      if (draggingViewTop >= dragHeightMax) {
        isOpen = true
        return
      }

      // whether the view should settle to open or close
      val settleDestY = if (yvel > AUTO_OPEN_VELOCITY_LIM || draggingViewTop > dragHeightMax / 2) {
        dragHeightMax
      } else {
        paddingTop
      }

      if (dragHelper.settleCapturedViewAt(0, settleDestY)) {
        this@SwipeRevealLayout.postInvalidateOnAnimation()
      }
    }
  }

  private var dragHandleView: View? = null
    get() {
      if (field == null) {
        field = findViewById(dragHandleViewId)
      }
      return field
    }

  private val hiddenContent: View
    get() = getChildAt(HIDDEN_CONTENT_INDEX)!!

  private val overlappingContent: View
    get() = getChildAt(OVERLAPPING_CONTENT_INDEX)!!

  private var initialDragX = 0f
  private var initialDragY = 0f
  private var draggingState = -1
  private var draggingViewTop = 0
  private val dragHeightMax
    get() = hiddenContent.height

  private lateinit var dragHelper: ViewDragHelper
  private var hasReceivedDownEvent = false

  /**
   * Whether the view is currently in 'dragging' state.
   */
  val isDragging: Boolean
    get() = draggingState == ViewDragHelper.STATE_DRAGGING ||
            draggingState == ViewDragHelper.STATE_SETTLING

  /**
   * The ID of the view which will be dragged to reveal the content.
   */
  @IdRes
  var dragHandleViewId = 0

  /**
   * The current drag progress.
   */
  @FloatRange(from = 0.0, to = 1.0)
  var dragProgress = 0.0f
    private set

  /**
   * Listener for drag events.
   */
  var dragListener: OnDragListener? = null

  /**
   * Whether the view is open.
   */
  var isOpen = false
    protected set

  companion object {

    private const val HIDDEN_CONTENT_INDEX = 0
    private const val OVERLAPPING_CONTENT_INDEX = 1

    @Suppress("UNUSED")
    const val STATE_IDLE = ViewDragHelper.STATE_IDLE

    @Suppress("UNUSED")
    const val STATE_DRAGGING = ViewDragHelper.STATE_DRAGGING

    @Suppress("UNUSED")
    const val STATE_SETTLING = ViewDragHelper.STATE_SETTLING

    const val AUTO_OPEN_VELOCITY_LIM = 800.0
  }

  init {
    if (attrs != null) {
      val typedArray = context.obtainStyledAttributes(attrs, R.styleable.SwipeRevealLayout,
        defStyleAttr, defStyleRes)
      dragHandleViewId = typedArray.getResourceId(R.styleable.SwipeRevealLayout_dragHandle,
        dragHandleViewId)
      typedArray.recycle()
    }
  }

  override fun onFinishInflate() {
    super.onFinishInflate()
    this.dragHelper = ViewDragHelper.create(this, dragHelperCallback)
    this.isOpen = false

    check(childCount == 2) {
      "SwipeRevealLayout must have exactly two children; the hidden content and the overlapping content"
    }
  }

  override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    measureChildren(widthMeasureSpec, heightMeasureSpec)

    val maxWidth = MeasureSpec.getSize(widthMeasureSpec)
    val maxHeight = MeasureSpec.getSize(heightMeasureSpec)

    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, 0),
      resolveSizeAndState(maxHeight, heightMeasureSpec, 0))
  }

  override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
    hiddenContent.layout(0, paddingTop, r, paddingTop + hiddenContent.measuredHeight)

    val olapTop = paddingTop + (hiddenContent.height * dragProgress).toInt()
    overlappingContent.layout(0, olapTop, r, b)
  }

  override fun onInterceptTouchEvent(ev: MotionEvent): Boolean {
    when (ev.actionMasked) {
      MotionEvent.ACTION_DOWN -> {
        val isInDragHandle = isViewHit(dragHandleView!!, ev.x.toInt(), ev.y.toInt())
        hasReceivedDownEvent = isInDragHandle
        return isInDragHandle && dragHelper.shouldInterceptTouchEvent(ev)
      }

      MotionEvent.ACTION_MOVE,
      MotionEvent.ACTION_UP,
      MotionEvent.ACTION_CANCEL -> {
        if (!hasReceivedDownEvent) {
          return false
        }

        val shouldIntercept = dragHelper.shouldInterceptTouchEvent(ev)
        if (ev.actionMasked == MotionEvent.ACTION_UP ||
          ev.actionMasked == MotionEvent.ACTION_CANCEL) {
          hasReceivedDownEvent = false
        }
        return shouldIntercept && isViewHit(dragHandleView!!, ev.x.toInt(), ev.y.toInt())
      }
      else -> return false
    }
  }

  @SuppressLint("ClickableViewAccessibility")
  override fun onTouchEvent(event: MotionEvent): Boolean {
    val x = event.x
    val xInt = x.toInt()
    val y = event.y
    val yInt = y.toInt()

    dragHelper.processTouchEvent(event)
    val isInHandle = dragHelper.isViewUnder(dragHandleView, xInt, yInt)

    when (event.actionMasked) {
      MotionEvent.ACTION_DOWN -> {
        initialDragX = x
        initialDragY = y
      }

      MotionEvent.ACTION_UP -> {
        val dx = x - initialDragX
        val dy = y - initialDragY
        val slop = dragHelper.touchSlop
        if (dx * dx + dy * dy < slop * slop && isInHandle) {
          smoothSlideTo(if (dragProgress == 0f) 1f else 0f)
        }
      }
    }

    return isInHandle && isViewHit(hiddenContent, xInt, yInt) || isViewHit(overlappingContent, xInt, yInt)
  }

  override fun computeScroll() {
    if (dragHelper.continueSettling(true)) {
      postInvalidateOnAnimation()
    }
  }

  /**
   * Internal callback. Invoked when the drag state changes.
   */
  @CallSuper
  protected open fun onDragStateChanged(state: Int) {
    draggingState = state
    dragListener?.onDragStateChanged(this, state)
  }

  /**
   * Internal callback. Invoked when the drag progress changes.
   */
  @CallSuper
  protected open fun onDragProgress(progress: Float) {
    if (dragProgress == progress) {
      return
    }

    dragProgress = progress
    applyDragProgress(progress)
    dragListener?.onDragProgress(this, progress)
  }

  /**
   * Applies the drag progress to the content.
   */
  protected open fun applyDragProgress(progress: Float) {
    val min = 0.97f
    val max = 1f
    val scale = min + (max - min) * (1 - progress)
    overlappingContent.scaleX = scale
    overlappingContent.scaleY = scale
    (overlappingContent.background as? MaterialShapeDrawable?)?.interpolation = progress
  }

  /**
   * Toggles the state of the view.
   */
  fun toggleState(isOpen: Boolean) {
    if (isOpen) {
      open()
    } else {
      close()
    }
  }

  /**
   * Opens the view.
   */
  fun open() {
    if (isOpen) {
      return
    }
    smoothSlideTo(1f)
  }

  /**
   * Closes the view.
   */
  fun close() {
    if (!isOpen) {
      return
    }

    smoothSlideTo(0f)
  }

  private fun smoothSlideTo(offset: Float) {
    val y = paddingTop + offset * dragHeightMax
    if (dragHelper.smoothSlideViewTo(overlappingContent, overlappingContent.left, y.toInt())) {
      postInvalidateOnAnimation()
    }
  }

  /**
   * Whether the given motion event lies within the target view.
   */
  private fun isViewHit(view: View, x: Int, y: Int): Boolean {
    val viewLoc = IntArray(2)
    view.getLocationOnScreen(viewLoc)
    val parentLoc = IntArray(2)
    getLocationOnScreen(parentLoc)

    val scrX = parentLoc[0] + x
    val scrY = parentLoc[1] + y
    return scrX >= viewLoc[0] && scrX < viewLoc[0] + view.width && scrY >= viewLoc[1] && scrY < viewLoc[1] + view.height
  }
}


================================================
File: java/com/itsaky/androidide/ui/SymbolInputView.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.ui;

import android.content.Context;
import android.util.AttributeSet;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.itsaky.androidide.adapters.SymbolInputAdapter;
import com.itsaky.androidide.editor.ui.IDEEditor;
import com.itsaky.androidide.models.Symbol;
import com.itsaky.androidide.utils.Symbols;
import java.util.List;

public class SymbolInputView extends RecyclerView {

  public SymbolInputView(Context context) {
    this(context, null);
  }

  public SymbolInputView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
  }

  public SymbolInputView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    setLayoutManager(new LinearLayoutManager(getContext(), LinearLayoutManager.HORIZONTAL, false));
  }

  public void refresh(IDEEditor editor, List<Symbol> symbols) {
    if (symbols == null || symbols.isEmpty()) {
      symbols = Symbols.INSTANCE.getPlainTextSymbols();
    }

    final var adapter = getAdapter();
    if (adapter instanceof SymbolInputAdapter) {
      ((SymbolInputAdapter) adapter).refresh(editor, symbols);
    } else {
      setAdapter(new SymbolInputAdapter(editor));
    }
  }
}



================================================
File: java/com/itsaky/androidide/ui/themes/ThemeManager.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.ui.themes

import android.app.Activity
import com.google.auto.service.AutoService
import com.itsaky.androidide.preferences.internal.GeneralPreferences
import com.itsaky.androidide.utils.isSystemInDarkMode

/**
 * Theme manager for AndroidIDE.
 *
 * @author Akash Yadav
 */
@Suppress("unused")
@AutoService(IThemeManager::class)
class ThemeManager : IThemeManager {

  /**
   * Apply the current theme to the given activity. Does nothing if theme is set to [Material You][IDETheme.MATERIAL_YOU].
   */
  override fun applyTheme(activity: Activity) {

    val theme = getCurrentTheme()
    if (theme == IDETheme.MATERIAL_YOU) {
      // No need to apply Material You theme
      return
    }

    val style = if (activity.isSystemInDarkMode()) {
      theme.styleDark
    } else {
      theme.styleLight
    }

    activity.setTheme(style)
  }

  /**
   * Get the currently selected theme.
   */
  override fun getCurrentTheme(): IDETheme {
    return GeneralPreferences.selectedTheme?.let { IDETheme.valueOf(it) } ?: IDETheme.DEFAULT
  }
}


================================================
File: java/com/itsaky/androidide/ui/transition/ArcMotionPlus.java
================================================
/*
 * Copyright (C) 2016 Neil Davies
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.itsaky.androidide.ui.transition;

/**
 * A PathMotion that generates a curved path along an arc on an imaginary circle containing the two
 * points. The two points reside on the circle and a line between them describes a chord for the
 * circle that is symmetrical. i.e the angle between the chord and the tangent to each point will be
 * the same.
 *
 * <p>A perpendicular line from the midpoint of the line between the two points will intersect the
 * center of the circle. Everything about the line from the center of the circle to the midpoint of
 * the chord is symmetrical.
 *
 * <p>This may be used in XML as an element inside a transition.
 *
 * <pre>{@code
 * <changeBounds>
 *   <pathMotion class="com.oeri.arcmotionplus.ArcMotionPlus"
 *              app:arcAngle="90"
 *              app:reflect="true"
 *              />
 * </changeBounds>
 * }</pre>
 */

import android.content.Context;
import android.graphics.Path;
import android.util.AttributeSet;
import androidx.transition.PathMotion;

public class ArcMotionPlus extends PathMotion {

  private static final float DEFAULT_ARC_ANGLE = 90f;
  private static final boolean DEFAULT_REFLECT = false;

  private boolean isReflectedArc = DEFAULT_REFLECT;
  private float arcAngle = DEFAULT_ARC_ANGLE;

  public ArcMotionPlus() {}

  public ArcMotionPlus(Context context, AttributeSet attrs) {
    super(context, attrs);
  }

  /**
   * Returns if we are reflecting the arc
   *
   * <p>The default value is false.
   *
   * @return Is the arc reflected
   */
  public boolean isReflectedArc() {
    return isReflectedArc;
  }

  /**
   * Sets whether we should reflect the arc about the line drawn between the start and end points
   *
   * <p>The default value is false.
   *
   * @param isReflectedArc Is the arc reflected about the line between start and end points
   */
  public void setReflectedArc(boolean isReflectedArc) {
    this.isReflectedArc = isReflectedArc;
  }

  /**
   * Returns the arc angle that describes the curve. The larger the angle the more pronounce the
   * curve will be. Min value is 1, Max value si 179
   *
   * <p>The default value is 90.
   *
   * @return The angle of the arc on a circle describing the Path between two points.
   */
  public float getArcAngle() {
    return arcAngle;
  }

  /**
   * Sets the arc angle that describes the curve. The larger the angle the more pronounce the curve
   * will be. Min value is 1, Max value si 179
   *
   * <p>The default value is 90.
   *
   * @param angle The angle of the arc on a circle describing the Path between two points.
   */
  public ArcMotionPlus setArcAngle(float angle) {
    arcAngle = angle;
    return this;
  }

  @Override
  public Path getPath(float startX, float startY, float endX, float endY) {
    float controlP1X, controlP1Y, controlP2X, controlP2Y;

    Path path = new Path();
    path.moveTo(startX, startY);

    CubicBezierArc cubicBezierArc = new CubicBezierArc(arcAngle, startX, startY, endX, endY);

    if (isReflectedArc) {
      controlP1X = cubicBezierArc.getReflectedControlPoint1().x;
      controlP1Y = cubicBezierArc.getReflectedControlPoint1().y;
      controlP2X = cubicBezierArc.getReflectedControlPoint2().x;
      controlP2Y = cubicBezierArc.getReflectedControlPoint2().y;

    } else {
      controlP1X = cubicBezierArc.getControlPoint1().x;
      controlP1Y = cubicBezierArc.getControlPoint1().y;
      controlP2X = cubicBezierArc.getControlPoint2().x;
      controlP2Y = cubicBezierArc.getControlPoint2().y;
    }

    path.cubicTo(controlP1X, controlP1Y, controlP2X, controlP2Y, endX, endY);
    return path;
  }
}



================================================
File: java/com/itsaky/androidide/ui/transition/CubicBezierArc.java
================================================
/*
 * Copyright (C) 2016 Neil Davies
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.itsaky.androidide.ui.transition;

/**
 * A Class that takes an angle, start point and end point that it uses to calculate controls points
 * which can be used to describe a curve between the two points that approximates an arc on a
 * circle.
 */
public class CubicBezierArc {

  private Point startPoint;
  private Point endPoint;
  private Point controlPoint1;
  private Point controlPoint2;
  private Point reflectedControlPoint1;
  private Point reflectedControlPoint2;

  /**
   * Create a CubicBezierArc class with arc angle and start and end points
   *
   * @param angle The angle used to describe the arc, the greater the angle the more curved the arc
   *     will be (min = 1 , max = 179)
   * @param startX the x coord of the start point
   * @param startY the y coord of the start point
   * @param endX the x coord of the end point
   * @param endY the y coord of the end point
   */
  public CubicBezierArc(float angle, float startX, float startY, float endX, float endY) {

    Point start = new Point(startX, startY);
    Point end = new Point(endX, endY);

    if (start.x == end.x && start.y == end.y) {
      throw new IllegalArgumentException("Start and end points cannot be the same");
    }
    if (angle < 1 || angle > 179) {
      throw new IllegalArgumentException("Arc angle must be between 1 and 179 degrees");
    }
    startPoint = start;
    endPoint = end;
    calculateControlPoints(angle, start, end);
  }

  private void calculateControlPoints(float angle, Point start, Point end) {
    double angleRadians = Math.toRadians(angle);

    float deltaX = start.x - end.x;
    float deltaY = start.y - end.y;
    float halfChordLength = (float) Math.sqrt(deltaX * deltaX + deltaY * deltaY) / 2;
    float radius = halfChordLength / (float) Math.sin(angleRadians / 2.0f);
    // The length of the line from the start or end point to the control point
    float controlLength = (float) ((4f / 3f) * Math.tan(angleRadians / 4)) * radius;

    float angleToControl = (float) Math.toDegrees(Math.atan(controlLength / radius));

    // The mid point of the line from start to end
    Point midPointChord = new Point((start.x + end.x) / 2, (start.y + end.y) / 2);

    // Angle between line from circle centre to control point, and line between control points
    float chordRadiusAngle = 180 - 90 - (angle / 2);

    Point center = getTrianglePoint(chordRadiusAngle, midPointChord, end);
    controlPoint2 = getTrianglePoint(angleToControl, end, center);
    controlPoint1 = getReflectedPointAboutLine(center, midPointChord, controlPoint2);

    // Get reflected control points
    reflectedControlPoint1 = getReflectedPointAboutLine(start, end, controlPoint1);
    reflectedControlPoint2 = getReflectedPointAboutLine(start, end, controlPoint2);
  }

  private Point getTrianglePoint(float angle, Point a, Point b) {
    double angleRadians = Math.toRadians(angle);
    Point thirdPoint = new Point();
    thirdPoint.x = (float) Math.tan(angleRadians) * (b.y - a.y) * -1;
    thirdPoint.y = (float) Math.tan(angleRadians) * (b.x - a.x);
    thirdPoint.x = thirdPoint.x + a.x;
    thirdPoint.y = thirdPoint.y + a.y;
    return thirdPoint;
  }

  private Point getReflectedPointAboutLine(Point start, Point end, Point reflect) {
    Point reflectedPoint = new Point();
    if (start.x != end.x) {
      float m = (start.y - end.y) / (start.x - end.x);
      float c = end.y - (m * end.x);
      float d = (reflect.x + (reflect.y - c) * m) / (1 + (m * m));
      reflectedPoint.x = (2 * d) - reflect.x;
      reflectedPoint.y = (2 * d * m) - reflect.y + (2 * c);
    } else {
      reflectedPoint.y = reflect.y;
      reflectedPoint.x = start.x - (reflect.x - start.x);
    }
    return reflectedPoint;
  }

  /**
   * Returns the start point
   *
   * @return The start point
   */
  public Point getStartPoint() {
    return startPoint;
  }

  /**
   * Returns the end point
   *
   * @return The end point
   */
  public Point getEndPoint() {
    return endPoint;
  }

  /**
   * Returns the first control point
   *
   * @return The first control point
   */
  public Point getControlPoint1() {
    return controlPoint1;
  }

  /**
   * Returns the second control point
   *
   * @return The second control point
   */
  public Point getControlPoint2() {
    return controlPoint2;
  }

  /**
   * Returns the first control point when reflected about line between start and end points
   *
   * @return Reflected control point 1
   */
  public Point getReflectedControlPoint1() {
    return reflectedControlPoint1;
  }

  /**
   * Returns the second control point when reflected about line between start and end points
   *
   * @return Reflected control point 2
   */
  public Point getReflectedControlPoint2() {
    return reflectedControlPoint2;
  }

  public static class Point {
    public float x;
    public float y;

    public Point() {}

    public Point(float x, float y) {
      this.x = x;
      this.y = y;
    }
  }
}



================================================
File: java/com/itsaky/androidide/ui/transition/ProgressTransition.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/
package com.itsaky.androidide.ui.transition;

import android.animation.Animator;
import android.animation.ObjectAnimator;
import android.util.Property;
import android.view.ViewGroup;
import android.widget.ProgressBar;
import androidx.transition.Transition;
import androidx.transition.TransitionValues;
import com.itsaky.androidide.utils.IntProperty;

public class ProgressTransition extends Transition {

  private static final String PROPNAME_PROGRESS = "ProgressTransition:progress";
  private static final Property<ProgressBar, Integer> PROGRESS_PROPERTY =
      new IntProperty<ProgressBar>(PROPNAME_PROGRESS) {

        @Override
        public void setValue(ProgressBar progressBar, int value) {
          progressBar.setProgress(value);
        }

        @Override
        public Integer get(ProgressBar progressBar) {
          return progressBar.getProgress();
        }
      };

  @Override
  public Animator createAnimator(
      ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues) {
    if (startValues != null && endValues != null && endValues.view instanceof ProgressBar) {
      ProgressBar progressBar = (ProgressBar) endValues.view;
      int start = (Integer) startValues.values.get(PROPNAME_PROGRESS);
      int end = (Integer) endValues.values.get(PROPNAME_PROGRESS);
      if (start != end) {
        progressBar.setProgress(start);
        return ObjectAnimator.ofInt(progressBar, PROGRESS_PROPERTY, end);
      }
    }
    return null;
  }

  @Override
  public void captureStartValues(TransitionValues transitionValues) {
    captureValues(transitionValues);
  }

  @Override
  public void captureEndValues(TransitionValues transitionValues) {
    captureValues(transitionValues);
  }

  private void captureValues(TransitionValues transitionValues) {
    if (transitionValues.view instanceof ProgressBar) {
      ProgressBar progressBar = ((ProgressBar) transitionValues.view);
      transitionValues.values.put(PROPNAME_PROGRESS, progressBar.getProgress());
    }
  }
}



================================================
File: java/com/itsaky/androidide/utils/ActionMenuUtils.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.content.Context
import android.view.View
import android.widget.PopupMenu
import androidx.core.widget.PopupMenuCompat.getDragToOpenListener
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.actions.FillMenuParams

/**
 * Utility class to show a popup menu with [com.itsaky.androidide.actions.ActionsRegistry].
 *
 * @author Akash Yadav
 */
object ActionMenuUtils {

  @JvmStatic
  @JvmOverloads
  fun createMenu(
    context: Context,
    anchor: View,
    location: ActionItem.Location,
    dragToOpen: Boolean = false
  ): PopupMenu {
    return PopupMenu(context, anchor).apply {
      val data = ActionData.create(context)
      ActionsRegistry.getInstance().fillMenu(FillMenuParams(data, location, menu))

      if (dragToOpen) {
        anchor.setOnTouchListener(getDragToOpenListener(this))
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/utils/ApkInstallationSessionCallback.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import com.itsaky.androidide.R.string
import com.itsaky.androidide.activities.editor.BaseEditorActivity
import com.itsaky.androidide.ui.EditorBottomSheet
import org.slf4j.LoggerFactory

/** @author Akash Yadav */
class ApkInstallationSessionCallback(
  private var activity: BaseEditorActivity?,
) : SingleSessionCallback() {

  private var sessionId = -1

  companion object {
    private val log = LoggerFactory.getLogger(ApkInstallationSessionCallback::class.java)
    private const val LOG_ABANDON_FAILED = "Failed to abandon session {} : {}"
    private const val LOG_SESSION_NOT_EXISTS = "Session {} no longer exists or is already abandoned"
    private const val LOG_SESSION_ERROR = "Error while handling installation session {} : {}"
    private const val SESSION_ID_NONE = -1
  }

  override fun onCreated(sessionId: Int) {
    this.sessionId = sessionId
    log.debug("Created package installation session: {}", sessionId)
    activity?._binding?.content?.apply {
      bottomSheet.setActionText(activity!!.getString(string.msg_installing_apk))
      bottomSheet.setActionProgress(0)
      bottomSheet.showChild(EditorBottomSheet.CHILD_ACTION)
    }
  }

  override fun onProgressChanged(sessionId: Int, progress: Float) {
    activity?._binding?.content?.bottomSheet?.setActionProgress((progress * 100f).toInt())
  }

  override fun onFinished(sessionId: Int, success: Boolean) {
    activity?._binding?.content?.apply {
      bottomSheet.showChild(EditorBottomSheet.CHILD_HEADER)
      bottomSheet.setActionProgress(0)
      if (!success) {
        activity?.flashError(string.title_installation_failed)
      }

      activity?.let {
        it.installationCallback?.destroy()
        it.installationCallback = null
      }
    }
  }

  fun destroy() {
    val currentActivity = this.activity
    val isActivityValid = currentActivity != null && !currentActivity.isFinishing && !currentActivity.isDestroyed

    if (this.sessionId != SESSION_ID_NONE && isActivityValid) {
      try {
        currentActivity?.packageManager?.packageInstaller?.let { packageInstaller ->
          val sessionExists = packageInstaller.mySessions.any { it.sessionId == this.sessionId }
          if (sessionExists) {
            try {
              packageInstaller.abandonSession(this.sessionId)
            } catch (ex: Exception) {
              log.error(LOG_ABANDON_FAILED, this.sessionId, ex.cause?.message ?: ex.message)
            }
          } else {
            log.info(LOG_SESSION_NOT_EXISTS, this.sessionId)
          }
        }
      } catch (ex: Exception) {
        log.error(LOG_SESSION_ERROR, this.sessionId, ex.cause?.message ?: ex.message)
      }
    }

    this.activity = null
    this.sessionId = -1
  }
}


================================================
File: java/com/itsaky/androidide/utils/AssetsInstallationHelper.kt
================================================
package com.itsaky.androidide.utils

import android.content.Context
import androidx.annotation.WorkerThread
import com.aayushatharva.brotli4j.Brotli4jLoader
import com.itsaky.androidide.app.configuration.IDEBuildConfigProvider
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.joinAll
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.adfa.constants.ANDROID_SDK_ZIP
import org.adfa.constants.DOCUMENTATION_DB
import org.adfa.constants.GRADLE_API_NAME_JAR_ZIP
import org.adfa.constants.GRADLE_DISTRIBUTION_ARCHIVE_NAME
import org.adfa.constants.LOCAL_MAVEN_REPO_ARCHIVE_ZIP_NAME
import org.slf4j.LoggerFactory
import java.io.InputStream
import java.nio.file.Files
import java.nio.file.Path
import java.util.UUID
import java.util.zip.ZipInputStream
import kotlin.io.path.ExperimentalPathApi
import kotlin.io.path.deleteRecursively
import kotlin.io.path.pathString

typealias AssetsInstallerProgressConsumer = (AssetsInstallationHelper.Progress) -> Unit

object AssetsInstallationHelper {

    sealed interface Result {
        data object Success : Result
        data class Failure(val cause: Throwable?) :
            Result
    }

    data class Progress(val message: String)

    private val logger = LoggerFactory.getLogger(AssetsInstallationHelper::class.java)
    const val BOOTSTRAP_ENTRY_NAME = "bootstrap.zip"

    suspend fun install(
        context: Context,
        onProgress: AssetsInstallerProgressConsumer = {},
    ): Result = withContext(Dispatchers.IO) {
        val result = runCatching {
            doInstall(context, onProgress)
        }

        if (result.isFailure) {
            logger.error("Failed to install assets", result.exceptionOrNull())
            return@withContext Result.Failure(result.exceptionOrNull())
        }

        return@withContext Result.Success
    }

    @OptIn(ExperimentalPathApi::class)
    private suspend fun doInstall(
        context: Context,
        onProgress: AssetsInstallerProgressConsumer
    ) = coroutineScope {
        onProgress(Progress("Preparing..."))

        val buildConfig = IDEBuildConfigProvider.getInstance()
        val cpuArch = buildConfig.cpuArch
        val expectedEntries = arrayOf(
            GRADLE_DISTRIBUTION_ARCHIVE_NAME,
            ANDROID_SDK_ZIP,
            DOCUMENTATION_DB,
            LOCAL_MAVEN_REPO_ARCHIVE_ZIP_NAME,
            BOOTSTRAP_ENTRY_NAME,
            GRADLE_API_NAME_JAR_ZIP,
        )

        val stagingDir = Files.createTempDirectory(UUID.randomUUID().toString())
        logger.debug("Staging directory ({}): {}", cpuArch, stagingDir)

        // Ensure relevant shared libraries are loaded
        Brotli4jLoader.ensureAvailability()

        // pre-install hook
        AssetsInstaller.preInstall(context, stagingDir)

        onProgress(Progress("Starting installation..."))
        val installerJobs = expectedEntries.map { entry ->
            async {
                AssetsInstaller.doInstall(
                    context = context,
                    stagingDir = stagingDir,
                    cpuArch = cpuArch,
                    entryName = entry
                )
            }
        }

        val totalTasks = installerJobs.size
        val progressUpdater = launch {
            var completed = 0
            var previousUpdate = -1
            while (isActive && completed < totalTasks) {
                completed = installerJobs.count { it.isCompleted }
                if (completed != previousUpdate) {
                    onProgress(Progress("$completed of $totalTasks tasks completed"))
                    previousUpdate = completed
                }
                delay(100)
            }

            completed = installerJobs.count { it.isCompleted }
            if (completed == totalTasks) {
                onProgress(Progress("Installation complete"))
            }
        }

        // wait for all jobs to complete
        installerJobs.joinAll()

        // then cancel progress updater
        progressUpdater.cancel()

        // clean up
        stagingDir.deleteRecursively()
    }

    @WorkerThread
    internal fun extractZipToDir(srcFile: Path, destDir: Path) =
        extractZipToDir(Files.newInputStream(srcFile), destDir)

    @WorkerThread
    internal fun extractZipToDir(srcStream: InputStream, destDir: Path) {
        Files.createDirectories(destDir)
        ZipInputStream(srcStream.buffered()).useEntriesEach { zipInput, entry ->
            val destFile = destDir.resolve(entry.name).normalize()
            if (!destFile.pathString.startsWith(destDir.pathString)) {
                // DO NOT allow extraction to outside of the target dir
                throw IllegalStateException("Entry is outside of the target dir: ${zipInput.buffered()}")
            }

            if (entry.isDirectory) {
                Files.createDirectories(destFile)
            } else {
                Files.newOutputStream(destFile).use { dest ->
                    zipInput.copyTo(dest)
                }
            }
        }
    }
}


================================================
File: java/com/itsaky/androidide/utils/BuildInfoUtils.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.content.Context
import android.os.Build
import com.blankj.utilcode.util.AppUtils
import com.blankj.utilcode.util.DeviceUtils
import com.itsaky.androidide.BuildConfig
import com.itsaky.androidide.app.IDEApplication
import com.itsaky.androidide.app.configuration.IDEBuildConfigProvider
import com.itsaky.androidide.buildinfo.BuildInfo
import com.termux.shared.android.PackageUtils
import com.termux.shared.termux.TermuxConstants
import com.termux.shared.termux.TermuxUtils

/**
 * @author Akash Yadav
 */
object BuildInfoUtils {

  private val BUILD_INFO_HEADER by lazy {
    val map = mapOf(
      "Version" to "v${BuildInfo.VERSION_NAME_SIMPLE} (${AppUtils.getAppVersionCode()})",
      "CI Build" to BuildInfo.CI_BUILD,
      "Branch" to BuildInfo.CI_GIT_BRANCH,
      "Commit" to BuildInfo.CI_GIT_COMMIT_HASH,
      "Variant" to "${IDEBuildConfigProvider.getInstance().cpuAbiName} (${BuildConfig.BUILD_TYPE})",
      "Build type" to getBuildType(),
      "F-Droid Build" to BuildInfo.FDROID_BUILD,
      "F-Droid Version" to BuildInfo.FDROID_BUILD_VERSION_NAME,
      "F-Droid Version code" to BuildInfo.FDROID_BUILD_VERSION_CODE,
      "SDK Version" to Build.VERSION.SDK_INT,
      "Supported ABIs" to "[${Build.SUPPORTED_ABIS.joinToString(separator = ", ")}]",
      "Manufacturer" to DeviceUtils.getManufacturer(),
      "Device" to DeviceUtils.getModel(),
    )
    map.entries.joinToString(separator = System.lineSeparator()) { "${it.key} : ${it.value}" }.trim()
  }

  @JvmStatic
  fun getBuildInfoHeader(): String {
    return BUILD_INFO_HEADER
  }

  private fun getBuildType() = getBuildType(IDEApplication.instance)

  fun getBuildType(context: Context) = if (isOfficialBuild(context)) "OFFICIAL" else "UNOFFICIAL"

  /**
   * Whether the AndroidIDE build is official or not. This checks the signature digest of the
   * APK against the signature digest of the official signing key.
   */
  @JvmStatic
  fun isOfficialBuild(context: Context): Boolean {
    val sha256DigestForPackage = PackageUtils.getSigningCertificateSHA256DigestForPackage(
      context,
      TermuxConstants.TERMUX_PACKAGE_NAME
    )

    val signer = TermuxUtils.getAPKRelease(sha256DigestForPackage)

    return TermuxConstants.APK_RELEASE_ANDROIDIDE == signer
        || TermuxConstants.APK_RELEASE_FDROID == signer
  }
}



================================================
File: java/com/itsaky/androidide/utils/ClassBuilder.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.itsaky.androidide.preferences.utils.indentationString
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.TypeSpec
import jdkx.lang.model.element.Modifier.PROTECTED
import jdkx.lang.model.element.Modifier.PUBLIC

object ClassBuilder {
  @JvmStatic
  fun createClass(packageName: String, className: String): String {
    return toJavaFile(packageName, newClassSpec(className)).toString()
  }

  private fun toJavaFile(
    packageName: String,
    type: TypeSpec,
    block: JavaFile.Builder.() -> Unit = {}
  ): JavaFile {
    return JavaFile.builder(packageName, type)
      .indent(indentationString)
      .apply { block(this) }
      .build()
  }

  private fun newClassSpec(className: String): TypeSpec {
    return TypeSpec.classBuilder(className).addModifiers(PUBLIC).build()
  }

  @JvmStatic
  fun createInterface(packageName: String, className: String): String {
    return toJavaFile(packageName, newInterfaceSpec(className)).toString()
  }

  private fun newInterfaceSpec(className: String): TypeSpec {
    return TypeSpec.interfaceBuilder(className).addModifiers(PUBLIC).build()
  }

  @JvmStatic
  fun createEnum(packageName: String, className: String): String {
    return toJavaFile(packageName, newEnumSpec(className)).toString()
  }

  private fun newEnumSpec(className: String): TypeSpec {
    return TypeSpec.enumBuilder(className)
      .addModifiers(PUBLIC)
      .addEnumConstant("ENUM_DECLARED")
      .build()
  }

  @JvmStatic
  fun createActivity(packageName: String, className: String): String {
    val onCreate =
      MethodSpec.methodBuilder("onCreate")
        .addAnnotation(Override::class.java)
        .addModifiers(PROTECTED)
        .addParameter(Bundle::class.java, "savedInstanceState")
        .addStatement("super.onCreate(savedInstanceState)")
        .build()
    val activity =
      newClassSpec(className)
        .toBuilder()
        .superclass(AppCompatActivity::class.java)
        .addMethod(onCreate)
    return toJavaFile(packageName, activity.build()) { skipJavaLangImports(true) }.toString()
  }
}



================================================
File: java/com/itsaky/androidide/utils/EditorActivityActions.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.utils

import android.content.Context
import com.itsaky.androidide.actions.ActionItem.Location.EDITOR_FILE_TABS
import com.itsaky.androidide.actions.ActionItem.Location.EDITOR_FILE_TREE
import com.itsaky.androidide.actions.ActionItem.Location.EDITOR_TOOLBAR
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.actions.build.DebugAction
import com.itsaky.androidide.actions.build.ProjectSyncAction
import com.itsaky.androidide.actions.build.QuickRunAction
import com.itsaky.androidide.actions.build.RunTasksAction
import com.itsaky.androidide.actions.editor.CopyAction
import com.itsaky.androidide.actions.editor.CutAction
import com.itsaky.androidide.actions.editor.ExpandSelectionAction
import com.itsaky.androidide.actions.editor.LongSelectAction
import com.itsaky.androidide.actions.editor.PasteAction
import com.itsaky.androidide.actions.editor.SelectAllAction
import com.itsaky.androidide.actions.etc.DisconnectLogSendersAction
import com.itsaky.androidide.actions.etc.FindActionMenu
import com.itsaky.androidide.actions.etc.LaunchAppAction
import com.itsaky.androidide.actions.etc.PreviewLayoutAction
import com.itsaky.androidide.actions.file.CloseAllFilesAction
import com.itsaky.androidide.actions.file.CloseFileAction
import com.itsaky.androidide.actions.file.CloseOtherFilesAction
import com.itsaky.androidide.actions.file.FormatCodeAction
import com.itsaky.androidide.actions.file.SaveFileAction
import com.itsaky.androidide.actions.file.ShowTooltipAction
import com.itsaky.androidide.actions.filetree.CopyPathAction
import com.itsaky.androidide.actions.filetree.DeleteAction
import com.itsaky.androidide.actions.filetree.HelpAction
import com.itsaky.androidide.actions.filetree.NewFileAction
import com.itsaky.androidide.actions.filetree.NewFolderAction
import com.itsaky.androidide.actions.filetree.OpenWithAction
import com.itsaky.androidide.actions.filetree.RenameAction
import com.itsaky.androidide.actions.github.GitHubCommitAction
import com.itsaky.androidide.actions.github.GitHubFetchAction
import com.itsaky.androidide.actions.github.GitHubPullAction
import com.itsaky.androidide.actions.github.GitHubPushAction
import com.itsaky.androidide.actions.text.RedoAction
import com.itsaky.androidide.actions.text.UndoAction

/**
 * Takes care of registering actions to the actions registry for the editor activity.
 *
 * @author Akash Yadav
 */
class EditorActivityActions {

  companion object {

    private const val ORDER_COPY_PATH = 100
    private const val ORDER_DELETE = 200
    private const val ORDER_NEW_FILE = 300
    private const val ORDER_NEW_FOLDER = 400
    private const val ORDER_OPEN_WITH = 500
    private const val ORDER_RENAME = 600
    private const val ORDER_HELP = 1000

    @JvmStatic
    fun register(context: Context) {
      clear()
      val registry = ActionsRegistry.getInstance()
      var order = 0

      // Toolbar actions
      registry.registerAction(UndoAction(context, order++))
      registry.registerAction(RedoAction(context, order++))
      registry.registerAction(QuickRunAction(context, order++))
      registry.registerAction(DebugAction(context, order++))
      registry.registerAction(RunTasksAction(context, order++))
      registry.registerAction(SaveFileAction(context, order++))
      registry.registerAction(PreviewLayoutAction(context, order++))
      registry.registerAction(FindActionMenu(context, order++))
      registry.registerAction(ProjectSyncAction(context, order++))
      registry.registerAction(DisconnectLogSendersAction(context, order++))
      registry.registerAction(LaunchAppAction(context, order++))
      registry.registerAction(GitHubCommitAction(context, order++))
      registry.registerAction(GitHubPushAction(context, order++))
      registry.registerAction(GitHubFetchAction(context, order++))
      registry.registerAction(GitHubPullAction(context, order++))

      // editor text actions
      registry.registerAction(ExpandSelectionAction(context, order++))
      registry.registerAction(SelectAllAction(context, order++))
      registry.registerAction(LongSelectAction(context, order++))
      registry.registerAction(CutAction(context, order++))
      registry.registerAction(CopyAction(context, order++))
      registry.registerAction(PasteAction(context, order++))
      registry.registerAction(FormatCodeAction(context, order++))
      registry.registerAction(ShowTooltipAction(context,order++))

      // file tab actions
      registry.registerAction(CloseFileAction(context, order++))
      registry.registerAction(CloseOtherFilesAction(context, order++))
      registry.registerAction(CloseAllFilesAction(context, order++))

      // file tree actions
      registry.registerAction(CopyPathAction(context, ORDER_COPY_PATH))
      registry.registerAction(DeleteAction(context, ORDER_DELETE))
      registry.registerAction(NewFileAction(context, ORDER_NEW_FILE))
      registry.registerAction(NewFolderAction(context, ORDER_NEW_FOLDER))
      registry.registerAction(OpenWithAction(context, ORDER_OPEN_WITH))
      registry.registerAction(RenameAction(context, ORDER_RENAME))
      registry.registerAction(HelpAction(context, ORDER_HELP))
    }

    @JvmStatic
    fun clear() {
      // EDITOR_TEXT_ACTIONS should not be cleared as the language servers register actions there as
      // well
      val locations = arrayOf(EDITOR_TOOLBAR, EDITOR_FILE_TABS, EDITOR_FILE_TREE)
      val registry = ActionsRegistry.getInstance()
      locations.forEach(registry::clearActions)
    }

    @JvmStatic
    fun clearActions() {
      // Clear actions but preserve build actions to prevent cancellation during onPause
      val locations = arrayOf(EDITOR_FILE_TABS, EDITOR_FILE_TREE)
      val registry = ActionsRegistry.getInstance()
      locations.forEach(registry::clearActions)
      
      // Clear toolbar actions except build actions
      registry.clearActionsExceptWhere(EDITOR_TOOLBAR) { action ->
        action.id == "ide.editor.build.quickRun" || 
        action.id == "ide.editor.build.runTasks" || 
        action.id == "ide.editor.build.sync"
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/utils/EditorSidebarActions.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.View
import androidx.annotation.IdRes
import androidx.core.net.toUri
import androidx.core.view.forEach
import androidx.navigation.NavController
import androidx.navigation.NavDestination
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.createGraph
import androidx.navigation.fragment.FragmentNavigator
import androidx.navigation.fragment.FragmentNavigatorDestinationBuilder
import androidx.navigation.fragment.NavHostFragment
import androidx.navigation.get
import androidx.navigation.navOptions
import com.google.android.material.shape.CornerFamily
import com.google.android.material.shape.MaterialShapeDrawable
import com.google.android.material.shape.ShapeAppearanceModel
import com.itsaky.androidide.R
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.actions.FillMenuParams
import com.itsaky.androidide.actions.SidebarActionItem
import com.itsaky.androidide.actions.internal.DefaultActionsRegistry
import com.itsaky.androidide.actions.sidebar.CloseProjectSidebarAction
import com.itsaky.androidide.actions.sidebar.EmailSidebarAction
import com.itsaky.androidide.actions.sidebar.FileTreeSidebarAction
import com.itsaky.androidide.actions.sidebar.GitSidebarAction
import com.itsaky.androidide.actions.sidebar.HelpSideBarAction
import com.itsaky.androidide.actions.sidebar.PreferencesSidebarAction
import com.itsaky.androidide.actions.sidebar.TerminalSidebarAction
import com.itsaky.androidide.fragments.sidebar.EditorSidebarFragment
import com.itsaky.androidide.utils.ContactDetails.EMAIL_SUPPORT
import java.lang.ref.WeakReference

/**
 * Sets up the actions that are shown in the
 * [EditorActivityKt][com.itsaky.androidide.activities.editor.EditorActivityKt]'s drawer's sidebar.
 *
 * @author Akash Yadav
 */

object ContactDetails {
    const val EMAIL_SUPPORT = "feedback@appdevforall.org"
}

internal object EditorSidebarActions {
    val tooltipTags = mutableListOf<String>()

    @JvmStatic
    fun registerActions(context: Context) {
        val registry = ActionsRegistry.getInstance()
        var order = -1

        @Suppress("KotlinConstantConditions")
        registry.registerAction(FileTreeSidebarAction(context, ++order))
//        registry.registerAction(BuildVariantsSidebarAction(context, ++order))
        registry.registerAction(GitSidebarAction(context, ++order))
        registry.registerAction(TerminalSidebarAction(context, ++order))
        registry.registerAction(PreferencesSidebarAction(context, ++order))
        registry.registerAction(CloseProjectSidebarAction(context, ++order))
        registry.registerAction(HelpSideBarAction(context, ++order))
        registry.registerAction(EmailSidebarAction(context, ++order))
    }

    @JvmStatic
    fun setup(sidebarFragment: EditorSidebarFragment) {
        val binding = sidebarFragment.getBinding() ?: return
        val controller = binding.fragmentContainer.getFragment<NavHostFragment>().navController
        val context = sidebarFragment.requireContext()
        val rail = binding.navigation


        val registry = ActionsRegistry.getInstance()
        val actions = registry.getActions(ActionItem.Location.EDITOR_SIDEBAR)
        if (actions.isEmpty()) {
            return
        }

        rail.background = (rail.background as MaterialShapeDrawable).apply {
            shapeAppearanceModel = shapeAppearanceModel.roundedOnRight()
        }

        rail.menu.clear()

        val data = ActionData.create(context)
        val titleRef = WeakReference(binding.title)
        val params = FillMenuParams(
            data,
            ActionItem.Location.EDITOR_SIDEBAR,
            rail.menu
        ) { actionsRegistry, action, item, actionsData ->
            action as SidebarActionItem

            if (action.fragmentClass == null) {
                (actionsRegistry as DefaultActionsRegistry).executeAction(action, actionsData)
                return@FillMenuParams true
            }

            return@FillMenuParams try {
                controller.navigate(action.id, navOptions {
                    launchSingleTop = true
                    restoreState = true
                })

                val result = controller.currentDestination?.matchDestination(action.id) == true
                if (result) {
                    item.isChecked = true
                    titleRef.get()?.text = item.title
                }

                result
            } catch (e: IllegalArgumentException) {
                false
            }
        }

        registry.fillMenu(params)

        rail.menu.forEach { item ->
            val view = rail.findViewById<View>(item.itemId)
            val action = actions.values.find { it.itemId == item.itemId } as? SidebarActionItem

            if (view != null && action != null) {
                val tag = action.tooltipTag()
                sidebarFragment.setupTooltip(view, "ide", tag)
                tooltipTags += tag
            }
        }

        controller.graph = controller.createGraph(startDestination = FileTreeSidebarAction.ID) {
            actions.forEach { (actionId, action) ->
                if (action !is SidebarActionItem) {
                    throw IllegalStateException(
                        "Actions registered at location ${ActionItem.Location.EDITOR_SIDEBAR}" +
                                " must implement ${SidebarActionItem::class.java.simpleName}"
                    )
                }

                val fragment = action.fragmentClass ?: return@forEach

                val builder = FragmentNavigatorDestinationBuilder(
                    provider[FragmentNavigator::class],
                    actionId,
                    fragment
                )

                builder.apply {
                    action.apply { buildNavigation() }
                }

                destination(builder)
            }
        }

        val railRef = WeakReference(rail)
        controller.addOnDestinationChangedListener(
            object : NavController.OnDestinationChangedListener {
                override fun onDestinationChanged(
                    controller: NavController,
                    destination: NavDestination,
                    arguments: Bundle?
                ) {
                    val railView = railRef.get()
                    if (railView == null) {
                        controller.removeOnDestinationChangedListener(this)
                        return
                    }
                    railView.menu.forEach { item ->
                        if (destination.matchDestination(item.itemId)) {
                            item.isChecked = true
                            titleRef.get()?.text = item.title
                        }
                    }
                }
            })

        rail.menu.findItem(FileTreeSidebarAction.ID.hashCode())?.also {
            it.isChecked = true
            binding.title.text = it.title
        }
    }

    /**
     * Determines whether the given `route` matches the NavDestination. This handles
     * both the default case (the destination's route matches the given route) and the nested case where
     * the given route is a parent/grandparent/etc of the destination.
     */
    @JvmStatic
    internal fun NavDestination.matchDestination(route: String): Boolean =
        hierarchy.any { it.route == route }

    @JvmStatic
    internal fun NavDestination.matchDestination(@IdRes destId: Int): Boolean =
        hierarchy.any { it.id == destId }

    @JvmStatic
    internal fun ShapeAppearanceModel.roundedOnRight(cornerSize: Float = 28f): ShapeAppearanceModel {
        return toBuilder().run {
            setTopRightCorner(CornerFamily.ROUNDED, cornerSize)
            setBottomRightCorner(CornerFamily.ROUNDED, cornerSize)
            build()
        }
    }

    fun showContactDialog(context: Context) {
        val builder = DialogUtils.newMaterialDialogBuilder(context)

        builder.setTitle(R.string.msg_contact_app_dev_title)
            .setMessage(R.string.msg_contact_app_dev_description)
            .setNegativeButton(android.R.string.cancel) { dialog, _ ->
                dialog.dismiss()
            }
            .setPositiveButton(R.string.send_email) { dialog, _ ->
                val intent = Intent(Intent.ACTION_SENDTO).apply {
                    data = "mailto:$EMAIL_SUPPORT?subject=${context.getString(R.string.feedback_email_subject)}".toUri()
                }
                context.startActivity(intent)
                dialog.dismiss()
            }
            .create()
            .show()
    }

    fun SidebarActionItem.tooltipTag(): String {
        return "ide.sidebar.${label.lowercase().replace("[^a-z0-9]+".toRegex(), "_")}.longpress"
    }
}


================================================
File: java/com/itsaky/androidide/utils/FlexboxUtils.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.view.ViewTreeObserver
import androidx.recyclerview.widget.RecyclerView
import com.google.android.flexbox.FlexboxLayoutManager
import kotlin.math.ceil

/**
 * @author Akash Yadav
 */
object FlexboxUtils {

  @JvmStatic
  inline fun <T: RecyclerView.Adapter<*>> createGlobalLayoutListenerToDistributeFlexboxItemsEvenly(
    crossinline adapterProvider: () -> T?,
    crossinline layoutManagerProvider: () -> FlexboxLayoutManager?,
    crossinline fillDiff: (T, diff: Int) -> Unit
  ): ViewTreeObserver.OnGlobalLayoutListener {

    return object : ViewTreeObserver.OnGlobalLayoutListener {
      override fun onGlobalLayout() {

        val adapter = adapterProvider() ?: return
        val layoutManager = layoutManagerProvider() ?: return

        val columns = layoutManager.flexLinesInternal.firstOrNull()?.itemCount ?: 0
        if (columns == 0) {
          return
        }

        val itemCount = adapter.itemCount
        val rows = ceil(itemCount.toFloat() / columns.toFloat()).toInt()
        if (itemCount % columns == 0) {
          return
        }

        val diff = rows * columns - itemCount
        if (diff <= 0) {
          return
        }

        fillDiff(adapter, diff)
      }
    }
  }
}


================================================
File: java/com/itsaky/androidide/utils/InstallationResultHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.IntentSender
import android.content.pm.PackageInstaller
import com.itsaky.androidide.services.InstallationResultReceiver
import org.slf4j.LoggerFactory

/**
 * Handles result of APK installation.
 *
 * @author Akash Yadav
 */
object InstallationResultHandler {

  private const val INSTALL_PACKAGE_REQ_CODE = 2304
  private const val INSTALL_PACKAGE_ACTION = "com.itsaky.androidide.installer.INSTALL_PACKAGE"

  private val log = LoggerFactory.getLogger(InstallationResultHandler::class.java)

  @JvmStatic
  fun createEditorActivitySender(
    context: Context,
    createIntent: () -> Intent = { Intent() },
  ): IntentSender {
    val intent = createIntent()
    intent.setClass(context, InstallationResultReceiver::class.java)
    intent.action = INSTALL_PACKAGE_ACTION
    return PendingIntent.getBroadcast(
      context,
      INSTALL_PACKAGE_REQ_CODE,
      intent,
      PendingIntent.FLAG_UPDATE_CURRENT
    ).intentSender
  }

  @JvmStatic
  fun onResult(context: Context?, intent: Intent?): String? {
    if (context == null || intent == null || intent.action != INSTALL_PACKAGE_ACTION) {
      log.warn("Invalid broadcast received. action={}", intent?.action)
      return null
    }

    val extras =
      intent.extras
        ?: run {
          log.warn("Invalid intent received in broadcast")
          return null
        }

    val packageName = extras.getString(PackageInstaller.EXTRA_PACKAGE_NAME)
    val status = extras.getInt(PackageInstaller.EXTRA_STATUS)
    val message = extras.getString(PackageInstaller.EXTRA_STATUS_MESSAGE)
    return when (status) {
      PackageInstaller.STATUS_PENDING_USER_ACTION -> {
        @Suppress("DEPRECATION")
        extras.get(Intent.EXTRA_INTENT)?.let {
          if (it is Intent) {
            if ((it.flags and Intent.FLAG_ACTIVITY_NEW_TASK) != Intent.FLAG_ACTIVITY_NEW_TASK) {
              it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            }
            context.startActivity(it)
          }
        }
        null
      }

      PackageInstaller.STATUS_SUCCESS -> {
        log.info("Package installed successfully!")
        packageName
      }

      PackageInstaller.STATUS_FAILURE,
      PackageInstaller.STATUS_FAILURE_ABORTED,
      PackageInstaller.STATUS_FAILURE_BLOCKED,
      PackageInstaller.STATUS_FAILURE_CONFLICT,
      PackageInstaller.STATUS_FAILURE_INCOMPATIBLE,
      PackageInstaller.STATUS_FAILURE_INVALID,
      PackageInstaller.STATUS_FAILURE_STORAGE -> {
        log.error("Package installation failed with status code {} and message {}", status, message)
        null
      }

      else -> {
        log.warn("Invalid status code received in broadcast: {}", status)
        null
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/utils/IntentUtils.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.core.app.ShareCompat
import androidx.core.content.FileProvider
import com.blankj.utilcode.util.ImageUtils
import com.blankj.utilcode.util.ImageUtils.ImageType.TYPE_UNKNOWN
import com.itsaky.androidide.R
import java.io.File

/**
 * Utilities for sharing files.
 *
 * @author Akash Yadav
 */
object IntentUtils {

  private const val RESULT_LAUNCH_APP_INTENT_SENDER = 223

  @JvmStatic
  fun openImage(context: Context, file: File) {
    imageIntent(context = context, file = file, intentAction = Intent.ACTION_VIEW)
  }

  @JvmStatic
  @JvmOverloads
  fun imageIntent(
    context: Context,
    file: File,
    intentAction: String = Intent.ACTION_SEND
  ) {
    val type = ImageUtils.getImageType(file)
    var typeString = type.value
    if (type == TYPE_UNKNOWN) {
      typeString = "*"
    }
    startIntent(
      context = context,
      file = file,
      mimeType = "image/$typeString",
      intentAction = intentAction
    )
  }

  @JvmStatic
  fun shareFile(context: Context, file: File, mimeType: String) {
    startIntent(context = context, file = file, mimeType = mimeType)
  }

  @JvmStatic
  @JvmOverloads
  fun startIntent(
    context: Context,
    file: File,
    mimeType: String = "*/*",
    intentAction: String = Intent.ACTION_SEND
  ) {
    val uri =
      FileProvider.getUriForFile(context, "${context.packageName}.providers.fileprovider", file)
    val intent =
      ShareCompat.IntentBuilder(context)
        .setType(mimeType)
        .setStream(uri)
        .intent
        .setAction(intentAction)
        .setDataAndType(uri, mimeType)
        .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)

    context.startActivity(Intent.createChooser(intent, null))
  }

  /**
   * Launch the application with the given [package name][packageName].
   *
   * @param context The context that will be used to fetch the launch intent.
   * @param packageName The package name of the application.
   */
  @JvmOverloads
  fun launchApp(context: Context, packageName: String, logError: Boolean = true) : Boolean {
    if (Build.VERSION.SDK_INT >= 33) {
      return launchAppApi33(context, packageName, logError)
    }

    return doLaunchApp(context, packageName, logError)
  }

  private fun doLaunchApp(context: Context, packageName: String, logError: Boolean = true) : Boolean {
    try {
      val launchIntent = context.packageManager.getLaunchIntentForPackage(packageName)
      if (launchIntent == null) {
        flashError(R.string.msg_app_launch_failed)
        return false
      }

      context.startActivity(launchIntent)
      return true
    } catch (e: Throwable) {
      flashError(R.string.msg_app_launch_failed)
      if (logError) {
        ILogger.ROOT.error("Failed to launch application with package name '{}'", packageName, e)
      }
      return false
    }
  }

  @RequiresApi(33)
  private fun launchAppApi33(context: Context, packageName: String, logError: Boolean = true) : Boolean {
    return try {
      val sender = context.packageManager.getLaunchIntentSenderForPackage(packageName)
      sender.sendIntent(
        context,
        RESULT_LAUNCH_APP_INTENT_SENDER,
        null,
        null,
        null
      )
      true
    } catch (e: Throwable) {
      flashError(R.string.msg_app_launch_failed)
      if (logError) {
        ILogger.ROOT.error("Failed to launch app", e)
      }
      false
    }
  }
}



================================================
File: java/com/itsaky/androidide/utils/JSONUtility.java
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.utils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.itsaky.androidide.tooling.api.util.ToolingApiLauncher;

public class JSONUtility {
  public static final Gson gson = new Gson();
  public static final Gson toolingGson;
  public static final Gson prettyPrinter = new GsonBuilder().setPrettyPrinting().create();

  static {
    final var builder = new GsonBuilder();
    ToolingApiLauncher.configureGson(builder);
    toolingGson = builder.create();
  }
}



================================================
File: java/com/itsaky/androidide/utils/JdkUtils.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import androidx.annotation.VisibleForTesting
import androidx.annotation.WorkerThread
import com.itsaky.androidide.app.IDEApplication
import com.itsaky.androidide.models.JdkDistribution
import com.itsaky.androidide.shell.executeProcessAsync
import com.termux.shared.termux.shell.command.environment.TermuxShellEnvironment
import org.slf4j.LoggerFactory
import java.io.File
import java.nio.file.Files

/**
 * Utilities related to JDK installations.
 *
 * @author Akash Yadav
 */
object JdkUtils {

  private val log = LoggerFactory.getLogger(JdkUtils::class.java)

  /**
   * Finds the available JDK installations and returns the JAVA_HOME for each installation.
   */
  @JvmStatic
  @WorkerThread
  fun findJavaInstallations(): List<JdkDistribution> {

    // a valid JDK can be installed anywhere in the file system
    // however, we currently only check for installations that are located in $PREFIX/lib/jvm dir
    // TODO: Find a way to efficiently list all JDK installations, including those which are located
    //    outside of $PREFIX/lib/jvm
    return try {
      log.debug("Starting to find Java installations.")
      val optDir = File(Environment.PREFIX, "lib/jvm")
      log.debug("optDir: {}", optDir)
      if (!optDir.exists() || !optDir.isDirectory) {
        log.debug("optDir does not exist or is not a directory. optDir.exists(): {}, optDir.isDirectory(): {}", optDir.exists(), optDir.isDirectory)
        emptyList()
      } else {
        log.debug("optDir exists and is a directory.")
        optDir.listFiles()?.mapNotNull { dir ->
          log.debug("Processing directory: {}", dir)
          if (Files.isSymbolicLink(dir.toPath())) {
            // ignore symbolic links
            log.debug("Directory {} is a symbolic link. Ignoring.", dir)
            return@mapNotNull null
          }
          log.debug("Directory {} is not a symbolic link.", dir)

          val java = File(dir, "bin/java")
          log.debug("java: {}", java)
          if (!canExecute(java)) {
            // java binary does not exist or is not executable
            log.debug("Java binary {} does not exist or is not executable. canExecute(java): {}", java, canExecute(java))
            return@mapNotNull null
          }
          log.debug("Java binary {} exists and is executable.", java)

          val dist = getDistFromJavaBin(java)
          log.debug("Got JdkDistribution for java binary {}: {}", java, dist)
          return@mapNotNull dist
        } ?: run {
          log.error("Failed to list files in {}", optDir)
          log.debug("optDir.listFiles() returned null.")
          emptyList()
        }
      }
    } catch (e: Exception) {
      log.error("Failed to list java alternatives", e)
      log.debug("Exception caught while finding Java installations: {}", e.message)
      emptyList()
    }.also {
      log.debug("Finished finding Java installations. Result: {}", it)
    }
  }

  private fun canExecute(file: File): Boolean {
    return file.exists() && file.isFile && file.canExecute()
  }

  /**
   * Returns a [JdkDistribution] instances representing the JDK installation of the given
   * `java` binary executable. This binary file is executed to extract the actual `java.home`
   * value.
   *
   * @param java The path to the `java` binary executable.
   * @return The [JdkDistribution] instance, or `null` if there was an error while getting required
   * information from the installation.
   */
  @JvmStatic
  fun getDistFromJavaBin(java: File): JdkDistribution? {
    if (!java.exists() || !java.isFile || !java.canExecute()) {
      log.error(
        "Failed to lookup JDK installation. File '{}' does not exist or cannot be executed.", java)
      return null
    }

    val properties = readProperties(java) ?: run {
      log.error("Failed to retrieve Java properties from java binary: '{}'", java)
      return null
    }

    return readDistFromProps(properties)
  }

  @VisibleForTesting
  internal fun readDistFromProps(properties: String): JdkDistribution? {
    val javaHome = Regex("java\\.home\\s*=\\s*(.*)").find(properties)?.groupValues?.get(1) ?: run {
      log.error("Failed to determine property 'java.home'. Properties: {}", properties)
      return null
    }

    log.debug("Found java.home=${javaHome}")

    val javaVersion = Regex("java\\.version\\s*=\\s*(.*)").find(properties)?.groupValues?.get(1)
      ?: run {
        log.error("Failed to determine property 'java.version'. Properties: {}", properties)
        return null
      }

    log.debug("Found java.version={}", javaVersion)

    return JdkDistribution(javaVersion, javaHome)
  }

  /**
   * Returns a [JdkDistribution] instance representing the JDK installation at the given
   * location.
   *
   * @param javaHome The path to the installed JDK.
   * @return The [JdkDistribution] instance, or `null` if there was an error while getting required
   * information from the installation.
   */
  @JvmStatic
  fun getDistFromJavaHome(javaHome: File): JdkDistribution? {
    return getDistFromJavaBin(javaHome.resolve("bin/java"))
  }

  private fun readProperties(file: File): String? {
    val propsCmd = "${file.absolutePath} -XshowSettings:properties -version"
    val process = executeWithBash(propsCmd) ?: return null
    return process.inputStream.bufferedReader().readText()
  }

  @WorkerThread
  private fun executeWithBash(cmd: String): Process? {
    val shell = Environment.BASH_SHELL

    if (!canExecute(shell)) {
      log.warn(
        "Unable to determine JDK installations. Command {} not found or is not executable.",
        shell.absolutePath)
      return null
    }

    val env = HashMap(TermuxShellEnvironment().getEnvironment(IDEApplication.instance, false))

    return executeProcessAsync {
      command = listOf(shell.absolutePath, "-c", cmd)
      environment = env
      redirectErrorStream = true
      workingDirectory = Environment.HOME
    }
  }
}


================================================
File: java/com/itsaky/androidide/utils/ListingFileRedirect.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import java.io.File
import java.io.PrintWriter
import java.io.StringReader
import java.util.Properties

object ListingFileRedirect {
  
  /**
   * Redirect file will have this marker as the first line as comment.
   */
  const val REDIRECT_MARKER = "#- File Locator -"
  
  /**
   * Property name in a [Properties] for the metadata file location.
   */
  const val REDIRECT_PROPERTY_NAME = "listingFile"
  
  /**
   * Redirect file name used when for the artifact.
   */
  const val REDIRECT_FILE_NAME = "redirect.txt"
  
  fun writeRedirect(listingFile: File, into: File) {
    val path = try {
      into.parentFile!!.toPath().relativize(listingFile.toPath()).toString()
    } catch(ex: IllegalArgumentException) {
      listingFile.canonicalPath
    }
    PrintWriter(into).use {
      it.println(REDIRECT_MARKER)
      it.println("${REDIRECT_PROPERTY_NAME}=${path.replace("\\", "/")}")
    }
  }
  
  private fun maybeExtractRedirectedFile(redirectFile: File, redirectFileContent: String? = null): File? {
    val fileContent = redirectFileContent ?: redirectFile.readText()
    return if (fileContent.startsWith(REDIRECT_MARKER)) {
      val fileLocator = Properties().also {
        it.load(StringReader(fileContent))
      }
      val file = File(fileLocator.getProperty(REDIRECT_PROPERTY_NAME))
      if(!file.isAbsolute)
        redirectFile.parentFile?.resolve(file)
      else
        file
    } else null
  }
  
  @JvmStatic
  fun getListingFile(inputFile: File) =
    maybeExtractRedirectedFile(inputFile) ?: inputFile
}




================================================
File: java/com/itsaky/androidide/utils/MemoryUsageWatcher.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.app.ActivityManager
import android.os.Debug
import android.os.Debug.MemoryInfo
import androidx.collection.IntObjectMap
import androidx.collection.MutableIntObjectMap
import androidx.core.content.getSystemService
import com.itsaky.androidide.app.BaseApplication
import com.itsaky.androidide.tasks.cancelIfActive
import com.termux.shared.reflection.ReflectionUtils
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.newSingleThreadContext
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Handles memory usage information of the IDE.
 *
 * @property updateInterval The interval at which to update the memory usage.
 * @author Akash Yadav
 */
class MemoryUsageWatcher(
  private val updateInterval: Long = DEFAULT_UPDATE_INTERVAL
) {

  @OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
  private val coroutineDispatcher = newSingleThreadContext("MemoryUsageWatcher")
  private val coroutineScope = CoroutineScope(coroutineDispatcher)
  private val memoryUsage = ConcurrentHashMap<Int, ProcessMemoryInfo>()
  private val watching = AtomicBoolean(false)

  /**
   * Whether the memory usage watcher is watching processes for their memory usage.
   */
  val isWatching: Boolean
    get() = watching.get()

  /**
   * The listener to be notified when the memory usage of a process changes.
   */
  var listener: MemoryUsageListener? = null

  companion object {

    private val android_os_Debug_getMemoryInfo by lazy {
      checkNotNull(ReflectionUtils.getDeclaredMethod(Debug::class.java, "getMemoryInfo",
        Int::class.javaPrimitiveType, MemoryInfo::class.java)) {
        "Unable to find getMemoryInfo method in android.os.Debug class"
      }
    }

    const val MAX_USAGE_ENTRIES = 30
    const val DEFAULT_UPDATE_INTERVAL = 1000L
    private val log = LoggerFactory.getLogger(MemoryUsageWatcher::class.java)
  }

  /**
   * Start watching processes for their memory usage.
   */
  fun startWatching() {
    if (isWatching) {
      log.warn("Processes are already being watched for memory usage")
      return
    }

    watching.set(true)

    coroutineScope.launch(context = SupervisorJob() + coroutineDispatcher) {
      while (isWatching) {
        readUsages()

        // don't bother to update if no listeners are set
        listener?.also { listener ->
          val usages = MutableIntObjectMap<ProcessMemoryInfo>(memoryUsage.size)
          for ((pid, usage) in this@MemoryUsageWatcher.memoryUsage) {
            usages[pid] = usage
          }
          withContext(Dispatchers.Main.immediate) {
            listener.onMemoryUsageChanged(usages)
          }
        }

        delay(1000)
      }
    }
  }

  private fun readUsages() {
    val activityManager = BaseApplication.getBaseInstance().getSystemService<ActivityManager>()
    if (activityManager == null) {
      log.error("ActivityManager is null")
      return
    }

    val pids = memoryUsage.keys.toIntArray()
    pids.forEach { pid ->

      // ActivityManager.getProcessMemoryInfo is rate-limited
      // but it internally uses Debug.getMemoryInfo to get the memory info
      // we use it directly using reflection to bypass the rate limit
      val proc = memoryUsage[pid] ?: run {
        log.warn("Process {} is not being watched, but readUsages() was called for the process", pid)
        return@forEach
      }

      ReflectionUtils.invokeMethod(android_os_Debug_getMemoryInfo, null, pid, proc.memInfo)

      // From https://developer.android.com/tools/dumpsys#meminfo
      // "PSS is a good measure for the actual RAM weight of a process and for comparison against
      // the RAM use of other processes and the total available RAM."
      val usage = proc.memInfo.totalPss

      // values are in kB, convert to bytes
      val usageBytes = usage * 1024L
      memoryUsage[pid]!!.apply {
        // we insert the usage entry at the start of the array, then increment the shift amount by 1
        // this makes the newly inserted usage entry the last element in the array
        // and the oldest usage entry the first element in the array

        // this means that _history[_history.size - 1] will be the newest usage entry

        // the "shift" amount basically indicates what is the start index of the array
        // for example, if shift is 1, then _history[0] will actually return _history[1] (index shifted by 1 to the right)
        // when the shift amount exceeds the size of the array, it will be reset to 0 (wrapped around)

        _history[0] = usageBytes
        _history.shift(1)
      }
    }
  }

  /**
   * Watches the memory usage of the given process.
   *
   * @param pid The process ID.
   * @param pname The process name.
   * @param unique Whether to unwatch the process with the same process name.
   */
  fun watchProcess(pid: Int, pname: String, unique: Boolean = true) {
    if (memoryUsage.containsKey(pid)) {
      log.warn("Process {} is already being watched", pid)
      return
    }

    if (unique) {
      // unwatch the process with the given process name
      unwatchProcess(pname)
    }

    memoryUsage[pid] = ProcessMemoryInfo(pid, pname,
      MutableShiftedLongArray(MAX_USAGE_ENTRIES))
  }

  /**
   * Returns the memory usage of all the registered processes.
   */
  fun getMemoryUsages(): Array<ProcessMemoryInfo> {
    return memoryUsage.values.toTypedArray()
  }

  /**
   * Returns the memory usage of the given process (in bytes).
   */
  fun getMemoryUsage(processId: Int): ProcessMemoryInfo? {
    return memoryUsage[processId]
  }

  /**
   * Removes the given process from the watch list.
   */
  fun unwatchProcess(processId: Int) {
    memoryUsage.remove(processId)
  }

  /**
   * Removes the process with the given process name from the watch list.
   */
  fun unwatchProcess(procName: String) {
    memoryUsage.values.forEach {
      if (it.pname == procName) {
        memoryUsage.remove(it.pid)
      }
    }
  }

  /**
   * Unwatches all the registered processes.
   */
  fun unwatchAll() {
    memoryUsage.clear()
  }

  /**
   * Stop watching processes for their memory usage.
   */
  fun stopWatching(unwatchAll: Boolean = true) {
    if (unwatchAll) {
      unwatchAll()
    }
    watching.set(false)
    coroutineScope.cancelIfActive("Cancellation requested")
  }

  /**
   * Registers a listener to be notified when the memory usage of a process changes.
   */
  fun interface MemoryUsageListener {

    /**
     * Called when the memory usage of a process changes.
     *
     * @param memoryUsage The memory usage of all the registered processes.
     */
    fun onMemoryUsageChanged(memoryUsage: IntObjectMap<ProcessMemoryInfo>)
  }

  /**
   * Represents the memory usage of a process.
   *
   * @property pid The process ID.
   * @property memInfo The latest [MemoryInfo] object. Stored here to ensure that we only allocate
   * a single [MemoryInfo] object for a process.
   * @property usageHistory The memory usage history of the process.
   */
  data class ProcessMemoryInfo(
    val pid: Int,
    val pname: String,
    internal val _history: MutableShiftedLongArray
  ) {

    internal val memInfo: MemoryInfo = MemoryInfo()

    val usageHistory: ShiftedLongArray
      get() = _history

    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other !is ProcessMemoryInfo) return false

      if (pid != other.pid) return false
      if (!_history.contentEquals(other._history)) return false

      return true
    }

    override fun hashCode(): Int {
      var result = pid
      result = 31 * result + _history.contentHashCode()
      return result
    }
  }
}


================================================
File: java/com/itsaky/androidide/utils/MutableShiftedLongArray.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

/**
 * Mutable version of [ShiftedLongArray].
 *
 * @author Akash Yadav
 */
class MutableShiftedLongArray(
  array: LongArray,
  shift: Int = 0
) : ShiftedLongArray(array, shift) {

  /**
   * @param capacity The capacity of the array.
   * @param shift The shift amount.
   * @param init A function to initialize the values of the array.
   */
  constructor(capacity: Int, shift: Int = 0, init: (Int) -> Long = { 0 }) : this(
    LongArray(capacity, init),
    shift)

  operator fun set(index: Int, value: Long) {
    checkIdx(index)
    array[getShiftedIndex(index)] = value
  }

  /**
   * Sets the given value at the specified absolute (un-shifted) index.
   */
  fun setAbsolute(index: Int, value: Long) {
    array[index] = value
  }

  /**
   * Shifts the array by the specified amount. The shift amount is added to the current shift.
   *
   * @param shift The shift amount.
   */
  fun shift(shift: Int) {
    this.shift = (this.shift + shift) % size
  }
}


================================================
File: java/com/itsaky/androidide/utils/NoOpServiceConnection.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.content.ComponentName
import android.content.ServiceConnection
import android.os.IBinder

/**
 * A no-op [ServiceConnection].
 *
 * @author Akash Yadav
 */
class NoOpServiceConnection : ServiceConnection {
  override fun onServiceConnected(name: ComponentName?, service: IBinder?) {}
  override fun onServiceDisconnected(name: ComponentName?) {}
}


================================================
File: java/com/itsaky/androidide/utils/ProjectWriter.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils;

import static java.lang.Character.isUpperCase;
import static java.lang.Character.toLowerCase;

import androidx.annotation.NonNull;
import com.blankj.utilcode.util.ResourceUtils;
import java.io.File;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import kotlin.text.StringsKt;

public class ProjectWriter {

  private static final String XML_TEMPLATE_PATH = "templates/xml";
  private static final String SOURCE_PATH_REGEX = "/.*/src/.*/java|kt";

  @NonNull
  public static String createMenu() {
    return ResourceUtils.readAssets2String(XML_TEMPLATE_PATH + "/menu.xml");
  }

  @NonNull
  public static String createDrawable() {
    return ResourceUtils.readAssets2String(XML_TEMPLATE_PATH + "/drawable.xml");
  }

  @NonNull
  public static String createLayout() {
    return ResourceUtils.readAssets2String(XML_TEMPLATE_PATH + "/layout.xml");
  }

  @NonNull
  public static String createLayoutName(String name) {
    final var nameWithoutExtension = StringsKt.substringBeforeLast(name, '.', name);
    var baseName = nameWithoutExtension;
    if (baseName.endsWith("Activity")) {
      baseName = StringsKt.substringBeforeLast(baseName, "Activity", baseName);
      baseName = "activity" + baseName;
    } else if (baseName.endsWith("Fragment")) {
      baseName = StringsKt.substringBeforeLast(baseName, "Fragment", baseName);
      baseName = "fragment" + baseName;
    } else {
      baseName = "layout" + baseName;
    }

    final var sb = new StringBuilder();
    var hasUpper = false;
    for (int i = 0; i < baseName.length(); i++) {
      final char c = baseName.charAt(i);
      if (isUpperCase(c)) {
        hasUpper = true;
        sb.append("_");
        sb.append(toLowerCase(c));
        continue;
      }

      sb.append(c);
    }

    if (!hasUpper) {
      sb.delete(0, sb.length());
      sb.append("layout_");
      sb.append(nameWithoutExtension);
    }

    sb.append(".xml");

    return sb.toString();
  }

  public static String getPackageName(File parentPath) {
    // Returns the package name or the closest internal and if none is found, returns null
    Matcher pkgMatcher = Pattern.compile(SOURCE_PATH_REGEX).matcher(parentPath.getAbsolutePath());

    if (pkgMatcher.find()) {
      int end = pkgMatcher.end();
      if (end <= 0) return "";

      String name = parentPath.getAbsolutePath().substring(end);
      if (name.startsWith(File.separator)) {
        name = name.substring(1);
      }

      if (!name.isEmpty()) {
        return name.replace(File.separator, ".");
      }

      File[] files = parentPath.listFiles();
      if (files != null) {
        for (File file : files) {
          if (file.isDirectory() && isValidPackageName(file.getName())) {
            return file.getName();
          }
        }
      }
      return "";
    }

    return null;
  }

  private static boolean isValidPackageName(String name) {
    return name.matches("^[a-zA-Z_][a-zA-Z0-9_]*$");
  }

  public static String createJavaClass(String packageName, String className) {
    return ClassBuilder.createClass(packageName, className);
  }

  public static String createJavaInterface(String packageName, String className) {
    return ClassBuilder.createInterface(packageName, className);
  }

  public static String createJavaEnum(String packageName, String className) {
    return ClassBuilder.createEnum(packageName, className);
  }

  public static String createActivity(String packageName, String className) {
    return ClassBuilder.createActivity(packageName, className);
  }
}



================================================
File: java/com/itsaky/androidide/utils/RecursiveFileSearcher.java
================================================
/************************************************************************************
 * This file is part of AndroidIDE.
 *
 *
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 **************************************************************************************/
package com.itsaky.androidide.utils;

import com.blankj.utilcode.util.FileIOUtils;
import com.blankj.utilcode.util.FileUtils;
import com.itsaky.androidide.models.Position;
import com.itsaky.androidide.models.Range;
import com.itsaky.androidide.models.SearchResult;
import com.itsaky.androidide.tasks.TaskExecutor;
import io.github.rosemoe.sora.text.CharPosition;
import io.github.rosemoe.sora.text.Content;
import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class provides API to search in files recursively
 *
 * @author Akash Yadav
 */
public class RecursiveFileSearcher {

  /**
   * Search the given text in files recursively in given search directories
   *
   * @param text       Text to search
   * @param exts       Extentions of file to search. Maybe null.
   * @param searchDirs Directories to search in. Subdirectories will be included
   * @param callback   A listener that will listen to the search result
   */
  public static void searchRecursiveAsync(
      String text, List<String> exts, List<File> searchDirs, Callback callback) {
    // Cannot search empty or null text
    if (text == null || text.isEmpty()) {
      return;
    }

    // If there is no listener to the search, search is meaningless
    if (callback == null) {
      return;
    }

    // Avoid searching if no directories are specified
    if (searchDirs == null || searchDirs.isEmpty()) {
      return;
    }

    TaskExecutor.executeAsync(new Searcher(text, exts, searchDirs), callback::onResult);
  }

  private static class Searcher implements Callable<Map<File, List<SearchResult>>> {

    private final String query;
    private final List<String> exts;
    private final List<File> dirs;

    public Searcher(String query, List<String> exts, List<File> dirs) {
      this.query = query;
      this.exts = exts;
      this.dirs = dirs;
    }

    @Override
    public Map<File, List<SearchResult>> call() throws Exception {
      final Map<File, List<SearchResult>> result = new HashMap<>();
      for (int i = 0; i < dirs.size(); i++) {
        final File dir = dirs.get(i);
        final List<File> files =
            FileUtils.listFilesInDirWithFilter(dir, new MultiFileFilter(exts), true);
        for (int j = 0; files != null && j < files.size(); j++) {
          final File file = files.get(j);
          if (file.isDirectory()) {
            continue;
          }
          final String text = FileIOUtils.readFile2String(file);
          if (text == null || text.trim().isEmpty()) {
            continue;
          }
          final Content content = new Content(text);
          final List<SearchResult> ranges = new ArrayList<>();
          Matcher matcher = Pattern.compile(Pattern.quote(this.query)).matcher(text);
          while (matcher.find()) {
            final Range range = new Range();
            final CharPosition start = content.getIndexer().getCharPosition(matcher.start());
            final CharPosition end = content.getIndexer().getCharPosition(matcher.end());
            range.setStart(new Position(start.line, start.column));
            range.setEnd(new Position(end.line, end.column));
            String sub =
                "..."
                    .concat(
                        text.substring(
                            Math.max(0, matcher.start() - 30),
                            Math.min(matcher.end() + 31, text.length())))
                    .trim()
                    .concat("...");
            String match =
                content.subContent(start.line, start.column, end.line, end.column).toString();
            ranges.add(new SearchResult(range, file, sub.replaceAll("\\s+", " "), match));
          }
          if (ranges.size() > 0) {
            result.put(file, ranges);
          }
        }
      }
      return result;
    }
  }

  private static class MultiFileFilter implements FileFilter {

    private final List<String> exts;

    public MultiFileFilter(List<String> exts) {
      this.exts = exts;
    }

    @Override
    public boolean accept(File file) {
      boolean accept = false;
      if (exts == null || exts.isEmpty() || file.isDirectory()) {
        accept = true;
      } else {
        for (String ext : exts) {
          if (file.getName().endsWith(ext)) {
            accept = true;
            break;
          }
        }
      }

      return accept && FileUtils.isUtf8(file);
    }
  }

  public static interface Callback {

    void onResult(Map<File, List<SearchResult>> results);
  }
}



================================================
File: java/com/itsaky/androidide/utils/ShiftedLongArray.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

/**
 * Represents an [Long] array whose indices are shifted by a specified number of positions. This class
 * provides methods to access and modify elements in the array based on the shifted indices. The
 * array is not cyclic; attempting to access indices outside the array bounds will result in an
 * [IndexOutOfBoundsException].
 *
 * Shift values are wrapped around. Therefore, a shift value of `array.size` effectively means no
 * shift (`size % size => 0`). Also, when the array is shifted by a negative value, then the indexing
 * starts from the end of the array (`array.size - 1`).
 *
 * @property size The number of elements in the array.
 * @property shift The number of positions to shift the indices of the array. A negative value
 * represents a left shift.
 * @property normalizedShift The normalized shift value.
 * @author Akash Yadav
 */
open class ShiftedLongArray(
  protected val array: LongArray,
  shift: Int = 0
) : Collection<Long> {

  override val size: Int
    get() = array.size

  var shift: Int = shift
    protected set

  val normalizedShift: Int
    get() = ((shift % size) + size) % size

  @Suppress("NOTHING_TO_INLINE")
  protected inline fun checkIdx(idx: Int) {
    if (idx < 0 || idx >= array.size) {
      throw IndexOutOfBoundsException("Index $idx is out of bounds for array of size ${array.size}")
    }
  }

  /**
   * Get the corresponding shifted-index for the given index.
   */
  open fun getShiftedIndex(index: Int): Int {
    val size = this.size
    val idx = if (shift < 0) {
      size - index
    } else index
    return (idx + normalizedShift) % size
  }

  /**
   * Returns whether the contents of this array are equal to the specified array.
   */
  fun contentEquals(array: ShiftedLongArray): Boolean {
    return contentEquals(array.array)
  }

  /**
   * Returns whether the contents of this array are equal to the specified array.
   */
  fun contentEquals(array: LongArray): Boolean {
    return this.array.contentEquals(array)
  }

  /**
   * Returns the hash code value for the contents of this array.
   */
  fun contentHashCode(): Int {
    return array.contentHashCode()
  }

  operator fun get(index: Int): Long {
    checkIdx(index)
    return array[getShiftedIndex(index)]
  }

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is ShiftedLongArray) return false

    if (!array.contentEquals(other.array)) return false
    if (shift != other.shift) return false

    return true
  }

  override fun hashCode(): Int {
    var result = array.contentHashCode()
    result = 31 * result + shift
    return result
  }

  override fun isEmpty(): Boolean {
    return array.isEmpty()
  }

  override fun containsAll(elements: Collection<Long>): Boolean {
    return elements.all { array.contains(it) }
  }

  override fun contains(element: Long): Boolean {
    return array.contains(element)
  }

  override fun iterator(): Iterator<Long> {
    return object : Iterator<Long> {
      var index = 0

      override fun hasNext(): Boolean {
        return index < array.size
      }

      override fun next(): Long {
        if (!hasNext()) {
          throw NoSuchElementException()
        } else {
          return this@ShiftedLongArray[index++]
        }
      }
    }
  }

  override fun toString(): String {
    return "ShiftedLongArray(array=${array.contentToString()}, shift=$shift)"
  }
}


================================================
File: java/com/itsaky/androidide/utils/SingleBottomSheetCallback.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.view.View
import com.google.android.material.bottomsheet.BottomSheetBehavior.BottomSheetCallback

/**
 * A [BottomSheetCallback] which allows you to override any single method.
 *
 * @author Akash Yadav
 */
open class SingleBottomSheetCallback : BottomSheetCallback() {
  override fun onStateChanged(bottomSheet: View, newState: Int) {}
  override fun onSlide(bottomSheet: View, slideOffset: Float) {}
}



================================================
File: java/com/itsaky/androidide/utils/Symbols.kt
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package com.itsaky.androidide.utils

import com.itsaky.androidide.models.Symbol
import java.io.File

object Symbols {

  @JvmStatic
  fun forFile(file: File?): List<Symbol> {
    if (file == null || !file.isFile) {
      return emptyList()
    }

    return when (file.extension) {
      "java",
      "gradle",
      "kt",
      "kts" -> javaSymbols

      "xml" -> xmlSymbols
      else -> plainTextSymbols
    }
  }

  private val javaSymbols by lazy {
    listOf(
      TabSymbol(),
      Symbol("{", "{}"),
      Symbol("}"),
      Symbol("(", "()"),
      Symbol(")"),
      Symbol(";"),
      Symbol("="),
      Symbol("\"", "\"\""),
      Symbol("|"),
      Symbol("&"),
      Symbol("!"),
      Symbol("[", "[]"),
      Symbol("]"),
      Symbol("<", "<>"),
      Symbol(">"),
      Symbol("+"),
      Symbol("-"),
      Symbol("/"),
      Symbol("*"),
      Symbol("?"),
      Symbol(":"),
      Symbol("_")
    )
  }

  private val xmlSymbols by lazy {
    listOf(
      TabSymbol(),
      Symbol("<", "<>"),
      Symbol(">"),
      Symbol("/"),
      Symbol("="),
      Symbol("\"", "\"\""),
      Symbol(":"),
      Symbol("@"),
      Symbol("+"),
      Symbol("(", "()"),
      Symbol(")"),
      Symbol(";"),
      Symbol(","),
      Symbol("."),
      Symbol("?"),
      Symbol("|"),
      Symbol("\\"),
      Symbol("&"),
      Symbol("[", "[]"),
      Symbol("]"),
      Symbol("{", "{}"),
      Symbol("}"),
      Symbol("_"),
      Symbol("-")
    )
  }

  val plainTextSymbols by lazy {
    listOf(
      TabSymbol(),
      Symbol("{", "{}", 1, "Braces (Opening)"),
      Symbol("}", "}", 1, "Braces (Closing)"),
      Symbol("(", "()", 1, "Parenthesis (Opening)"),
      Symbol(")", ")", 1, "Parenthesis (Closing)"),
      Symbol("=", "=", 1, "Equals sign"),
      Symbol("\"", "\"\"", 1, "Double quotes"),
      Symbol("'", "''", 1, "Single quote"),
      Symbol("|", "|", 1, "Pipe"),
      Symbol("&", "&", 1, "Ampersand"),
      Symbol("!", "!", 1, "Exclamation mark"),
      Symbol("[", "[]", 1, "Brackets (Opening)"),
      Symbol("]", "]", 1, "Brackets (Closing)"),
      Symbol("<", "<>", 1, "Angle Bracket (Opening)"),
      Symbol(">", ">", 1, "Angle Bracket (Closing)"),
      Symbol("+", "+", 1, "Plus sign"),
      Symbol("-", "-", 1, "Minus sign"),
      Symbol("/", "/", 1, "Slash"),
      Symbol("~", "~", 1, "Tilde"),
      Symbol("`", "`", 1, "Backtick"),
      Symbol(":", ":", 1, "Colon"),
      Symbol("_", "_", 1, "Underscore")
    )
  }

  private class TabSymbol : Symbol("↹") {

    override val commit: String
      get() = "\t"

    override val offset: Int
      get() = 1
  }
}



================================================
File: java/com/itsaky/androidide/utils/TemplateRecipeExecutor.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import org.adfa.constants.LOCAL_MAVEN_CACHES_DEST
import org.adfa.constants.LOCAL_MAVEN_REPO_ARCHIVE_ZIP_NAME
import com.blankj.utilcode.util.ResourceUtils
import com.blankj.utilcode.util.ZipUtils
import com.itsaky.androidide.app.IDEApplication
import com.itsaky.androidide.managers.ToolsManager
import com.itsaky.androidide.templates.RecipeExecutor
import java.io.File
import java.io.IOException
import java.io.InputStream

/**
 * [RecipeExecutor] implementation used for creating projects.
 *
 * @author Akash Yadav
 */
class TemplateRecipeExecutor : RecipeExecutor {

    private val application: IDEApplication
        get() = IDEApplication.instance

    override fun copy(source: File, dest: File) {
        source.copyTo(dest)
    }

    override fun save(source: String, dest: File) {
        dest.parentFile?.mkdirs()
        dest.writeText(source)
    }

    override fun openAsset(path: String): InputStream {
        try {
            return application.assets.open(path)
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    override fun copyAsset(path: String, dest: File) {
        openAsset(path).use {
            it.copyTo(dest.outputStream())
        }
    }

    override fun copyAssetsRecursively(path: String, destDir: File) {
        ResourceUtils.copyFileFromAssets(path, destDir.absolutePath)
    }
}


================================================
File: java/com/itsaky/androidide/utils/TerminalInstaller.kt
================================================
/*
 * Copyright (C) 2025 Akash Yadav
 *
 * Scribe is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Scribe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Scribe.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.content.Context
import android.system.Os
import android.system.OsConstants
import com.itsaky.androidide.resources.R
import com.termux.app.TermuxInstaller
import com.termux.shared.android.PackageUtils
import com.termux.shared.errors.Error
import com.termux.shared.file.FileUtils
import com.termux.shared.logger.Logger
import com.termux.shared.markdown.MarkdownUtils
import com.termux.shared.shell.command.ExecutionCommand
import com.termux.shared.shell.command.ExecutionCommand.Runner
import com.termux.shared.shell.command.runner.app.AppShell
import com.termux.shared.termux.TermuxConstants
import com.termux.shared.termux.TermuxConstants.TERMUX_PREFIX_DIR_PATH
import com.termux.shared.termux.file.TermuxFileUtils
import com.termux.shared.termux.shell.command.environment.TermuxShellEnvironment
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.apache.commons.compress.archivers.zip.ZipFile
import org.apache.commons.compress.utils.SeekableInMemoryByteChannel
import org.slf4j.LoggerFactory
import java.io.BufferedReader
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream
import java.io.InputStreamReader
import java.nio.channels.SeekableByteChannel


/**
 * Install the Termux bootstrap packages if necessary by following the below steps:
 * 1. If $PREFIX already exist, assume that it is correct and be done. Note that this relies on that we do not create a
 *    broken $PREFIX directory below.
 * 2. A progress dialog is shown with "Installing..." message and a spinner.
 * 3. A staging directory, $STAGING_PREFIX, is cleared if left over from broken installation below.
 * 4. The zip file is loaded from a shared library.
 * 5. The zip, containing entries relative to the $PREFIX, is is downloaded and extracted by a zip input stream
 *    continuously encountering zip file entries:
 *    - If the zip entry encountered is SYMLINKS.txt, go through it and remember all symlinks to setup.
 *    - For every other zip entry, extract it into $STAGING_PREFIX and set execute permissions if necessary.
 *
 * @author Akash Yadav
 * @see <a href="https://gitlab.com/scribe-oss/core/Scribe/-/blob/main/core/resources/src/main/res/values/terminal.xml">ScribeTerminalInstaller.kt</a>
 */
object TerminalInstaller {
    private val logger = LoggerFactory.getLogger(TerminalInstaller::class.java)

    private val executableDirs = arrayOf(
        "bin/",
        "libexec",
        "lib/apt/apt-helper",
        "lib/apt/methods",
    )

    private val executableFiles = arrayOf(
        "etc/termux/termux-bootstrap/second-stage/termux-bootstrap-second-stage.sh",
    )

    /**
     * The result of the install operation.
     */
    sealed interface InstallResult {
        /**
         * The install was successful.
         */
        data object Success : InstallResult

        /**
         * The installation was not performed, possibility due to a 'dry run' flag.
         */
        data object NotInstalled : InstallResult

        /**
         * The install was not successful.
         */
        sealed interface Error : InstallResult {
            /**
             * The install was not successful because the user is not the primary user.
             */
            data object IsSecondaryUser : Error

            /**
             * The generic error which is shown to the user.
             */
            data class Interactive(
                val title: String,
                val message: String,
            ) : InstallResult
        }
    }

    sealed interface ProgressType {
        data object Preparing : ProgressType

        data class Unzipping(
            val entry: String,
        ) : ProgressType

        data class Linking(
            val source: String,
            val destination: String,
        ) : ProgressType
    }

    /**
     * Install the terminal bootstrap packages if necessary.
     *
     * @param context The application context.
     * @return The installation result.
     */
    suspend fun installIfNeeded(
        context: Context,
        byteChannel: SeekableByteChannel,
        dryRun: Boolean = false,
        onProgress: (ProgressType) -> Unit = {},
    ): InstallResult = withContext(Dispatchers.IO) {
        onProgress(ProgressType.Preparing)

        val filesDirAccessibleErr = TermuxFileUtils.isTermuxFilesDirectoryAccessible(
            // context =
            context,
            // createDirectoryIfMissing =
            true,
            // setMissingPermissions =
            true,
        )

        val isFilesDirAccessible = filesDirAccessibleErr == null

        if (!PackageUtils.isCurrentUserThePrimaryUser(context)) {
            val errorMessage = context.getString(
                R.string.bootstrap_error_not_primary_user_message,
                MarkdownUtils.getMarkdownCodeForString(
                    TermuxConstants.TERMUX_PREFIX_DIR_PATH,
                    false,
                ),
            )

            logger.error("isFilesDirAccessible: $isFilesDirAccessible")
            logger.error(errorMessage)
            return@withContext InstallResult.Error.IsSecondaryUser
        }

        if (!isFilesDirAccessible) {
            var errorMessage = Error.getMinimalErrorString(filesDirAccessibleErr)

            // noinspection SdCardPath
            if (PackageUtils.isAppInstalledOnExternalStorage(context) && TermuxConstants.TERMUX_FILES_DIR_PATH != context.filesDir.absolutePath.replace(
                    "^/data/user/0".toRegex(),
                    "/data/data/",
                )
            ) {
                errorMessage += "\n\n" + context.getString(
                    R.string.bootstrap_error_installed_on_portable_sd,
                    MarkdownUtils.getMarkdownCodeForString(
                        TermuxConstants.TERMUX_PREFIX_DIR_PATH,
                        false,
                    ),
                )
            }

            logger.error(errorMessage)
            return@withContext InstallResult.Error.Interactive(
                title = context.getString(R.string.bootstrap_error_title),
                message = errorMessage,
            )
        }

        if (FileUtils.directoryFileExists(TermuxConstants.TERMUX_PREFIX_DIR_PATH, true)) {
            if (TermuxFileUtils.isTermuxPrefixDirectoryEmpty()) {
                logger.info(
                    "The termux prefix directory {} exists but is empty or only contains specific unimportant files.",
                    TermuxConstants.TERMUX_PREFIX_DIR_PATH,
                )
            } /*else {
                    return@withContext InstallResult.Success
                }*/
        } else if (FileUtils.fileExists(TermuxConstants.TERMUX_PREFIX_DIR_PATH, false)) {
            logger.info(
                "The termux prefix directory {} does not exist but another file exists at its destination.",
                TermuxConstants.TERMUX_PREFIX_DIR_PATH,
            )
        }

        if (dryRun) {
            // halt actual installation
            return@withContext InstallResult.NotInstalled
        }

        logger.info("Installing {} bootstrap packages.", TermuxConstants.TERMUX_APP_NAME)

        var error = FileUtils.createDirectoryFile(TermuxConstants.TERMUX_HOME_DIR_PATH)
        if (error != null) {
            return@withContext InstallResult.Error.Interactive(
                title = context.getString(R.string.bootstrap_error_title),
                message = Error.getErrorMarkdownString(error),
            )
        }

        error = FileUtils.deleteFile(
            "termux prefix staging directory",
            TermuxConstants.TERMUX_STAGING_PREFIX_DIR_PATH,
            true,
        )
        if (error != null) {
            return@withContext InstallResult.Error.Interactive(
                title = context.getString(R.string.bootstrap_error_title),
                message = Error.getErrorMarkdownString(error),
            )
        }

        error = FileUtils.deleteFile(
            "termux prefix directory",
            TermuxConstants.TERMUX_PREFIX_DIR_PATH,
            true,
        )
        if (error != null) {
            return@withContext InstallResult.Error.Interactive(
                title = context.getString(R.string.bootstrap_error_title),
                message = Error.getErrorMarkdownString(error),
            )
        }

        error = TermuxFileUtils.isTermuxPrefixStagingDirectoryAccessible(true, true)
        if (error != null) {
            return@withContext InstallResult.Error.Interactive(
                title = context.getString(R.string.bootstrap_error_title),
                message = Error.getErrorMarkdownString(error),
            )
        }

        error = TermuxFileUtils.isTermuxPrefixDirectoryAccessible(true, true)
        if (error != null) {
            return@withContext InstallResult.Error.Interactive(
                title = context.getString(R.string.bootstrap_error_title),
                message = Error.getErrorMarkdownString(error),
            )
        }

        logger.info(
            "Extracting bootstrap zip to prefix staging directory {}.",
            TermuxConstants.TERMUX_STAGING_PREFIX_DIR_PATH,
        )

        return@withContext doInstall(context, byteChannel, onProgress)
    }

    private fun doInstall(
        context: Context,
        byteChannel: SeekableByteChannel,
        onProgress: (ProgressType) -> Unit
    ): InstallResult {
        var error: Error?
        val buffer = ByteArray(DEFAULT_BUFFER_SIZE)
        val symlinks = mutableListOf<Pair<String, String>>()

        ZipFile.builder()
            .setSeekableByteChannel(byteChannel)
            .get().use { zipFile ->
                zipFile.entries.asSequence().forEach { entry ->
                    val entryStream = zipFile.getInputStream(entry)
                    if (entry.name == "SYMLINKS.txt") {
                        val symlinksReader = BufferedReader(InputStreamReader(entryStream))
                        var line: String?
                        while ((symlinksReader.readLine().also { line = it }) != null) {
                            val parts = line!!.split("←".toRegex())
                                .dropLastWhile { segment -> segment.isEmpty() }.toTypedArray()

                            if (parts.size != 2) {
                                throw RuntimeException("Malformed symlink line: $line")
                            }

                            val oldPath = parts[0]
                            val newPath = buildString {
                                append(TermuxConstants.TERMUX_STAGING_PREFIX_DIR_PATH)
                                append("/")
                                append(parts[1])
                            }

                            symlinks.add(oldPath to newPath)

                            error = ensureDirectoryExists(File(newPath).parentFile!!)
                            if (error != null) {
                                return@use InstallResult.Error.Interactive(
                                    title = context.getString(R.string.bootstrap_error_title),
                                    message = Error.getErrorMarkdownString(error),
                                )
                            }
                        }
                    } else {
                        val zipEntryName = entry.name
                        onProgress(ProgressType.Unzipping(zipEntryName))

                        val targetFile =
                            File(TermuxConstants.TERMUX_STAGING_PREFIX_DIR_PATH, zipEntryName)
                        val isDirectory = entry.isDirectory

                        error =
                            ensureDirectoryExists(if (isDirectory) targetFile else targetFile.parentFile)
                        if (error != null) {
                            return InstallResult.Error.Interactive(
                                title = context.getString(R.string.bootstrap_error_title),
                                message = Error.getErrorMarkdownString(error),
                            )
                        }

                        if (!isDirectory) {
                            FileOutputStream(targetFile).use { outStream ->
                                var readBytes: Int
                                while ((entryStream.read(buffer)
                                        .also { len -> readBytes = len }) != -1
                                ) {
                                    outStream.write(buffer, 0, readBytes)
                                }
                            }

                            if (executableDirs.any { dir -> zipEntryName.startsWith(dir) }
                                || executableFiles.any { file -> file == zipEntryName }) {
                                Os.chmod(targetFile.absolutePath, OsConstants.S_IRWXU)
                            } else {
                                Os.chmod(targetFile.absolutePath, entry.unixMode)
                            }
                        }
                    }
                }
            }

        if (symlinks.isEmpty()) {
            throw java.lang.RuntimeException("No SYMLINKS.txt encountered")
        }

        for ((first, second) in symlinks) {
            onProgress(ProgressType.Linking(first, second))
            Os.symlink(first, second)
        }

        logger.info("Moving termux prefix staging to prefix directory.")

        if (!TermuxConstants.TERMUX_STAGING_PREFIX_DIR.renameTo(TermuxConstants.TERMUX_PREFIX_DIR)) {
            throw RuntimeException("Moving termux prefix staging to prefix directory failed")
        }

        // Run Termux bootstrap second stage.
        val termuxBootstrapSecondStageFile =
            "$TERMUX_PREFIX_DIR_PATH/etc/termux/termux-bootstrap/second-stage/termux-bootstrap-second-stage.sh"
        if (!FileUtils.fileExists(termuxBootstrapSecondStageFile, false)) {
            logger.info(
                "Not running Termux bootstrap second stage since script not found at \"{}\" path.",
                termuxBootstrapSecondStageFile
            )
        } else {
            if (!FileUtils.fileExists(TermuxConstants.TERMUX_BIN_PREFIX_DIR_PATH + "/bash", true)) {
                logger.info(
                    "Not running Termux bootstrap second stage since bash not found."
                )
            }

            logger.info("Running Termux bootstrap second stage.")

            val executionCommand = ExecutionCommand(
                -1,
                termuxBootstrapSecondStageFile,
                null,
                null,
                null,
                Runner.APP_SHELL.runnerName,
                false
            )

            executionCommand.commandLabel = "Termux Bootstrap Second Stage Command"
            executionCommand.backgroundCustomLogLevel = Logger.LOG_LEVEL_NORMAL

            val shell = AppShell.execute(
                context, executionCommand, null, TermuxShellEnvironment(), hashMapOf(), true
            )

            if (shell == null || !executionCommand.isSuccessful || executionCommand.resultData.exitCode != 0) {

                // Delete prefix directory as otherwise when app is restarted, the broken prefix directory would be used and logged into.
                error =
                    FileUtils.deleteFile("termux prefix directory", TERMUX_PREFIX_DIR_PATH, true)
                logger.error("Failed to run Termux second-stage command: {}", executionCommand)
                logger.error("Failed to run Termux second-stage command: {}", error)
                return InstallResult.Error.Interactive(
                    title = context.getString(R.string.bootstrap_error_title),
                    message = Error.getErrorMarkdownString(error),
                )
            }
        }


        logger.info("Bootstrap packages installed successfully.")

        // Recreate env file since termux prefix was wiped earlier
        TermuxShellEnvironment.writeEnvironmentToFile(context)

        return InstallResult.Success
    }

    private fun ensureDirectoryExists(directory: File): Error? =
        FileUtils.createDirectoryFile(directory.absolutePath)
}



================================================
File: java/com/itsaky/androidide/utils/TextWatcherAdapter.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils;

import android.text.Editable;
import android.text.TextWatcher;
import androidx.annotation.NonNull;

/**
 * @author Akash Yadav
 */
public class TextWatcherAdapter implements TextWatcher {

  @Override
  public void beforeTextChanged(@NonNull CharSequence s, int start, int count, int after) {}

  @Override
  public void onTextChanged(@NonNull CharSequence s, int start, int before, int count) {}

  @Override
  public void afterTextChanged(@NonNull Editable s) {}
}



================================================
File: java/com/itsaky/androidide/utils/TooltipUtils.kt
================================================
/*
 * This file is part of AndroidIDE.
 *
 * AndroidIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AndroidIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.utils

import android.content.Context
import android.content.Intent
import android.database.sqlite.SQLiteDatabase
import android.os.Bundle
import android.util.Log
import android.view.View
import com.itsaky.androidide.utils.Environment
import androidx.fragment.app.FragmentTransaction
import com.itsaky.androidide.R
import com.itsaky.androidide.activities.MainActivity
import com.itsaky.androidide.activities.editor.HelpActivity
import com.itsaky.androidide.fragments.IDETooltipWebviewFragment
import com.itsaky.androidide.fragments.MainFragment

import com.itsaky.androidide.idetooltips.IDETooltipItem

import com.itsaky.androidide.idetooltips.TooltipManager
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.adfa.constants.CONTENT_KEY
import org.adfa.constants.CONTENT_TITLE_KEY

object TooltipUtils {
    private val mainActivity: MainActivity?
        get() = MainActivity.getInstance()

    /**
     * This displays a webpage as the 3rd level tooltip
     *
     * @param   context callers context
     * @param   url    the url as specified in the tooltips database
     * @return  none
     */
    fun showWebPage(context: Context, url: String) {
        val currentActivity = mainActivity ?: return
        val transaction: FragmentTransaction =
            currentActivity.supportFragmentManager.beginTransaction().addToBackStack("WebView")
        val fragment = IDETooltipWebviewFragment()
        val bundle = Bundle()
        bundle.putString(MainFragment.KEY_TOOLTIP_URL, url)
        fragment.arguments = bundle
        transaction.replace(R.id.fragment_containers_parent, fragment)
        transaction.show(fragment)
        transaction.commitAllowingStateLoss()
    }

    /**
     * Shows a tooltip anchored to a generic view.
     */
    fun showIDETooltip(
        context: Context,
        anchorView: View,
        level: Int,
        tooltipItem: IDETooltipItem
    ) {
        TooltipManager.showIDETooltip(context, anchorView, level, tooltipItem) { ctx, url, title ->
            val intent = Intent(ctx, HelpActivity::class.java).apply {
                putExtra(CONTENT_KEY, url)
                putExtra(CONTENT_TITLE_KEY, title)
            }
            ctx.startActivity(intent)
        }
    }


    /**
     * Dumps tooltip database content to Logcat for debugging.
     */
    suspend fun dumpDatabase(context: Context) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val dbPath = Environment.DOC_DB.absolutePath
                val db = SQLiteDatabase.openDatabase(dbPath, null, SQLiteDatabase.OPEN_READONLY)
                
                val query = "SELECT COUNT(*) as count FROM ide_tooltip_table"
                val cursor = db.rawQuery(query, null)
                
                if (cursor.moveToFirst()) {
                    val count = cursor.getInt(cursor.getColumnIndexOrThrow("count"))
                    cursor.close()
                    db.close()
                    
                    withContext(Dispatchers.Main) {
                        if (count == 0) {
                            Log.d("DumpIDEDatabase", "No records found in ide_tooltip_table.")
                        } else {
                            Log.d("DumpIDEDatabase", "Found $count records in ide_tooltip_table.")
                        }
                    }
                } else {
                    cursor.close()
                    db.close()
                    withContext(Dispatchers.Main) {
                        Log.d("DumpIDEDatabase", "No records found in ide_tooltip_table.")
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Log.e("DumpIDEDatabase", "Error accessing tooltip database: ${e.message}")
                }
            }
        }
    }
}


================================================
File: java/com/itsaky/androidide/utils/ZipExts.kt
================================================
package com.itsaky.androidide.utils

import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream

inline fun ZipInputStream.forEach(crossinline action: (ZipEntry) -> Unit) {
    var entry: ZipEntry?
    while (nextEntry.also { entry = it } != null) {
        action(entry!!)
    }
}

inline fun ZipInputStream.useEntriesEach(crossinline action: (ZipInputStream, ZipEntry) -> Unit) = use {
    forEach { entry ->
        action(this, entry)
    }
}



================================================
File: java/com/itsaky/androidide/viewmodel/BuildVariantsViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.viewmodel

import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import com.itsaky.androidide.tooling.api.models.BuildVariantInfo

/**
 * [ViewModel] for the build variants fragment.
 *
 * @author Akash Yadav
 */
class BuildVariantsViewModel : ViewModel() {

  internal val _buildVariants = MutableLiveData<Map<String, BuildVariantInfo>>(null)
  internal val _updatedBuildVariants = MutableLiveData<MutableMap<String, BuildVariantInfo>>(null)

  var buildVariants: Map<String, BuildVariantInfo>
    get() = this._buildVariants.value ?: emptyMap()
    set(value) {
      this._buildVariants.value = value
    }

  var updatedBuildVariants: MutableMap<String, BuildVariantInfo>
    get() = this._updatedBuildVariants.value ?: mutableMapOf()
    set(value) {
      this._updatedBuildVariants.value = value
    }

  /**
   * Resets the updated selections.
   */
  internal fun resetUpdatedSelections() {
    updatedBuildVariants = updatedBuildVariants.also { it.clear() }
  }
}


================================================
File: java/com/itsaky/androidide/viewmodel/ContributorsViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.viewmodel

import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.itsaky.androidide.contributors.Contributor
import com.itsaky.androidide.contributors.CrowdinTranslator
import com.itsaky.androidide.contributors.CrowdinTranslators
import com.itsaky.androidide.contributors.GitHubContributor
import com.itsaky.androidide.contributors.GitHubContributors
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * @author Akash Yadav
 */
class ContributorsViewModel : ViewModel() {

  internal val _crowdinTranslators = MutableLiveData(emptyList<CrowdinTranslator>())
  internal val _githubContributors = MutableLiveData(emptyList<GitHubContributor>())

  private val _crowdinTranslatorsLoading = MutableLiveData(false)
  private val _githubContributorsLoading = MutableLiveData(false)

  val isLoading: Boolean
    get() = _githubContributorsLoading.value!! || _crowdinTranslatorsLoading.value!!

  companion object {

    private const val CONTRIBUTORS_MAX_SIZE = 30
  }

  fun observeLoadingState(owner: LifecycleOwner, observer: Observer<Boolean>) {
    _crowdinTranslatorsLoading.observe(owner) {
      observer.onChanged(isLoading)
    }
    _githubContributorsLoading.observe(owner) {
      observer.onChanged(isLoading)
    }
  }

  fun fetchCrowdinTranslators() {
    _crowdinTranslatorsLoading.value = true
    viewModelScope.launch(Dispatchers.Default) {
      val translators = CrowdinTranslators.getAllTranslators()
      withContext(Dispatchers.Main) {
        _crowdinTranslators.value = translators.trimToMaxSize()
        _crowdinTranslatorsLoading.value = false
      }
    }
  }

  fun fetchGitHubTranslators() {
    _githubContributorsLoading.value = true
    viewModelScope.launch(Dispatchers.Default) {
      val contributors = GitHubContributors.getAllContributors()
      withContext(Dispatchers.Main) {
        _githubContributors.value = contributors.trimToMaxSize()
        _githubContributorsLoading.value = false
      }
    }
  }

  fun fetchAll() {
    fetchCrowdinTranslators()
    fetchGitHubTranslators()
  }

  private fun <T : Contributor> List<T>.trimToMaxSize(): List<T> {
    return if (size > CONTRIBUTORS_MAX_SIZE) {
      subList(0, CONTRIBUTORS_MAX_SIZE)
    } else {
      this
    }
  }
}


================================================
File: java/com/itsaky/androidide/viewmodel/DebuggerViewModel.kt
================================================
package com.itsaky.androidide.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.itsaky.androidide.fragments.debug.ResolvableStackFrame
import com.itsaky.androidide.fragments.debug.ResolvableThreadInfo
import com.itsaky.androidide.fragments.debug.ResolvableVariable
import com.itsaky.androidide.fragments.debug.VariableTreeNodeGenerator
import com.itsaky.androidide.fragments.debug.resolvedOrNull
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.lsp.IDEDebugClientImpl
import com.itsaky.androidide.lsp.debug.model.StackFrame
import com.itsaky.androidide.lsp.debug.model.ThreadInfo
import io.github.dingyi222666.view.treeview.Tree
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory

private data class DebuggerState(
    val threads: List<ResolvableThreadInfo>,
    val threadIndex: Int,
    val frameIndex: Int,
    val variablesTree: Tree<ResolvableVariable<*>>
) {
    val selectedThread: ResolvableThreadInfo?
        get() = threads.getOrNull(threadIndex)

    suspend fun selectedFrame() = selectedThread?.getFrames()?.getOrNull(frameIndex)

    companion object {
        val DEFAULT = DebuggerState(
            threads = emptyList(),
            threadIndex = -1,
            frameIndex = -1,
            variablesTree = Tree.createTree(
                VariableTreeNodeGenerator.newInstance(emptySet())
            ),
        )
    }
}


enum class DebuggerConnectionState {
    // order of the enum constants matter

    /**
     * Not connected to any remote client.
     */
    DETACHED,

    /**
     * Connected to a remote client, but not yet suspended.
     */
    ATTACHED,

    /**
     * Connected to a remote client and suspended, but not due to a breakpoint hit or step.
     */
    SUSPENDED,

    /**
     * Connected to a remote client and suspended due to a breakpoint hit or step.
     */
    AWAITING_BREAKPOINT,
}

/**
 * @author Akash Yadav
 */
class DebuggerViewModel : ViewModel() {

    private val _connectionState = MutableStateFlow(DebuggerConnectionState.DETACHED)
    private val _debugeePackage = MutableStateFlow("")
    private val state = MutableStateFlow(DebuggerState.DEFAULT)
    internal val debugClient = IDEDebugClientImpl(this)

    init {
        Lookup.getDefault().register(IDEDebugClientImpl::class.java, debugClient)
    }

    companion object {
        private val logger = LoggerFactory.getLogger(DebuggerViewModel::class.java)
    }

    val connectionState: StateFlow<DebuggerConnectionState>
        get() = _connectionState.asStateFlow()

    val debugeePackageFlow: StateFlow<String>
        get() = _debugeePackage.asStateFlow()

    var debugeePackage: String
        get() = _debugeePackage.value
        set(value) {
            _debugeePackage.update { value }
        }

    val allThreads: StateFlow<List<ResolvableThreadInfo>>
        get() = state.map { it.threads }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.Eagerly,
            initialValue = emptyList()
        )

    val selectedThread: StateFlow<Pair<ResolvableThreadInfo?, Int>>
        get() = state.map { state ->
            state.selectedThread to state.threadIndex
        }.stateIn(
            scope = viewModelScope, started = SharingStarted.Eagerly, initialValue = null to -1
        )

    val allFrames: StateFlow<List<ResolvableStackFrame>>
        get() = selectedThread.map { (thread, _) ->
            thread?.getFrames() ?: emptyList()
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.Eagerly,
            initialValue = emptyList()
        )

    val selectedFrame: StateFlow<Pair<ResolvableStackFrame?, Int>>
        get() = state.map { state ->
            state.selectedFrame() to state.frameIndex
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.Eagerly,
            initialValue = null to -1
        )

    val selectedFrameVariables: StateFlow<List<ResolvableVariable<*>>>
        get() = selectedFrame.map { (frame, _) ->
            frame?.getVariables() ?: emptyList()
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.Eagerly,
            initialValue = emptyList()
        )

    val variablesTree: StateFlow<Tree<ResolvableVariable<*>>>
        get() = state.map { state ->
            state.variablesTree
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.Eagerly,
            initialValue = DebuggerState.DEFAULT.variablesTree
        )

    override fun onCleared() {
        super.onCleared()
        Lookup.getDefault().unregister(IDEDebugClientImpl::class.java)
    }

    fun setConnectionState(state: DebuggerConnectionState) {
        _connectionState.update { state }
    }

    @OptIn(ExperimentalStdlibApi::class)
    fun observeConnectionState(
        observeOn: CoroutineDispatcher = Dispatchers.Default,
        notifyOn: CoroutineDispatcher? = null,
        consume: suspend (DebuggerConnectionState) -> Unit
    ) = viewModelScope.launch(observeOn) {
        connectionState.collectLatest { state ->
            if (notifyOn != null && notifyOn != coroutineContext[CoroutineDispatcher]) {
                withContext(notifyOn) {
                    consume(state)
                }
            } else {
                consume(state)
            }
        }
    }

    suspend fun setThreads(threads: List<ThreadInfo>) = withContext(Dispatchers.IO) {
        val resolvableThreads = threads.map(ResolvableThreadInfo::create)
            .filter { thread ->
                val descriptor = thread.resolve()
                if (descriptor == null) {
                    logger.warn("Unable to resolve descriptor for thread: $thread")
                    return@filter false
                }

                descriptor.state.isInteractable
            }

        val threadIndex = resolvableThreads.indexOfFirst { it.resolvedOrNull?.state?.isInteractable == true }
        val frameIndex = if (resolvableThreads.getOrNull(threadIndex)?.getFrames()?.firstOrNull() != null) 0 else -1
        val newState = DebuggerState(
            threads = resolvableThreads,
            threadIndex = threadIndex,
            frameIndex = frameIndex,
            variablesTree = createVariablesTree(
                threads = resolvableThreads,
                threadIndex = threadIndex,
                frameIndex = frameIndex,
                resolve = false
            )
        )

        state.update { newState }
    }

    fun refreshState() {
        viewModelScope.launch {
            debugClient.updateThreadInfo(
                debugClient.requireClient,
            )
        }
    }

    private suspend fun createVariablesTree(
        threads: List<ResolvableThreadInfo>,
        threadIndex: Int,
        frameIndex: Int,
        resolve: Boolean = true,
    ): Tree<ResolvableVariable<*>> = coroutineScope {

        if (resolve) {
            // resolve the data we need to render the UI
            threads.forEach { thread ->
                thread.resolve()
            }
        }

        val roots =
            threads.getOrNull(threadIndex)
                ?.getFrames()
                ?.getOrNull(frameIndex)
                ?.getVariables()

        Tree.createTree(VariableTreeNodeGenerator.newInstance(roots?.toSet() ?: emptySet()))
    }

    @OptIn(ExperimentalStdlibApi::class)
    fun observeLatestThreads(
        observeOn: CoroutineDispatcher = Dispatchers.Default,
        notifyOn: CoroutineDispatcher? = null,
        consume: suspend (List<ResolvableThreadInfo>) -> Unit
    ) = viewModelScope.launch(observeOn) {
        allThreads.collectLatest { threads ->
            if (notifyOn != null && notifyOn != coroutineContext[CoroutineDispatcher]) {
                withContext(notifyOn) {
                    consume(threads)
                }
            } else {
                consume(threads)
            }
        }
    }

    suspend fun setSelectedThreadIndex(index: Int) = withContext(Dispatchers.IO) {
        state.update { current ->
            check(index in 0..<current.threads.size) {
                "Invalid thread index: $index"
            }

            val thread = current.threads[index]
            if (thread.resolvedOrNull?.state?.isInteractable != true) {
                // thread is non-interactive
                // do not change the thread index
                logger.warn("Attempt to interact with non-interactive thread: $thread")
                return@update current
            }

            val frameIndex = if (current.threads.getOrNull(index)?.getFrames()
                    ?.firstOrNull() != null
            ) 0 else -1
            current.copy(
                threadIndex = index,
                frameIndex = frameIndex,
                variablesTree = createVariablesTree(current.threads, index, frameIndex)
            )
        }
    }

    @OptIn(ExperimentalStdlibApi::class)
    fun observeLatestSelectedThread(
        observeOn: CoroutineDispatcher = Dispatchers.Default,
        notifyOn: CoroutineDispatcher? = null,
        consume: suspend (ResolvableThreadInfo?, Int) -> Unit
    ) = viewModelScope.launch(observeOn) {
        selectedThread.collectLatest { (thread, index) ->
            if (notifyOn != null && notifyOn != coroutineContext[CoroutineDispatcher]) {
                withContext(notifyOn) {
                    consume(thread, index)
                }
            } else {
                consume(thread, index)
            }
        }
    }

    @OptIn(ExperimentalStdlibApi::class)
    fun observeLatestAllFrames(
        observeOn: CoroutineDispatcher = Dispatchers.Default,
        notifyOn: CoroutineDispatcher? = null,
        consume: suspend (List<StackFrame>) -> Unit
    ) = viewModelScope.launch(observeOn) {
        allFrames.collectLatest { frames ->
            if (notifyOn != null && notifyOn != coroutineContext[CoroutineDispatcher]) {
                withContext(notifyOn) {
                    consume(frames)
                }
            } else {
                consume(frames)
            }
        }
    }

    suspend fun setSelectedFrameIndex(index: Int) = withContext(Dispatchers.IO) {
        state.update { current ->
            check(index in 0..<(current.selectedThread?.getFrames()?.size ?: 0)) {
                "Invalid frame index: $index"
            }

            current.copy(
                frameIndex = index,
                variablesTree = createVariablesTree(current.threads, current.threadIndex, index)
            )
        }
    }

    @OptIn(ExperimentalStdlibApi::class)
    fun observeLatestSelectedFrame(
        observeOn: CoroutineDispatcher = Dispatchers.Default,
        notifyOn: CoroutineDispatcher? = null,
        consume: suspend (StackFrame?, Int) -> Unit,
    ) = viewModelScope.launch(observeOn) {
        selectedFrame.collectLatest { (frame, index) ->
            if (notifyOn != null && notifyOn != coroutineContext[CoroutineDispatcher]) {
                withContext(notifyOn) {
                    consume(frame, index)
                }
            } else {
                consume(frame, index)
            }
        }
    }

    @OptIn(ExperimentalStdlibApi::class)
    fun observeLatestVariablesTree(
        observeOn: CoroutineDispatcher = Dispatchers.Default,
        notifyOn: CoroutineDispatcher? = null,
        consume: suspend (Tree<ResolvableVariable<*>>) -> Unit
    ) = viewModelScope.launch(observeOn) {
        variablesTree.collectLatest { tree ->
            if (notifyOn != null && notifyOn != coroutineContext[CoroutineDispatcher]) {
                withContext(notifyOn) {
                    consume(tree)
                }
            } else {
                consume(tree)
            }
        }
    }
}


================================================
File: java/com/itsaky/androidide/viewmodel/EditorViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.viewmodel

import android.view.Gravity.CENTER
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.blankj.utilcode.util.FileUtils
import com.google.gson.GsonBuilder
import com.itsaky.androidide.models.OpenedFilesCache
import com.itsaky.androidide.projects.IProjectManager
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.ILogger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.IOException
import java.util.Collections

/** ViewModel for data used in [com.itsaky.androidide.activities.editor.EditorActivityKt] */
@Suppress("PropertyName")
class EditorViewModel : ViewModel() {

  internal val _isBuildInProgress = MutableLiveData(false)
  internal val _isInitializing = MutableLiveData(false)
  internal val _statusText = MutableLiveData<Pair<CharSequence, Int>>("" to CENTER)
  internal val _displayedFile = MutableLiveData(-1)
  internal val _startDrawerOpened = MutableLiveData(false)
  internal val _isSyncNeeded = MutableLiveData(false)

  internal val _filesModified = MutableLiveData(false)
  internal val _filesSaving = MutableLiveData(false)

  private val _openedFiles = MutableLiveData<OpenedFilesCache>()
  private val _isBoundToBuildService = MutableLiveData(false)
  private val _files = MutableLiveData<MutableList<File>>(ArrayList())

  /**
   * Holds information about the currently selected editor fragment. First value in the pair is the
   * index of the editor opened. Second value is the file that is opened.
   */
  private val mCurrentFile = MutableLiveData<Pair<Int, File?>?>(null)

  var areFilesModified: Boolean
    get() = _filesModified.value ?: false
    set(value) {
      _filesModified.value = value
    }

  var areFilesSaving: Boolean
    get() = _filesSaving.value ?: false
    set(value) {
      _filesSaving.value = value
    }

  var openedFilesCache: OpenedFilesCache?
    get() = _openedFiles.value
    set(value) {
      this._openedFiles.value = value
    }

  var isBoundToBuildSerice: Boolean
    get() = _isBoundToBuildService.value ?: false
    set(value) {
      _isBoundToBuildService.value = value
    }

  var isBuildInProgress: Boolean
    get() = _isBuildInProgress.value ?: false
    set(value) {
      _isBuildInProgress.value = value
    }

  var isInitializing: Boolean
    get() = _isInitializing.value ?: false
    set(value) {
      _isInitializing.value = value
    }

  var statusText: CharSequence
    get() = this._statusText.value?.first ?: ""
    set(value) {
      _statusText.value = value to (_statusText.value?.second ?: 0)
    }

  var statusGravity: Int
    get() = this._statusText.value?.second ?: CENTER
    set(value) {
      _statusText.value = (_statusText.value?.first ?: "") to value
    }

  var displayedFileIndex: Int
    get() = _displayedFile.value!!
    set(value) {
      _displayedFile.value = value
    }

  var startDrawerOpened: Boolean
    get() = _startDrawerOpened.value ?: false
    set(value) {
      _startDrawerOpened.value = value
    }

  var isSyncNeeded: Boolean
    get() = _isSyncNeeded.value ?: false
    set(value) {
      _isSyncNeeded.value = value
    }

  internal var files: MutableList<File>
    get() = this._files.value ?: Collections.emptyList()
    set(value) {
      this._files.value = value
    }

  private inline fun updateFiles(crossinline action: (files: MutableList<File>) -> Unit) {
    val files = this.files
    action(files)
    this.files = files
  }

  /**
   * Add the given file to the list of opened files.
   *
   * @param file The file that has been opened.
   */
  fun addFile(file: File) = updateFiles { files ->
    files.add(file)
  }

  /**
   * Remove the file at the given index from the list of opened files.
   *
   * @param index The index of the closed file.
   */
  fun removeFile(index: Int) = updateFiles { files ->
    files.removeAt(index)

    if (files.isEmpty()) {
      mCurrentFile.value = null
    }
  }

  fun removeAllFiles() = updateFiles { files ->
    files.clear()
    setCurrentFile(-1, null)
  }

  fun setCurrentFile(index: Int, file: File?) {
    displayedFileIndex = index
    mCurrentFile.value = index to file
  }

  fun updateFile(index: Int, newFile: File) = updateFiles { files ->
    files[index] = newFile
  }

  /**
   * Get the opened file at the given index.
   *
   * @param index The index of the file.
   * @return The file at the given index.
   */
  fun getOpenedFile(index: Int): File {
    return files[index]
  }

  /**
   * Get the number of files opened.
   *
   * @return The number of files opened.
   */
  fun getOpenedFileCount(): Int {
    return files.size
  }

  /**
   * Get the list of currently opened files.
   *
   * @return The list of opened files.
   */
  fun getOpenedFiles(): List<File> {
    return Collections.unmodifiableList(files)
  }

  /**
   * Add an observer to the list of opened files.
   *
   * @param lifecycleOwner The lifecycle owner.
   * @param observer The observer.
   */
  fun observeFiles(lifecycleOwner: LifecycleOwner?, observer: Observer<MutableList<File>?>?) {
    _files.observe(lifecycleOwner!!, observer!!)
  }

  fun getCurrentFileIndex(): Int {
    return mCurrentFile.value?.first ?: -1
  }

  fun getCurrentFile(): File? {
    return mCurrentFile.value?.second
  }

  /**
   * Get the [OpenedFilesCache] if it is already loaded, otherwise read the cache from the file system
   * and invoke the given callback.
   *
   * If the cache is already loaded, [result] is called on the same thread. Otherwise, it is
   * always called on the main/UI thread.
   */
  inline fun getOrReadOpenedFilesCache(crossinline result: (OpenedFilesCache?) -> Unit) {
    return openedFilesCache?.let(result) ?: run {
      viewModelScope.launch(Dispatchers.IO) {
        val cache = try {
          val cacheFile = getOpenedFilesCache(false)
          if (cacheFile.exists() && cacheFile.length() > 0L) {
            cacheFile.bufferedReader().use(OpenedFilesCache::parse)
          } else null
        } catch (err: IOException) {
          // ignore exception
          null
        }

        withContext(Dispatchers.Main) {
          result(cache)
        }
      }.also { job ->
        handleOpenedFilesCacheJobCompletion(job, "read")
      }
      Unit
    }
  }

  fun handleOpenedFilesCacheJobCompletion(it: Job, operation: String) {
    it.invokeOnCompletion { err ->
      if (err != null) {
        ILogger.ROOT.error("[EditorViewModel] Failed to {} opened files cache", operation, err)
      }
    }
  }

  fun writeOpenedFiles(cache: OpenedFilesCache?) {
    viewModelScope.launch(Dispatchers.IO) {
      val file = getOpenedFilesCache(true)

      if (cache == null) {
        file.delete()
        return@launch
      }

      val gson = GsonBuilder().setPrettyPrinting().create()
      val string = gson.toJson(cache)
      file.createNewFile()
      file.writeText(string)
    }.also { job ->
      handleOpenedFilesCacheJobCompletion(job, "write")
    }
  }

  @PublishedApi
  internal fun getOpenedFilesCache(forWrite: Boolean = false): File {
    var file = Environment.getProjectCacheDir(IProjectManager.getInstance().projectDir)
    file = File(file, "editor/openedFiles.json")
    if (file.exists() && forWrite) {
      FileUtils.rename(file, "${file.name}.bak")
    }

    if (file.parentFile?.exists() == false) {
      file.parentFile?.mkdirs()
    }

    file.createNewFile()

    return file
  }
}



================================================
File: java/com/itsaky/androidide/viewmodel/EmptyStateFragmentViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.viewmodel

import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel

/**
 * @author Akash Yadav
 */
class EmptyStateFragmentViewModel : ViewModel() {

  val isEmpty = MutableLiveData(true)
  val emptyMessage = MutableLiveData<CharSequence>("")
}


================================================
File: java/com/itsaky/androidide/viewmodel/FileTreeViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.viewmodel

import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import com.itsaky.androidide.tasks.executeAsync
import com.itsaky.androidide.tasks.runOnUiThread
import com.unnamed.b.atv.view.AndroidTreeView

/**
 * [ViewModel] for the file tree fragment.
 *
 * @author Akash Yadav
 */
internal class FileTreeViewModel : ViewModel() {

  val treeState = MutableLiveData<String>(null)

  val savedState: String
    get() = treeState.value ?: ""

  fun saveState(treeView: AndroidTreeView?) {
    treeView?.let { tree ->
      executeAsync({
        // if a large number of directories have been expanded in the tree
        // this could block teh UI thread
        return@executeAsync tree.saveState
      }) { result ->
        runOnUiThread {
          treeState.value = result
        }
      }
    }
  }
}


================================================
File: java/com/itsaky/androidide/viewmodel/GitViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.viewmodel

import androidx.lifecycle.ViewModel

/**
 * [ViewModel] for the build variants fragment.
 *
 * @author Akash Yadav
 */
class GitViewModel : ViewModel() {

}


================================================
File: java/com/itsaky/androidide/viewmodel/MainViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.viewmodel

import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModel
import com.itsaky.androidide.templates.Template
import java.util.concurrent.atomic.AtomicInteger

/**
 * [ViewModel] for main activity.
 *
 * @author Akash Yadav
 */
class MainViewModel : ViewModel() {

    companion object {

        // The values assigned to these variables reflect the order in which the screens are presented
        // to the user. A screen with a lower value is displayed before a screen with a higher value.
        // For example, SCREEN_MAIN is the first screen visible to the user, followed by SCREEN_TEMPLATE_LIST,
        // and then SCREEN_TEMPLATE_DETAILS.
        //
        // These values are used as unique identifiers for the screens as well as for determining whether
        // the screen change transition should be forward or backward.
        const val SCREEN_MAIN = 0
        const val SCREEN_TEMPLATE_LIST = 1
        const val SCREEN_TEMPLATE_DETAILS = 2
        const val TOOLTIPS_WEB_VIEW = 3
        const val SCREEN_SAVED_PROJECTS = 4
        const val SCREEN_DELETE_PROJECTS = 5
    }

    private val _currentScreen = MutableLiveData(-1)
    private val _previousScreen = AtomicInteger(-1)
    private val _isTransitionInProgress = MutableLiveData(false)

    internal val template = MutableLiveData<Template<*>>(null)
    internal val creatingProject = MutableLiveData(false)

    val currentScreen: LiveData<Int> = _currentScreen

    val previousScreen: Int
        get() = _previousScreen.get()

    var isTransitionInProgress: Boolean
        get() = _isTransitionInProgress.value ?: false
        set(value) {
            _isTransitionInProgress.value = value
        }

    fun setScreen(screen: Int) {
        _previousScreen.set(_currentScreen.value ?: SCREEN_MAIN)
        _currentScreen.value = screen
    }

    fun postTransition(owner: LifecycleOwner, action: Runnable) {
        if (isTransitionInProgress) {
            _isTransitionInProgress.observe(owner, object : Observer<Boolean> {
                override fun onChanged(t: Boolean) {
                    _isTransitionInProgress.removeObserver(this)
                    action.run()
                }
            })
        } else {
            action.run()
        }
    }
}


================================================
File: java/com/itsaky/androidide/viewmodel/RecentProjectsViewModel.kt
================================================
package com.itsaky.androidide.viewmodel

import android.app.Application
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.viewModelScope
import com.itsaky.androidide.roomData.recentproject.RecentProject
import com.itsaky.androidide.roomData.recentproject.RecentProjectDao
import com.itsaky.androidide.roomData.recentproject.RecentProjectRoomDatabase
import com.itsvks.layouteditor.ProjectFile
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.io.File
import java.util.Date

class RecentProjectsViewModel(application: Application) : AndroidViewModel(application) {

    private val _projects = MutableLiveData<List<ProjectFile>>()
    val projects: LiveData<List<ProjectFile>> = _projects


    // Get the database and DAO instance
    private val recentProjectDao: RecentProjectDao =
        RecentProjectRoomDatabase.getDatabase(application, viewModelScope).recentProjectDao()

    fun loadProjects() {
        viewModelScope.launch(Dispatchers.IO) {
            val projectsFromDb = recentProjectDao.dumpAll() ?: emptyList()
            val context = getApplication<Application>().applicationContext
            val projectFiles =
                projectsFromDb.map { ProjectFile(it.location, it.createdAt, context) }
            _projects.postValue(projectFiles)
        }
    }

    fun insertProject(project: RecentProject) = viewModelScope.launch(Dispatchers.IO) {
        recentProjectDao.insert(project)
    }

    fun insertProjectFromFolder(name: String, location: String) =
        viewModelScope.launch(Dispatchers.IO) {
            // Check if the project already exists
            val existingProject = recentProjectDao.getProjectByName(name)
            if (existingProject == null) {
                recentProjectDao.insert(
                    RecentProject(
                        location = location,
                        name = name,
                        createdAt = Date().toString()
                    )
                )
            }
        }


    fun deleteProject(name: String) = viewModelScope.launch(Dispatchers.IO) {
        recentProjectDao.deleteByName(name)
        // Update the LiveData by removing the deleted project
        _projects.value?.let { currentList ->
            val updatedList = currentList.filter { it.name != name }
            _projects.postValue(updatedList)
        }
        loadProjects()
    }

    fun updateProject(oldName: String, newName: String, location: String) =
        viewModelScope.launch(Dispatchers.IO) {
            recentProjectDao.updateNameAndLocation(
                oldName = oldName,
                newName = newName,
                newLocation = location
            )
            loadProjects()
        }

    fun deleteSelectedProjects(selectedNames: List<String>) =
        viewModelScope.launch(Dispatchers.IO) {
            // Delete the selected projects from the database
            recentProjectDao.deleteByNames(selectedNames)
            //  update the LiveData to remove the deleted projects
            _projects.postValue(_projects.value?.filterNot { it.name in selectedNames })

        }
}



================================================
File: java/com/itsaky/androidide/viewmodel/RunTasksViewModel.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.viewmodel

import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModel
import com.itsaky.androidide.models.Checkable
import com.itsaky.androidide.tooling.api.models.GradleTask

/** @author Akash Yadav */
class RunTasksViewModel : ViewModel() {
  
  private val _tasks = MutableLiveData(listOf<Checkable<GradleTask>>())
  private val _selected = MutableLiveData(mutableSetOf<String>())
  private val _displayedChild = MutableLiveData(0)
  private val _query = MutableLiveData("")

  var tasks: List<Checkable<GradleTask>>
    get() = _tasks.value!!
    set(value) {
      _tasks.value = value
    }

  var displayedChild: Int
    get() = this._displayedChild.value!!
    set(value) {
      this._displayedChild.value = value
    }

  var query: String
    get() = _query.value!!
    set(value) {
      _query.value = value
    }

  val selected: Set<String>
    get() = _selected.value!!

  fun observeDisplayedChild(owner: LifecycleOwner, observer: Observer<Int>) {
    _displayedChild.observe(owner, observer)
  }

  fun observeQuery(owner: LifecycleOwner, observer: Observer<String>) {
    _query.observe(owner, observer)
  }

  fun select(item: String) {
    this._selected.value!!.add(item)
  }

  fun deselect(item: String) {
    this._selected.value!!.remove(item)
  }

  fun getSelectedTaskPaths(): String {
    return selected.joinToString(separator = "\n")
  }
}





================================================
File: res/resources.properties
================================================
#
#  This file is part of AndroidIDE.
#
#  Code On The Go is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Code On The Go is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#   along with Code On The Go.  If not, see <https://www.gnu.org/licenses/>.
#

unqualifiedResLocale=en-US



================================================
File: res/drawable/bg_outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <solid android:color="@android:color/white" />

    <stroke
        android:width="1dp"
        android:color="#CCCCCC" />

    <corners android:radius="8dp" />

</shape>


================================================
File: res/drawable/snackbar_custom_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <solid android:color="@color/black"/>
    <corners android:radius="8dp"/>
</shape>


================================================
File: res/menu/ctx_menu.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<menu xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:android="http://schemas.android.com/apk/res/android">

  <item
    android:id="@+id/ctx_menu_main_action_help"
    android:title="Help" />
  <item
    android:id="@+id/ctx_menu_main_action_feedback"
    android:title="Feedback" />
</menu>


================================================
File: res/menu/menu_recent_projects.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/menu_rename"
        android:title="@string/rename" />

    <item
        android:id="@+id/menu_delete"
        android:title="@string/delete" />

</menu>




================================================
File: res/navigation/git_nav_graph.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/git_nav_graph"
    app:startDestination="@id/gitFragment">

    <fragment
        android:id="@+id/gitFragment"
        android:name="com.itsaky.androidide.fragments.sidebar.GitFragment"
        android:label="Git"
        tools:layout="@layout/fragment_git">

        <action
            android:id="@+id/action_gitFragment_to_gitCommitFragment"
            app:destination="@id/gitCommitFragment" />

        <action
            android:id="@+id/action_gitFragment_to_gitRemotesListFragment"
            app:destination="@id/gitRemotesListFragment" />

        <action
            android:id="@+id/action_gitFragment_to_gitCommitListFragment"
            app:destination="@id/gitCommitListFragment" />
    </fragment>

    <fragment
        android:id="@+id/gitCommitFragment"
        android:name="com.itsaky.androidide.fragments.sidebar.GitCommitFragment"
        android:label="Commit Changes"
        tools:layout="@layout/fragment_git_commit" />

    <fragment
        android:id="@+id/gitRemotesListFragment"
        android:name="com.itsaky.androidide.fragments.sidebar.GitRemotesListFragment"
        android:label="Manage Remotes"
        tools:layout="@layout/fragment_git_remotes_list">
        <action
            android:id="@+id/action_gitRemotesListFragment_to_gitEditRemoteFragment"
            app:destination="@id/gitEditRemoteFragment" />
    </fragment>
    <fragment
        android:id="@+id/gitEditRemoteFragment"
        android:name="com.itsaky.androidide.fragments.sidebar.GitEditRemoteFragment"
        android:label="Edit Remote"
        tools:layout="@layout/fragment_git_edit_remote">
        <argument
            android:name="remoteName"
            app:argType="string"
            app:nullable="true"
            android:defaultValue="@null" />
    </fragment>


    <fragment
        android:id="@+id/gitCommitListFragment"
        android:name="com.itsaky.androidide.fragments.sidebar.GitHistoryFragment"
        android:label="Git Log"
        tools:layout="@layout/fragment_git_commit_list">
        <action
            android:id="@+id/action_gitCommitListFragment_to_gitShowCommitFragment"
            app:destination="@id/gitShowCommitFragment" />
    </fragment>

    <fragment
        android:id="@+id/gitShowCommitFragment"
        android:name="com.itsaky.androidide.fragments.sidebar.GitCommitDetailFragment"
        android:label="Commit Details"
        tools:layout="@layout/fragment_git_edit_remote">
        <argument
            android:name="commitHash"
            app:argType="string"
            app:nullable="true"
            android:defaultValue="@null" />
    </fragment>
</navigation>



================================================
File: res/values/arrays.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string-array name="filename_array">
    <item>manifests</item>
    <item>Kotlin+java</item>
    <item>ui.theme</item>
    <item>MainActivity</item>
    <item>res</item>
    <item>\tdrawable</item>
    <item>\tlayout</item>
  </string-array>
</resources>


================================================
File: res/values/bools.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<resources>
  <bool name="logsender_auto_install">false</bool>
</resources>


================================================
File: res/values/colors.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <color name="purple_200">#FFBB86FC</color>
  <color name="purple_500">#FF6200EE</color>
  <color name="purple_700">#FF3700B3</color>
  <color name="lavender">#94B2FF</color>
  <color name="teal_200">#FF03DAC5</color>
  <color name="teal_700">#FF018786</color>
  <color name="black">#FF000000</color>
  <color name="white">#FFFFFFFF</color>
</resources>


================================================
File: res/values/dimens.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<resources>
    <dimen name="editor_mem_usage_view_height">200dp</dimen>
    <dimen name="editor_container_corners">28dp</dimen>

  <dimen name="snackbar_offset_bottom">28dp</dimen>
    <dimen name="tooltip_padding">8dp</dimen>
    <dimen name="faq_bottom_padding">24dp</dimen>
    <dimen name="_32sp">32sp</dimen>
    <dimen name="_16sp">16sp</dimen>
</resources>


================================================
File: res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<resources>
    <!--  Required by F-Droid-->
    <string name="app_name" translatable="false">Code on the Go</string>

</resources>


================================================
File: res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<resources>
  <declare-styleable name="SwipeRevealLayout">
    <attr name="dragHandle" format="reference"/>
  </declare-styleable>
</resources>


================================================
File: res/xml/debugger_accessibility_service_config.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:accessibilityEventTypes="typeWindowStateChanged"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:accessibilityFlags="flagDefault"
    android:canRetrieveWindowContent="false"
    android:description="@string/debugger_foreground_detection_service_description"
    android:notificationTimeout="100" />


================================================
File: res/xml/ide_file_provider_paths.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<paths>
  <root-path name="root" path="." />
  <external-path name="external" path="." />
  <external-files-path name="external_files" path="." />
  <files-path name="files" path="." />
</paths>



================================================
File: res/xml/ide_prefs.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.preference.PreferenceScreen>

</androidx.preference.PreferenceScreen>



================================================
File: res/xml/network_security_config.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">localhost</domain>
        <domain includeSubdomains="true">127.0.0.1</domain>
        <domain includeSubdomains="true">10.0.2.2</domain>
        <domain includeSubdomains="true">10.0.3.2</domain>
    </domain-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system"/>
        </trust-anchors>
    </base-config>
</network-security-config> 

