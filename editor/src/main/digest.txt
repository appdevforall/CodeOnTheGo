Directory structure:
└── main/
    ├── AndroidManifest.xml
    ├── assets/
    │   └── editor/
    │       ├── schemes/
    │       │   ├── default/
    │       │   │   ├── default.json
    │       │   │   ├── editor.json
    │       │   │   ├── java.json
    │       │   │   ├── json.json
    │       │   │   ├── kotlin.json
    │       │   │   ├── log.json
    │       │   │   ├── scheme.prop
    │       │   │   └── xml.json
    │       │   └── default-dark/
    │       │       ├── default-dark.json
    │       │       ├── editor.json
    │       │       ├── java.json
    │       │       ├── json.json
    │       │       ├── kotlin.json
    │       │       ├── log.json
    │       │       ├── scheme.prop
    │       │       └── xml.json
    │       └── treesitter/
    │           ├── java/
    │           │   ├── blocks.scm
    │           │   ├── brackets.scm
    │           │   ├── highlights.scm
    │           │   ├── indents.scm
    │           │   └── locals.scm
    │           ├── json/
    │           │   ├── blocks.scm
    │           │   ├── brackets.scm
    │           │   ├── highlights.scm
    │           │   └── indents.scm
    │           ├── kt/
    │           │   ├── highlights.scm
    │           │   └── locals.scm
    │           ├── log/
    │           │   └── highlights.scm
    │           └── xml/
    │               ├── blocks.scm
    │               ├── brackets.scm
    │               ├── highlights.scm
    │               └── indents.scm
    ├── java/
    │   ├── com/
    │   │   └── itsaky/
    │   │       └── androidide/
    │   │           └── editor/
    │   │               ├── adapters/
    │   │               │   └── CompletionListAdapter.kt
    │   │               ├── events/
    │   │               │   ├── FileUpdateEvent.kt
    │   │               │   └── LanguageUpdateEvent.kt
    │   │               ├── language/
    │   │               │   ├── CommonCompletionProvider.kt
    │   │               │   ├── CompletionCancelChecker.kt
    │   │               │   ├── IDELanguage.kt
    │   │               │   ├── LSPFormatter.kt
    │   │               │   ├── cpp/
    │   │               │   │   ├── CppAnalyzer.java
    │   │               │   │   └── CppLanguage.java
    │   │               │   ├── groovy/
    │   │               │   │   ├── GroovyAnalyzer.kt
    │   │               │   │   ├── GroovyAutoComplete.java
    │   │               │   │   └── GroovyLanguage.java
    │   │               │   ├── incremental/
    │   │               │   │   ├── BaseIncrementalAnalyzeManager.java
    │   │               │   │   ├── IncrementalToken.kt
    │   │               │   │   └── LineState.kt
    │   │               │   ├── newline/
    │   │               │   │   ├── BaseNewlineHandler.kt
    │   │               │   │   ├── BracketsNewlineHandler.kt
    │   │               │   │   ├── CStyleBracketsHandler.kt
    │   │               │   │   ├── TSBracketsHandler.kt
    │   │               │   │   └── TSCStyleBracketsHandler.kt
    │   │               │   ├── treesitter/
    │   │               │   │   ├── JavaLanguage.kt
    │   │               │   │   ├── JsonLanguage.kt
    │   │               │   │   ├── KotlinLanguage.kt
    │   │               │   │   ├── LogLanguage.kt
    │   │               │   │   ├── TSLanguageRegistry.kt
    │   │               │   │   ├── TreeSitterAnalyzeManager.kt
    │   │               │   │   ├── TreeSitterIndentProvider.kt
    │   │               │   │   ├── TreeSitterLanguage.kt
    │   │               │   │   ├── TreeSitterLanguageProvider.kt
    │   │               │   │   ├── TreeSitterLanguageSpec.kt
    │   │               │   │   ├── TreeSitterSpanFactory.kt
    │   │               │   │   ├── XMLLanguage.kt
    │   │               │   │   ├── common.kt
    │   │               │   │   ├── internal/
    │   │               │   │   │   └── TSLanguageRegistryImpl.kt
    │   │               │   │   └── predicates/
    │   │               │   │       ├── AnyOfPredicate.kt
    │   │               │   │       ├── EqualPredicate.kt
    │   │               │   │       ├── InvertingPredicate.kt
    │   │               │   │       ├── MatchPredicate.kt
    │   │               │   │       ├── NotEqualPredicate.kt
    │   │               │   │       ├── NotMatchPredicate.kt
    │   │               │   │       └── TreeSitterPredicate.kt
    │   │               │   └── utils/
    │   │               │       ├── CommonSymbolPairs.kt
    │   │               │       └── CompletionHelper.kt
    │   │               ├── schemes/
    │   │               │   ├── IDEColorScheme.kt
    │   │               │   ├── IDEColorSchemeProvider.kt
    │   │               │   ├── LanguageSpecProvider.kt
    │   │               │   ├── LocalCaptureSpecProvider.kt
    │   │               │   └── internal/
    │   │               │       └── parser/
    │   │               │           ├── EditorSchemeParser.kt
    │   │               │           ├── LanguageParser.kt
    │   │               │           ├── ParseException.kt
    │   │               │           ├── SchemeParser.kt
    │   │               │           └── common.kt
    │   │               ├── snippets/
    │   │               │   ├── AbstractSnippetVariableResolver.kt
    │   │               │   ├── FileVariableResolver.kt
    │   │               │   └── WorkspaceVariableResolver.kt
    │   │               ├── ui/
    │   │               │   ├── AbstractPopupWindow.kt
    │   │               │   ├── BaseEditorWindow.java
    │   │               │   ├── DiagnosticWindow.kt
    │   │               │   ├── EditorActionsMenu.kt
    │   │               │   ├── EditorCompletionLayout.kt
    │   │               │   ├── EditorCompletionWindow.kt
    │   │               │   ├── EditorEventDispatcher.kt
    │   │               │   ├── EditorFeatures.kt
    │   │               │   ├── EditorSearchLayout.kt
    │   │               │   ├── IDECompletionPublisher.kt
    │   │               │   ├── IDEEditor.kt
    │   │               │   ├── ReplaceAction.kt
    │   │               │   ├── SignatureHelpWindow.java
    │   │               │   └── TracingEditorRenderer.kt
    │   │               └── utils/
    │   │                   ├── ContentReadWrite.kt
    │   │                   └── contentExt.kt
    │   └── io/
    │       └── github/
    │           └── rosemoe/
    │               └── sora/
    │                   ├── text/
    │                   │   └── ContentLockAccessor.kt
    │                   └── widget/
    │                       └── IDEEditorSearcher.kt
    └── res/
        ├── layout/
        │   ├── layout_code_editor.xml
        │   ├── layout_completion_item.xml
        │   ├── layout_editor_find_replace.xml
        │   ├── layout_find_in_file.xml
        │   └── layout_popup_menu_item.xml
        └── values/
            └── dimens.xml

================================================
File: AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<manifest/>


================================================
File: assets/editor/schemes/default/default.json
================================================
{
  "definitions": {
    "primary": "#6f5a4a",
    "primaryLight": "#f9ddc9",
    "primaryInverse": "#dcc2ae",
    "onPrimary": "#ffffff",
    "onPrimaryContainer": "#27190c",
    "surface": "#ffffff",
    "surfaceInverse": "#33302e",
    "surfaceVariant": "#e8e1dd",
    "onSurface": "#1e1b19",
    "onSurfaceVariant": "#4a4644",
    "outline": "#7a7572",
    "text.selected": "#ff5252",

    "type": "#1976d2",
    "keyword": "#d32f2f",
    "operator": "#1976d2",
    "attribute": "#827717",
    "variable": "#ba68c8",
    "field" : "#ff6f00",
    "constant": "#ff6f00",
    "number": "#558b2f",
    "string": "#558b2f",
    "comment": "#9e9e9e",
    "func.decl": "#2196f3",
    "func.call": "#2196f3",

    "java.package": "#e66400",

    "kt.preproc":  "#9e9e9e",
    "kt.property":  "#ff6f00",
    "kt.punctuation.special": "#d32f2f",
    "kt.constructor": "#2196f3",
    "kt.string.esc": "#2196f3",

    "xml.tag": "#e64a19",
    "xml.ref": "#2196f3",
    "ns_prefix": "#9c27b0",

    "json.key": "#1976d2",
    "json.escape": "#2196f3",

    "log.err.text": "#f44336",
    "log.err.pr.fg" : "#000000",
    "log.err.pr.bg" : "#f44336",

    "log.warn.text": "#ffab00",
    "log.warn.pr.fg" : "#000000",
    "log.warn.pr.bg" : "#FFEB3B",

    "log.info.text": "#4CAF50",
    "log.info.pr.fg" : "#ffffff",
    "log.info.pr.bg" : "#1f65c0",

    "log.debug.text": "#212121",
    "log.debug.pr.fg" : "#ffffff",
    "log.debug.pr.bg" : "#9e9d24",

    "log.verbose.text": "#0288d1",
    "log.verbose.pr.fg" : "#000000",
    "log.verbose.pr.bg" : "#ffffff",

    "breakpoint.line.indicator": "#f77b72",
    "breakpoint.line.bg": "#f77b72"
  },
  "editor": "@editor.json",
  "languages": [
    "@java.json",
    "@json.json",
    "@kotlin.json",
    "@xml.json",
    "@log.json"
  ]
}


================================================
File: assets/editor/schemes/default/editor.json
================================================
{
  "bg": "@surface",
  "line.current": "@surfaceVariant",
  "line.divider": "@surface",
  "line.num": "@onSurface",
  "line.num.current": "@surfaceInverse",
  "line.num.bg": "@surface",
  "line.num.panel": "@surfaceVariant",
  "line.num.panel.text": "@onSurfaceVariant",
  "text.normal": "@onSurface",
  "text.cursor": "@primary",
  "text.selection.handle": "@primaryInverse",
  "text.matched.bg": "#FF8F00",
  "text.selected.bg": "@primaryLight",
  "snippet.bg.editing": "#cccccc",
  "snippet.bg.related": "#cccccc",
  "snippet.bg.inactive": "#66dddddd",

  "scrollbar.thumb": "@surface",
  "scrollbar.thumb.pressed": "@surfaceInverse",
  "scrollbar.track": "@surfaceVariant",

  "code.block.line": "@surfaceVariant",
  "code.block.line.current": "@outline",
  "code.block.line.side": "@outline",
  "highlighted.delimiters.underline": "@outline",
  "highlighted.delimiters.bg": "@surfaceVariant",
  "highlighted.delimiters.fg": "@onSurface",

  "non_printable_char": "@onSurface",

  "breakpoint.line.indicator": "@breakpoint.line.indicator",
  "breakpoint.line.bg": "@breakpoint.line.bg"
}


================================================
File: assets/editor/schemes/default/java.json
================================================
{
  "types": [
    "java"
  ],
  "local.scopes": [
    "scope"
  ],
  "local.scopes.members": [
    "scope.members"
  ],
  "local.definitions": [
    "definition.var",
    "definition.field"
  ],
  "local.references": [
    "reference"
  ],
  "styles": {
    "comment": {
      "fg": "@comment",
      "italic": true
    },
    "keyword": {
      "fg": "@keyword",
      "bold": true
    },
    "string": {
      "fg": "@string",
      "completion": false,
      "maybeHexColor": true
    },
    "variable.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "function.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "type.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "constant": {
      "fg": "@constant",
      "bold": true
    },
    "number": "@number",
    "variable": "@onSurface",
    "constant.builtin": "@keyword",
    "type": "@type",
    "attribute": "@attribute",
    "function.declaration": "@func.decl",
    "function.invocation": "@func.call",
    "variable.field": "@field",
    "operator": "@operator",

    "package.decl": "@java.package",

    "import.package": "@java.package",
    "import.type": "@type",
    "import.member": "@field"
  }
}


================================================
File: assets/editor/schemes/default/json.json
================================================
{
  "types": ["json"],
  "styles": {
    "string.special.key": "@json.key",
    "string" : {
      "fg": "@string",
      "maybeHexColor": true
    },
    "number" : "@number",
    "constant.builtin": "@keyword",
    "escape": "@json.escape",
    "comment" : {
      "fg": "@comment",
      "italic": true
    }
  }
}


================================================
File: assets/editor/schemes/default/kotlin.json
================================================
{
  "types": [
    "kt", "kts"
  ],
  "local.scopes": [
    "scope"
  ],
  "local.scopes.members": [
    "scope.members"
  ],
  "local.definitions": [
    "definition.namespace",
    "definition.import",
    "definition.function",
    "definition.method",
    "definition.parameter",
    "definition.field"
  ],
  "local.references": [
    "reference"
  ],
  "styles": {
    "preproc": {
      "fg": "@kt.preproc",
      "italic": true,
      "bold": true
    },
    "comment": {
      "fg": "@comment",
      "italic": true
    },
    "keyword": {
      "fg": "@keyword",
      "bold": true
    },
    "label": {
      "fg": "@keyword",
      "bold": true
    },
    "type.qualifier": {
      "fg": "@keyword",
      "bold": true
    },
    "string": {
      "fg": "@string",
      "completion": false,
      "maybeHexColor": true
    },
    "string.regex": {
      "fg": "@string",
      "completion": false
    },
    "string.escape": {
      "fg": "@kt.string.esc",
      "completion": false
    },
    "variable.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "function.builtin": {
      "fg": "@func.call",
      "italic": true
    },
    "type.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "constant": {
      "fg": "@constant",
      "bold": true
    },
    "number": "@number",
    "identifier": "@onSurface",
    "parameter": "@variable",
    "constant.builtin": "@keyword",
    "type": "@type",
    "attribute": "@attribute",
    "function.declaration": "@func.decl",
    "function.invocation": "@func.call",
    "operator": "@operator",
    "punctuation.special": "@kt.punctuation.special",
    "constructor": "@kt.constructor",
    "property.class": "@kt.property",
    "property.top_level": "@kt.property",
    "property.local": "@onSurface",
    "bracket": "@onSurface"
  }
}


================================================
File: assets/editor/schemes/default/log.json
================================================
{
  "types": ["log"],
  "styles": {
    "begin_header" : {
      "fg": "@comment",
      "italic": true
    },
    "err.date": "@log.err.text",
    "err.time": "@log.err.text",
    "err.pid": "@log.err.text",
    "err.tid": "@log.err.text",
    "err.tag" : "@log.err.text",
    "err.msg": "@log.err.text",
    "err.priority": {
      "fg": "@log.err.pr.fg",
      "bg": "@log.err.pr.bg"
    },

    "warn.date": "@log.warn.text",
    "warn.time": "@log.warn.text",
    "warn.pid": "@log.warn.text",
    "warn.tid": "@log.warn.text",
    "warn.tag" : "@log.warn.text",
    "warn.msg": "@log.warn.text",
    "warn.priority": {
      "fg": "@log.warn.pr.fg",
      "bg": "@log.warn.pr.bg"
    },

    "info.date": "@log.info.text",
    "info.time": "@log.info.text",
    "info.pid": "@log.info.text",
    "info.tid": "@log.info.text",
    "info.tag" : "@log.info.text",
    "info.msg": "@log.info.text",
    "info.priority": {
      "fg": "@log.info.pr.fg",
      "bg": "@log.info.pr.bg"
    },

    "debug.date": "@log.debug.text",
    "debug.time": "@log.debug.text",
    "debug.pid": "@log.debug.text",
    "debug.tid": "@log.debug.text",
    "debug.tag" : "@log.debug.text",
    "debug.msg": "@log.debug.text",
    "debug.priority": {
      "fg": "@log.debug.pr.fg",
      "bg": "@log.debug.pr.bg"
    },

    "verbose.date": "@log.verbose.text",
    "verbose.time": "@log.verbose.text",
    "verbose.pid": "@log.verbose.text",
    "verbose.tid": "@log.verbose.text",
    "verbose.tag" : "@log.verbose.text",
    "verbose.msg": "@log.verbose.text",
    "verbose.priority": {
      "fg": "@log.verbose.pr.fg",
      "bg": "@log.verbose.pr.bg"
    }
  }
}


================================================
File: assets/editor/schemes/default/scheme.prop
================================================
# Name of the color scheme
scheme.name=AndroidIDE Default

# The version code of the color scheme
scheme.version=13

# Whether the scheme is dark or light
scheme.isDark=false

# The JSON color scheme definition file
scheme.file=default.json


================================================
File: assets/editor/schemes/default/xml.json
================================================
{
  "types": ["xml"],
  "styles": {
    "xml_decl": {
      "fg": "@operator",
      "bold": true
    },
    "element.tag": {
      "fg": "@xml.tag",
      "bold": true
    },
    "ns_declarator": {
      "fg": "@keyword",
      "bold": true
    },
    "xml.ref": {
      "fg": "@xml.ref",
      "italic": true
    },
    "comment": {
      "fg": "@comment",
      "italic": true
    },
    "operator": "@operator",
    "cdata.start": "@xml.tag",
    "cdata.end": "@xml.tag",
    "cdata": "@onSurface",
    "xmlns.prefix": "@ns_prefix",
    "attr.prefix" : "@ns_prefix",
    "attr.name": "@onSurface",
    "attr.value": {
      "fg": "@string",
      "maybeHexColor": true
    },
    "text": {
      "fg": "@onSurface",
      "maybeHexColor": true
    }
  }
}


================================================
File: assets/editor/schemes/default-dark/default-dark.json
================================================
{
  "definitions": {
    "primary": "#dcc2ae",
    "primaryLight": "#ff564334",
    "primaryInverse": "#ff6f5a4a",
    "onPrimary": "#ff3d2d1f",
    "onPrimaryContainer": "#fff9ddc9",
    "surface": "#ff1e1b19",
    "surfaceInverse": "#ffe8e1dd",
    "surfaceVariant": "#ff4a4644",
    "onSurface": "#ffe8e1dd",
    "onSurfaceVariant": "#ffccc5c2",
    "outline": "#ff95908d",

    "type": "#4fc3f7",
    "keyword": "#ff6060",
    "operator": "#4fc3f7",
    "attribute": "#afb42b",
    "variable": "#ba68c8",
    "field" : "#f0be4b",
    "constant": "#f0be4b",
    "number": "#8bc34a",
    "string": "#8bc34a",
    "comment": "#bdbdbd",
    "func.decl": "#64b5f6",
    "func.call": "#64b5f6",

    "java.package": "#d8ab44",

    "kt.preproc":  "#bdbdbd",
    "kt.property":  "#f0be4b",
    "kt.punctuation.special": "#ff6060",
    "kt.constructor": "#64b5f6",
    "kt.string.esc": "#2196f3",

    "xml.tag": "#ff6060",
    "xml.ref": "#90caf9",
    "ns_prefix": "#ce93d8",

    "json.key": "#ba68c8",
    "json.escape": "#2196f3",

    "log.err.text": "#f44336",
    "log.err.pr.fg" : "#000000",
    "log.err.pr.bg" : "#f44336",

    "log.warn.text": "#FFEB3B",
    "log.warn.pr.fg" : "#000000",
    "log.warn.pr.bg" : "#FFEB3B",

    "log.info.text": "#4CAF50",
    "log.info.pr.fg" : "#ffffff",
    "log.info.pr.bg" : "#1f65c0",

    "log.debug.text": "#f5f5f5",
    "log.debug.pr.fg" : "#ffffff",
    "log.debug.pr.bg" : "#9e9d24",

    "log.verbose.text": "#4fc3f7",
    "log.verbose.pr.fg" : "#000000",
    "log.verbose.pr.bg" : "#ffffff",

    "breakpoint.line.indicator": "#f44336",
    "breakpoint.line.bg": "#f44336"
  },
  "editor": "@editor.json",
  "languages": [
    "@java.json",
    "@json.json",
    "@kotlin.json",
    "@xml.json",
    "@log.json"
  ]
}


================================================
File: assets/editor/schemes/default-dark/editor.json
================================================
{
  "bg": "@surface",
  "line.current": "@surfaceVariant",
  "line.divider": "@surface",
  "line.num": "@onSurface",
  "line.num.current": "@surfaceInverse",
  "line.num.bg": "@surface",
  "line.num.panel": "@surfaceVariant",
  "line.num.panel.text": "@onSurfaceVariant",
  "text.normal": "@onSurface",
  "text.cursor": "@primary",
  "text.selection.handle": "@primaryInverse",
  "text.selected": "@onSurface",
  "text.matched.bg": "#FF8F00",
  "text.selected.bg": "@primaryLight",
  "snippet.bg.editing": "#44cccccc",
  "snippet.bg.related": "#44dddddd",
  "snippet.bg.inactive": "#66dddddd",

  "scrollbar.thumb": "@surface",
  "scrollbar.thumb.pressed": "@surfaceInverse",
  "scrollbar.track": "@surfaceVariant",

  "code.block.line": "@surfaceVariant",
  "code.block.line.current": "@outline",
  "code.block.line.side": "@outline",
  "highlighted.delimiters.underline": "@outline",
  "highlighted.delimiters.bg": "@surfaceVariant",
  "highlighted.delimiters.fg": "@onSurface",

  "non_printable_char": "@onSurface",

  "breakpoint.line.indicator": "@breakpoint.line.indicator",
  "breakpoint.line.bg": "@breakpoint.line.bg"
}


================================================
File: assets/editor/schemes/default-dark/java.json
================================================
{
  "types": [
    "java"
  ],
  "local.scopes": [
    "scope"
  ],
  "local.scopes.members": [
    "scope.members"
  ],
  "local.definitions": [
    "definition.var",
    "definition.field"
  ],
  "local.references": [
    "reference"
  ],
  "styles": {
    "comment": {
      "fg": "@comment",
      "italic": true
    },
    "keyword": {
      "fg": "@keyword",
      "bold": true
    },
    "string": {
      "fg": "@string",
      "completion": false,
      "maybeHexColor": true
    },
    "variable.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "function.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "type.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "constant": {
      "fg": "@constant",
      "bold": true
    },
    "number": "@number",
    "variable": "@onSurface",
    "constant.builtin": "@keyword",
    "type": "@type",
    "attribute": "@attribute",
    "function.declaration": "@func.decl",
    "function.invocation": "@func.call",
    "variable.field": "@field",
    "operator": "@operator",

    "package.decl": "@java.package",

    "import.package": "@java.package",
    "import.type": "@type",
    "import.member": "@field"
  }
}


================================================
File: assets/editor/schemes/default-dark/json.json
================================================
{
  "types": ["json"],
  "styles": {
    "string.special.key": "@json.key",
    "string" : {
      "fg": "@string",
      "maybeHexColor": true
    },
    "number" : "@number",
    "constant.builtin": "@keyword",
    "escape": "@json.escape",
    "comment" : {
      "fg": "@comment",
      "italic": true
    }
  }
}


================================================
File: assets/editor/schemes/default-dark/kotlin.json
================================================
{
  "types": [
    "kt", "kts"
  ],
  "local.scopes": [
    "scope"
  ],
  "local.scopes.members": [
    "scope.members"
  ],
  "local.definitions": [
    "definition.namespace",
    "definition.import",
    "definition.function",
    "definition.method",
    "definition.parameter",
    "definition.field"
  ],
  "local.references": [
    "reference"
  ],
  "styles": {
    "preproc": {
      "fg": "@kt.preproc",
      "italic": true,
      "bold": true
    },
    "comment": {
      "fg": "@comment",
      "italic": true
    },
    "keyword": {
      "fg": "@keyword",
      "bold": true
    },
    "label": {
      "fg": "@keyword",
      "bold": true
    },
    "type.qualifier": {
      "fg": "@keyword",
      "bold": true
    },
    "string": {
      "fg": "@string",
      "completion": false,
      "maybeHexColor": true
    },
    "string.regex": {
      "fg": "@string",
      "completion": false
    },
    "string.escape": {
      "fg": "@kt.string.esc",
      "completion": false
    },
    "variable.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "function.builtin": {
      "fg": "@func.call",
      "italic": true
    },
    "type.builtin": {
      "fg": "@keyword",
      "bold": true
    },
    "constant": {
      "fg": "@constant",
      "bold": true
    },
    "number": "@number",
    "identifier": "@onSurface",
    "parameter": "@variable",
    "constant.builtin": "@keyword",
    "type": "@type",
    "attribute": "@attribute",
    "function.declaration": "@func.decl",
    "function.invocation": "@func.call",
    "operator": "@operator",
    "punctuation.special": "@kt.punctuation.special",
    "constructor": "@kt.constructor",
    "property.class": "@kt.property",
    "property.top_level": "@kt.property",
    "property.local": "@onSurface",
    "bracket": "@onSurface"
  }
}


================================================
File: assets/editor/schemes/default-dark/log.json
================================================
{
  "types": ["log"],
  "styles": {
    "begin_header" : {
      "fg": "@comment",
      "italic": true
    },
    "err.date": "@log.err.text",
    "err.time": "@log.err.text",
    "err.pid": "@log.err.text",
    "err.tid": "@log.err.text",
    "err.tag" : "@log.err.text",
    "err.msg": "@log.err.text",
    "err.priority": {
      "fg": "@log.err.pr.fg",
      "bg": "@log.err.pr.bg"
    },

    "warn.date": "@log.warn.text",
    "warn.time": "@log.warn.text",
    "warn.pid": "@log.warn.text",
    "warn.tid": "@log.warn.text",
    "warn.tag" : "@log.warn.text",
    "warn.msg": "@log.warn.text",
    "warn.priority": {
      "fg": "@log.warn.pr.fg",
      "bg": "@log.warn.pr.bg"
    },

    "info.date": "@log.info.text",
    "info.time": "@log.info.text",
    "info.pid": "@log.info.text",
    "info.tid": "@log.info.text",
    "info.tag" : "@log.info.text",
    "info.msg": "@log.info.text",
    "info.priority": {
      "fg": "@log.info.pr.fg",
      "bg": "@log.info.pr.bg"
    },

    "debug.date": "@log.debug.text",
    "debug.time": "@log.debug.text",
    "debug.pid": "@log.debug.text",
    "debug.tid": "@log.debug.text",
    "debug.tag" : "@log.debug.text",
    "debug.msg": "@log.debug.text",
    "debug.priority": {
      "fg": "@log.debug.pr.fg",
      "bg": "@log.debug.pr.bg"
    },

    "verbose.date": "@log.verbose.text",
    "verbose.time": "@log.verbose.text",
    "verbose.pid": "@log.verbose.text",
    "verbose.tid": "@log.verbose.text",
    "verbose.tag" : "@log.verbose.text",
    "verbose.msg": "@log.verbose.text",
    "verbose.priority": {
      "fg": "@log.verbose.pr.fg",
      "bg": "@log.verbose.pr.bg"
    }
  }
}


================================================
File: assets/editor/schemes/default-dark/scheme.prop
================================================
# Name of the color scheme
scheme.name=AndroidIDE Default - Dark

# The version code of the color scheme
scheme.version=13

# Whether the scheme is dark or light
scheme.isDark=true

# The JSON color scheme definition file
scheme.file=default-dark.json


================================================
File: assets/editor/schemes/default-dark/xml.json
================================================
{
  "types": ["xml"],
  "styles": {
    "xml_decl": {
      "fg": "@operator",
      "bold": true
    },
    "element.tag": {
      "fg": "@xml.tag",
      "bold": true
    },
    "ns_declarator": {
      "fg": "@keyword",
      "bold": true
    },
    "xml.ref": {
      "fg": "@xml.ref",
      "italic": true
    },
    "comment": {
      "fg": "@comment",
      "italic": true
    },
    "operator": "@operator",
    "cdata.start": "@xml.tag",
    "cdata.end": "@xml.tag",
    "cdata": "@onSurface",
    "xmlns.prefix": "@ns_prefix",
    "attr.prefix" : "@ns_prefix",
    "attr.name": "@onSurface",
    "attr.value": {
      "fg": "@string",
      "maybeHexColor": true
    },
    "text": {
      "fg": "@onSurface",
      "maybeHexColor": true
    }
  }
}


================================================
File: assets/editor/treesitter/java/blocks.scm
================================================
; Code block patterns for editor
; Capture names for scopes does not matter much in sora-editor implementation, you may use 'abc', 'test.xyz', etc.
; General, editor considers the captured node's region as code block region.
; However, capture name with '.marked' suffix is special. The last terminal node's start position in the capture will be the end position of the block
; 'terminal node' refers to a node without children

(class_declaration
  body: (_) @scope.marked)

(record_declaration
  body: (_) @scope.marked)

(enum_declaration
  body: (_) @scope.marked)

(block) @scope.marked

(array_initializer) @scope.marked


================================================
File: assets/editor/treesitter/java/brackets.scm
================================================
; Brackets pattern for editor
; Note that you should match both open node and close node in one pattern
; In sora-editor, capture named 'editor.brackets.open' is regarded as open symbol node, capture named 'editor.brackets.close' is regarded as close symbol node.
(block
  "{" @editor.brackets.open
  "}" @editor.brackets.close)

(expression
  "(" @editor.brackets.open
  ")" @editor.brackets.close)

(array_initializer
  "{" @editor.brackets.open
  "}" @editor.brackets.close)


================================================
File: assets/editor/treesitter/java/highlights.scm
================================================
(package_declaration
  name: (_) @package.decl)

; import package.name.Type
(single_type_import
  (scoped_identifier
    scope: (_) @import.package
    name: (_) @import.type))

; import package.name.*
(type_import_on_demand
  (scoped_identifier) @import.package
  (asterisk) @import.member)

; import static package.name.Type.MEMBER
(single_static_import
  (scoped_identifier
    scope: (_) @import.package
    name: (_) @import.type)
  (identifier) @import.member .)

; import static package.name.Type.*
(static_import_on_demand
  (scoped_identifier
    scope: (_) @import.package
    name: (_) @import.type)
  (asterisk) @import.member)

; Methods and Fields

(method_declaration
  name: (identifier) @function.declaration)
(method_invocation
  name: (identifier) @function.invocation)
(super) @function.builtin
(field_declaration
  declarator: (variable_declarator
                name: (identifier) @variable.field))

; Annotations

(annotation
  "@" @attribute
  name: (identifier) @attribute)

(annotation_argument_list
  (element_value_pair
    key: (identifier) @variable.field))

(marker_annotation
  "@" @attribute
  name: (identifier) @attribute)

; Types

(type_identifier) @type

(interface_declaration
  name: (identifier) @type)
(class_declaration
  name: (identifier) @type)
(enum_declaration
  name: (identifier) @type)

((field_access
  object: (identifier) @type)
 (#match? @type "^[A-Z]"))
((scoped_identifier
  scope: (identifier) @type)
 (#match? @type "^[A-Z]"))
((method_invocation
  object: (identifier) @type)
 (#match? @type "^[A-Z]"))
((method_reference
  . (identifier) @type)
 (#match? @type "^[A-Z]"))

(constructor_declaration
  name: (identifier) @type)

[
  (boolean_type)
  (integral_type)
  (floating_point_type)
  (floating_point_type)
  (void_type)
] @type.builtin

; Variables

(field_access
  field: (_) @variable.field)

((identifier) @constant
 (#match? @constant "^_*[A-Z][A-Z\\d_]+$"))

; (identifier) @variable

(this) @variable.builtin

; Literals

[
  (hex_integer_literal)
  (decimal_integer_literal)
  (octal_integer_literal)
  (decimal_floating_point_literal)
  (hex_floating_point_literal)
] @number

[
  (character_literal)
  (string_literal)
] @string

[
  (true)
  (false)
  (null_literal)
] @constant.builtin

[
  (line_comment)
  (block_comment)
] @comment

; Keywords

[
  "abstract"
  "assert"
  "break"
  "case"
  "catch"
  "class"
  "continue"
  "default"
  "do"
  "else"
  "enum"
  "exports"
  "extends"
  "final"
  "finally"
  "for"
  "if"
  "implements"
  "import"
  "instanceof"
  "interface"
  "module"
  "native"
  "new"
  "non-sealed"
  "open"
  "opens"
  "package"
  "private"
  "protected"
  "provides"
  "public"
  "requires"
  "return"
  "sealed"
  "static"
  "strictfp"
  "switch"
  "synchronized"
  "throw"
  "throws"
  "to"
  "transient"
  "transitive"
  "try"
  "uses"
  "volatile"
  "while"
  "with"
] @keyword


================================================
File: assets/editor/treesitter/java/indents.scm
================================================
; https://github.com/nvim-treesitter/nvim-treesitter/blob/57a8acf0c4ed5e7f6dda83c3f9b073f8a99a70f9/queries/java/indents.scm

; format-ignore
[
  ; ... refers to the portion that this indent query will have effects on
  (class_body)                        ; { ... } of `class X`
  (enum_body)                         ; { ... } of `enum X`
  (interface_body)                    ; { ... } of `interface X`
  (constructor_body)                  ; { `modifier` X() {...} } inside `class X`
  (annotation_type_body)              ; { ... } of `@interface X`
  (block)                             ; { ... } that's not mentioned in this scope
  (switch_block)                      ; { ... } in `switch X`
  (array_initializer)                 ; [1, 2]
  (argument_list)                     ; foo(...)
  (formal_parameters)                 ; method foo(...)
  (annotation_argument_list)          ; @Annotation(...)
  (element_value_array_initializer)   ; { a, b } inside @Annotation()
] @indent.begin

(expression_statement
  (method_invocation) @indent.begin)

[
  "("
  ")"
  "{"
  "}"
  "["
  "]"
] @indent.branch

(annotation_argument_list
  ")" @indent.end) ; This should be a special cased as `()` here doesn't have ending `;`

"}" @indent.end

(line_comment) @indent.ignore

[
  (ERROR)
  (block_comment)
] @indent.auto


================================================
File: assets/editor/treesitter/java/locals.scm
================================================
; from https://github.com/nvim-treesitter/nvim-treesitter/blob/eedb7b9c69b13afe86461b0742266bb62b811ece/queries/java/locals.scm
; SCOPES
; declarations
(program) @scope
(class_declaration
  body: (_) @scope.members)
(record_declaration
  body: (_) @scope.members)
(enum_declaration
  body: (_) @scope.members)
(lambda_expression) @scope
(enhanced_for_statement) @scope

; block
(block) @scope

; if/else
(if_statement) @scope ; if+else
(if_statement
  consequence: (_) @scope) ; if body in case there are no braces
(if_statement
  alternative: (_) @scope) ; else body in case there are no braces

; try/catch
(try_statement) @scope ; covers try+catch, individual try and catch are covered by (block)
(catch_clause) @scope ; needed because `Exception` variable

; loops
(for_statement) @scope ; whole for_statement because loop iterator variable
(for_statement         ; "for" body in case there are no braces
  body: (_) @scope)
(do_statement
  body: (_) @scope)
(while_statement
  body: (_) @scope)

; Functions

(constructor_declaration) @scope
(method_declaration) @scope


; DEFINITIONS
(local_variable_declaration
  declarator: (variable_declarator
                name: (identifier) @definition.var))
(formal_parameter
  name: (identifier) @definition.var)
(catch_formal_parameter
  name: (identifier) @definition.var)
(inferred_parameters (identifier) @definition.var) ; (x,y) -> ...
(lambda_expression
    parameters: (identifier) @definition.var) ; x -> ...
(enhanced_for_statement ; for (var item : items) {
  name: (identifier) @definition.var)

(field_declaration
  declarator: (variable_declarator
                name: (identifier) @definition.field))

; REFERENCES
(identifier) @reference


================================================
File: assets/editor/treesitter/json/blocks.scm
================================================
(object) @scope.marked
(array) @scope.marked


================================================
File: assets/editor/treesitter/json/brackets.scm
================================================
(object
  "{" @editor.brackets.open
  "}" @editor.brackets.close)

(array
  "[" @editor.brackets.open
  "]" @editor.brackets.close)


================================================
File: assets/editor/treesitter/json/highlights.scm
================================================
(pair
  key: (_) @string.special.key)

(string) @string

(number) @number

[
  (null)
  (true)
  (false)
] @constant.builtin

(escape_sequence) @escape

(comment) @comment


================================================
File: assets/editor/treesitter/json/indents.scm
================================================
(object
  "{" @indent
  "}" @outdent)

(array
  "[" @indent
  "]" @outdent)


================================================
File: assets/editor/treesitter/kt/highlights.scm
================================================
;;; Identifiers

(simple_identifier) @identifier

; `this` this keyword inside classes
(this_expression) @variable.builtin

; `super` keyword inside classes
(super_expression) @variable.builtin

(statements
	  (property_declaration
  	  	(variable_declaration
  		  	(simple_identifier) @property.local)))

(source_file
	(property_declaration
		(variable_declaration
			(simple_identifier) @property.top_level)))

(class_body
	(property_declaration
		(variable_declaration
			(simple_identifier) @property.class)))

(class_parameter
	(simple_identifier) @property.class)

; id_1.id_2.id_3: `id_2` and `id_3` are assumed as object properties
(_
	(navigation_suffix
		(simple_identifier) @property.class))

; SCREAMING CASE identifiers are assumed to be constants
((simple_identifier) @constant
(#match? @constant "^[A-Z][A-Z0-9_]*$"))

(_
	(navigation_suffix
		(simple_identifier) @constant
		(#match? @constant "^[A-Z][A-Z0-9_]*$")))

(enum_entry
	(simple_identifier) @constant)

(type_identifier) @type

; '?' operator, replacement for Java @Nullable
(nullable_type) @punctuation.special

((type_identifier) @type.builtin
	(#any-of? @type.builtin
		"Byte"
		"Short"
		"Int"
		"Long"
		"UByte"
		"UShort"
		"UInt"
		"ULong"
		"Float"
		"Double"
		"Boolean"
		"Char"
		"String"
		"Array"
		"ByteArray"
		"ShortArray"
		"IntArray"
		"LongArray"
		"UByteArray"
		"UShortArray"
		"UIntArray"
		"ULongArray"
		"FloatArray"
		"DoubleArray"
		"BooleanArray"
		"CharArray"
		"Map"
		"Set"
		"List"
		"EmptyMap"
		"EmptySet"
		"EmptyList"
		"MutableMap"
		"MutableSet"
		"MutableList"
))

(package_header
  "package" @keyword)

(import_header
	"import" @keyword)

;;; Function definitions

(function_declaration
	(simple_identifier) @function.declaration)

(getter
	("get") @function.builtin)
(setter
	("set") @function.builtin)

(primary_constructor
  "constructor" @keyword
  (class_parameter
    (simple_identifier) @property.class
    (_
      (type_identifier) @type )))

(secondary_constructor
	("constructor") @keyword)

(constructor_delegation_call
	[ "this" "super" ] @keyword)

(constructor_invocation
	(user_type
		(type_identifier) @constructor))

(anonymous_initializer
	("init") @function.invocation)

(parameter
	(simple_identifier) @parameter)

(parameter_with_optional_type
	(simple_identifier) @parameter)

; lambda parameters
(lambda_literal
	(lambda_parameters
		(variable_declaration
			(simple_identifier) @parameter)))

;;; Function calls

; function()
(call_expression
	. (simple_identifier) @function.invocation)

; ::function
(callable_reference
	. (simple_identifier) @function.invocation)

; object.function() or object.property.function()
(call_expression
	(navigation_expression
		(navigation_suffix
			(simple_identifier) @function.invocation) . ))

(call_expression
	. (simple_identifier) @function.builtin
    (#any-of? @function.builtin
		"arrayOf"
		"arrayOfNulls"
		"byteArrayOf"
		"shortArrayOf"
		"intArrayOf"
		"longArrayOf"
		"ubyteArrayOf"
		"ushortArrayOf"
		"uintArrayOf"
		"ulongArrayOf"
		"floatArrayOf"
		"doubleArrayOf"
		"booleanArrayOf"
		"charArrayOf"
		"emptyArray"
		"mapOf"
		"setOf"
		"listOf"
		"emptyMap"
		"emptySet"
		"emptyList"
		"mutableMapOf"
		"mutableSetOf"
		"mutableListOf"
		"print"
		"println"
		"error"
		"TODO"
		"run"
		"runCatching"
		"repeat"
		"lazy"
		"lazyOf"
		"enumValues"
		"enumValueOf"
		"assert"
		"check"
		"checkNotNull"
		"require"
		"requireNotNull"
		"with"
		"suspend"
		"synchronized"
))

;;; Literals

[(line_comment) (multiline_comment)] @comment

(shebang_line) @preproc

(real_literal) @number
[
	(integer_literal)
	(long_literal)
	(hex_literal)
	(bin_literal)
	(unsigned_literal)
] @number

[
	"null" ; should be highlighted the same as booleans
	(boolean_literal)
] @constant.builtin

(character_literal) @string

(string_literal) @string

; There are 3 ways to define a regex
;    - "[abc]?".toRegex()
(call_expression
	(navigation_expression
		((string_literal) @string.regex)
		(navigation_suffix
			((simple_identifier) @_function
			(#eq? @_function "toRegex")))))

;    - Regex("[abc]?")
(call_expression
	((simple_identifier) @_function
	(#eq? @_function "Regex"))
	(call_suffix
		(value_arguments
			(value_argument
				(string_literal) @string.regex))))

;    - Regex.fromLiteral("[abc]?")
(call_expression
	(navigation_expression
		((simple_identifier) @_class
		(#eq? @_class "Regex"))
		(navigation_suffix
			((simple_identifier) @_function
			(#eq? @_function "fromLiteral"))))
	(call_suffix
		(value_arguments
			(value_argument
				(string_literal) @string.regex))))

;;; Keywords

(type_alias "typealias" @keyword)

(companion_object "companion" @keyword)

[
	(class_modifier)
	(member_modifier)
	(function_modifier)
	(property_modifier)
	(platform_modifier)
	(variance_modifier)
	(parameter_modifier)
	(visibility_modifier)
	(reification_modifier)
	(inheritance_modifier)
] @type.qualifier

[
	"val"
	"var"
	"enum"
	"class"
	"object"
	"interface"
	"fun"
;	"typeof" ; NOTE: It is reserved for future use
  "fun"
	"for"
	"do"
	"while"
	"try"
  "catch"
  "throw"
  "finally"
  "if"
  "else"
  "when"
  "return"
  "continue"
  "break"
] @keyword

(label) @label

(annotation
	"@" @attribute (use_site_target)? @attribute)
(annotation
	(user_type
		(type_identifier) @attribute))
(annotation
	(constructor_invocation
		(user_type
			(type_identifier) @attribute)))

(file_annotation
	"@" @attribute "file" @attribute ":" @attribute)
(file_annotation
	(user_type
		(type_identifier) @attribute))
(file_annotation
	(constructor_invocation
		(user_type
			(type_identifier) @attribute)))

;;; Operators & Punctuation

[
	"!"
	"!="
	"!=="
	"="
	"=="
	"==="
	">"
	">="
	"<"
	"<="
	"||"
	"&&"
	"+"
	"++"
	"+="
	"-"
	"--"
	"-="
	"*"
	"*="
	"/"
	"/="
	"%"
	"%="
	"?."
	"?:"
	"!!"
	"is"
	"!is"
	"in"
	"!in"
	"as"
	"as?"
	".."
	"->"
	"."
	","
	";"
	":"
	"::"
] @operator

[
  "(" ")"
  "[" "]"
  "{" "}"
] @bracket


================================================
File: assets/editor/treesitter/kt/locals.scm
================================================
;;; Imports

(package_header
	. (identifier) @definition.namespace)

(import_header
	(identifier
		(simple_identifier) @definition.import .)
	(import_alias
		(type_identifier) @definition.import)?)

;;; Functions

(function_declaration
	. (simple_identifier) @definition.function
	(#set! "definition.function.scope" "parent"))

(class_body
	(function_declaration
		. (simple_identifier) @definition.method)
	(#set! "definition.method.scope" "parent"))

;;; Variables

(function_declaration
    (function_value_parameters
		  (parameter
			  (simple_identifier) @definition.parameter)))

(lambda_literal
	(lambda_parameters
		(variable_declaration
			(simple_identifier) @definition.parameter)))

(property_declaration
		(variable_declaration
			(simple_identifier) @definition.field))

(class_declaration
	(primary_constructor
		(class_parameter
			(simple_identifier) @definition.field)))

(enum_class_body
	(enum_entry
		(simple_identifier) @definition.field))

(variable_declaration
	(simple_identifier) @definition.var)

;;; Scopes

[
	(if_expression)
	(when_expression)
	(when_entry)

	(for_statement)
	(while_statement)
	(do_while_statement)

	(lambda_literal)
	(function_declaration)
	(primary_constructor)
	(secondary_constructor)
	(anonymous_initializer)

	(class_declaration)
	(enum_class_body)
	(enum_entry)

	(interpolated_expression)
] @scope


================================================
File: assets/editor/treesitter/log/highlights.scm
================================================
(begin_header) @header

(log_line
  (date) @err.date
  (time) @err.time
  (pid) @err.pid
  (tid) @err.tid
  (priority) @err.priority
  (tag) @err.tag
  (message) @err.msg
  (#match? @err.priority "E")
)

(log_line
  (date) @warn.date
  (time) @warn.time
  (pid) @warn.pid
  (tid) @warn.tid
  (priority) @warn.priority
  (tag) @warn.tag
  (message) @warn.msg
  (#match? @warn.priority "W")
)

(log_line
  (date) @info.date
  (time) @info.time
  (pid) @info.pid
  (tid) @info.tid
  (priority) @info.priority
  (tag) @info.tag
  (message) @info.msg
  (#match? @info.priority "I")
)

(log_line
  (date) @debug.date
  (time) @debug.time
  (pid) @debug.pid
  (tid) @debug.tid
  (priority) @debug.priority
  (tag) @debug.tag
  (message) @debug.msg
  (#match? @debug.priority "D")
)

(log_line
  (date) @verbose.date
  (time) @verbose.time
  (pid) @verbose.pid
  (tid) @verbose.tid
  (priority) @verbose.priority
  (tag) @verbose.tag
  (message) @verbose.msg
  (#match? @verbose.priority "V")
)

(ide_log_line
  (date) @err.date
  (time) @err.time
  (priority) @err.priority
  (thread_name) @err.thread_name
  (tag) @err.tag
  (message) @err.msg
  (#match? @err.priority "ERROR")
)

(ide_log_line
  (date) @warn.date
  (time) @warn.time
  (priority) @warn.priority
  (thread_name) @warn.thread_name
  (tag) @warn.tag
  (message) @warn.msg
  (#match? @warn.priority "WARN")
)

(ide_log_line
  (date) @info.date
  (time) @info.time
  (priority) @info.priority
  (thread_name) @info.thread_name
  (tag) @info.tag
  (message) @info.msg
  (#match? @info.priority "INFO")
)

(ide_log_line
  (date) @debug.date
  (time) @debug.time
  (priority) @debug.priority
  (thread_name) @debug.thread_name
  (tag) @debug.tag
  (message) @debug.msg
  (#match? @debug.priority "DEBUG")
)

(ide_log_line
  (date) @verbose.date
  (time) @verbose.time
  (priority) @verbose.priority
  (thread_name) @verbose.thread_name
  (tag) @verbose.tag
  (message) @verbose.msg
  (#match? @verbose.priority "TRACE")
)



================================================
File: assets/editor/treesitter/xml/blocks.scm
================================================
; Query for creating code block ranges in sora-editor

(xml_decl) @scope.marked

(end_tag_element) @scope.marked

(empty_element) @scope.marked


================================================
File: assets/editor/treesitter/xml/brackets.scm
================================================
; bracket pair highlights query for sora-editor

; for xml declaration, mark the opening '<?' as brackets open and closing '?>' as brackets close
(xml_decl
  "<?" @editor.brackets.open
  "?>" @editor.brackets.close)

; for empty element tag, mark opening '<' and closing '/>' as brackets open and close
(empty_element
  "<" @editor.brackets.open
  ">" @editor.brackets.close)

; in case of an element which has an end tag
; mark the tag name in tag_start as bracket open
; and the tag name in tag_end as bracket close
(tag_start
  tag_name: (name) @editor.brackets.open)
(tag_end
  tag_name: (name) @editor.brackets.close)

; bracket pairs for CDATA sections
(cdata_start) @editor.brackets.open
(cdata_end) @editor.brackets.close


================================================
File: assets/editor/treesitter/xml/highlights.scm
================================================
(xml_decl
  decl: "xml" @xml_decl)

(xml_version
  version_attr: "version" @attr.name)

(xml_encoding
  encoding_attr: "encoding" @attr.name)

(xml_version_value) @attr.value
(xml_encoding_value) @attr.value

(empty_element
  tag_name: (name) @element.tag)

(tag_start
  tag_name: (name) @element.tag)

(tag_end
  tag_name: (name) @element.tag)

"xmlns" @ns_declarator
(ns_decl
  xmlns_prefix: (name) @xmlns.prefix)

(xml_attr
  ns_prefix: (name) @attr.prefix
  attr_name: (name) @attr.name)

(attr_value) @attr.value

(comment) @comment

(entity_ref) @xml.ref
(char_ref) @xml.ref

(comment) @comment

(cdata_start) @cdata.start
(cdata_end) @cdata.end
(cdata) @cdata.data

(char_data) @text

(eq) @operator

["<" "/" ">" "<?" "?>"] @operator


================================================
File: assets/editor/treesitter/xml/indents.scm
================================================
; Indents query for AndroidIDE

(xml_decl
  "<?" @indent
  "?>" @outdent)

(empty_element
  tag_name: (name) @indent
  ">" @outdent)

(end_tag_element
  (tag_start
    tag_name: (name) @indent)
  (tag_end
    "<" @outdent)
  )


================================================
File: java/com/itsaky/androidide/editor/adapters/CompletionListAdapter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.editor.adapters

import android.content.res.Resources
import android.graphics.Typeface
import android.graphics.drawable.GradientDrawable
import android.text.TextUtils
import android.util.TypedValue
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import com.itsaky.androidide.editor.R
import com.itsaky.androidide.editor.databinding.LayoutCompletionItemBinding
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.lsp.models.ClassCompletionData
import com.itsaky.androidide.lsp.models.CompletionItemKind.CLASS
import com.itsaky.androidide.lsp.models.CompletionItemKind.CONSTRUCTOR
import com.itsaky.androidide.lsp.models.CompletionItemKind.ENUM
import com.itsaky.androidide.lsp.models.CompletionItemKind.FIELD
import com.itsaky.androidide.lsp.models.CompletionItemKind.INTERFACE
import com.itsaky.androidide.lsp.models.CompletionItemKind.METHOD
import com.itsaky.androidide.lsp.models.MemberCompletionData
import com.itsaky.androidide.lsp.models.MethodCompletionData
import com.itsaky.androidide.preferences.internal.EditorPreferences
import com.itsaky.androidide.resources.R.string.msg_api_info_deprecated
import com.itsaky.androidide.resources.R.string.msg_api_info_removed
import com.itsaky.androidide.resources.R.string.msg_api_info_since
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.COMPLETION_WND_TEXT_API
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.COMPLETION_WND_TEXT_DETAIL
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.COMPLETION_WND_TEXT_LABEL
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.COMPLETION_WND_TEXT_TYPE
import com.itsaky.androidide.tasks.executeAsync
import com.itsaky.androidide.utils.customOrJBMono
import com.itsaky.androidide.xml.versions.ApiVersions
import com.itsaky.androidide.xml.versions.Info
import io.github.rosemoe.sora.widget.component.EditorCompletionAdapter
import com.itsaky.androidide.lsp.models.CompletionItem as LspCompletionItem

class CompletionListAdapter : EditorCompletionAdapter() {

  override fun getItemHeight(): Int {
    return TypedValue.applyDimension(
      TypedValue.COMPLEX_UNIT_DIP,
      40f,
      Resources.getSystem().displayMetrics
    )
      .toInt()
  }

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup?,
    isCurrentCursorPosition: Boolean,
  ): View {
    val binding =
      convertView?.let { LayoutCompletionItemBinding.bind(it) }
        ?: LayoutCompletionItemBinding.inflate(LayoutInflater.from(context), parent, false)
    val item = getItem(position) as LspCompletionItem
    val label = item.ideLabel
    val desc = item.detail
    var type: String? = item.completionKind.toString()
    val header = if (type!!.isEmpty()) "O" else type[0].toString()
    if (item.overrideTypeText != null) {
      type = item.overrideTypeText
    }
    binding.completionIconText.text = header
    binding.completionLabel.text = label
    binding.completionType.text = type
    binding.completionDetail.text = desc
    binding.completionIconText.setTypeface(customOrJBMono(EditorPreferences.useCustomFont),
      Typeface.BOLD)
    if (desc.isEmpty()) {
      binding.completionDetail.visibility = View.GONE
    }

    binding.completionApiInfo.visibility = View.GONE

    applyColorScheme(binding, isCurrentCursorPosition)
    showApiInfoIfNeeded(item, binding.completionApiInfo)
    return binding.root
  }

  private fun applyColorScheme(binding: LayoutCompletionItemBinding, isCurrent: Boolean) {
    setItemBackground(binding, isCurrent)
    var color = getThemeColor(COMPLETION_WND_TEXT_LABEL)
    if (color != 0) {
      binding.completionLabel.setTextColor(color)
      binding.completionIconText.setTextColor(color)
    }

    color = getThemeColor(COMPLETION_WND_TEXT_DETAIL)
    if (color != 0) {
      binding.completionDetail.setTextColor(color)
    }

    color = getThemeColor(COMPLETION_WND_TEXT_API)
    if (color != 0) {
      binding.completionApiInfo.setTextColor(color)
    }

    color = getThemeColor(COMPLETION_WND_TEXT_TYPE)
    if (color != 0) {
      binding.completionType.setTextColor(color)
    }
  }

  private fun setItemBackground(binding: LayoutCompletionItemBinding, isCurrent: Boolean) {
    val color =
      if (isCurrent) getThemeColor(SchemeAndroidIDE.COMPLETION_WND_BG_CURRENT_ITEM)
      else 0

    val cornerRadius = binding.root.context.resources
      .getDimensionPixelSize(R.dimen.completion_window_corner_radius).toFloat()

    val gd = GradientDrawable().apply {
      setColor(color)
      setCornerRadius(cornerRadius)
    }

    binding.root.background = gd
  }

  private fun showApiInfoIfNeeded(item: LspCompletionItem, textView: TextView) {
    executeAsync({
      if (!isValidForApiVersion(item)) {
        return@executeAsync null
      }

      val data = item.data
      val versions =
        Lookup.getDefault().lookup(ApiVersions.COMPLETION_LOOKUP_KEY) ?: return@executeAsync null
      val className =
        when (data) {
          is ClassCompletionData -> data.className
          is MemberCompletionData -> data.classInfo.className
          else -> return@executeAsync null
        }
      val kind = item.completionKind

      val clazz = versions.getClass(className) ?: return@executeAsync null
      var info: Info? = clazz

      if (data is MethodCompletionData) {
        if (
          kind == METHOD && data.erasedParameterTypes.isNotEmpty() && data.memberName.isNotBlank()
        ) {
          val method = clazz.getMethod(data.memberName, *data.erasedParameterTypes.toTypedArray())
          if (method != null) {
            info = method
          }
        } else if (kind == FIELD && data.memberName.isNotBlank()) {
          val field = clazz.getField(data.memberName)
          if (field != null) {
            info = field
          }
        }
      }
      val sb = StringBuilder()
      if (info!!.since > 1) {
        sb.append(textView.context.getString(msg_api_info_since, info.since))
        sb.append("\n")
      }

      if (info.removed > 0) {
        sb.append(textView.context.getString(msg_api_info_removed, info.removed))
        sb.append("\n")
      }

      if (info.deprecated > 0) {
        sb.append(textView.context.getString(msg_api_info_deprecated, info.deprecated))
        sb.append("\n")
      }

      return@executeAsync sb
    }) {
      if (it.isNullOrBlank()) {
        textView.visibility = View.GONE
        return@executeAsync
      }

      textView.text = it
      textView.visibility = View.VISIBLE
    }
  }

  private fun isValidForApiVersion(item: LspCompletionItem?): Boolean {
    if (item == null) {
      return false
    }
    val type = item.completionKind
    val data = item.data
    return if ( // These represent a class type
      (type === CLASS ||
          type === INTERFACE ||
          type === ENUM ||

          // These represent a method type
          type === METHOD ||
          type === CONSTRUCTOR ||

          // A field type
          type === FIELD) && data != null
    ) {
      val className =
        when (data) {
          is ClassCompletionData -> data.className
          is MemberCompletionData -> data.classInfo.className
          else -> null
        }
      !TextUtils.isEmpty(className)
    } else false
  }
}



================================================
File: java/com/itsaky/androidide/editor/events/FileUpdateEvent.kt
================================================
package com.itsaky.androidide.editor.events

import io.github.rosemoe.sora.event.Event
import io.github.rosemoe.sora.widget.CodeEditor
import java.io.File

class FileUpdateEvent(val file: File?, editor: CodeEditor): Event(editor)


================================================
File: java/com/itsaky/androidide/editor/events/LanguageUpdateEvent.kt
================================================
package com.itsaky.androidide.editor.events

import io.github.rosemoe.sora.event.Event
import io.github.rosemoe.sora.lang.Language
import io.github.rosemoe.sora.widget.CodeEditor

class LanguageUpdateEvent(val language: Language?, editor: CodeEditor) : Event(editor)


================================================
File: java/com/itsaky/androidide/editor/language/CommonCompletionProvider.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.editor.language

import com.itsaky.androidide.editor.language.utils.CompletionHelper
import com.itsaky.androidide.lsp.api.ILanguageServer
import com.itsaky.androidide.lsp.models.CompletionItem
import com.itsaky.androidide.lsp.models.CompletionParams
import com.itsaky.androidide.lsp.models.CompletionResult
import com.itsaky.androidide.lsp.models.FailureType.COMPLETION
import com.itsaky.androidide.lsp.models.LSPFailure
import com.itsaky.androidide.lsp.util.setupLookupForCompletion
import com.itsaky.androidide.models.Position
import io.github.rosemoe.sora.lang.completion.CompletionCancelledException
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.ContentReference
import org.slf4j.LoggerFactory
import java.nio.file.Path
import java.util.concurrent.CancellationException

/**
 * Common implementation of completion provider which requests completions to provided language
 * server.
 *
 * @author Akash Yadav
 */
internal class CommonCompletionProvider(
  private val server: ILanguageServer,
  private val cancelChecker: CompletionCancelChecker
) {

  companion object {

    private val log = LoggerFactory.getLogger(CommonCompletionProvider::class.java)
  }

  /**
   * Computes completion items using the provided language server instance.
   *
   * @param content The reference to the content of the editor.
   * @param file The file to compute completions for.
   * @param position The position of the cursor in the content.
   * @return The computed completion items. May return an empty list if the there was an error
   * computing the completion items.
   */
  inline fun complete(
    content: ContentReference,
    file: Path,
    position: CharPosition,
    prefixMatcher: (Char) -> Boolean
  ): List<CompletionItem> {
    val completionResult =
      try {
        setupLookupForCompletion(file)
        val prefix = CompletionHelper.computePrefix(content, position, prefixMatcher)
        val params =
          CompletionParams(Position(position.line, position.column, position.index), file,
            cancelChecker)
        params.content = content
        params.prefix = prefix
        server.complete(params)
      } catch (e: Throwable) {

        if (e is CancellationException) {
          log.debug("Completion process cancelled")
        }

        // Do not log if completion was interrupted or cancelled
        if (!(e is CancellationException || e is CompletionCancelledException)) {
          if (!server.handleFailure(LSPFailure(COMPLETION, e))) {
            log.error("Unable to compute completions", e)
          }
        }
        CompletionResult.EMPTY
      }

    if (completionResult == CompletionResult.EMPTY) {
      return listOf()
    }

    return completionResult.items
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/CompletionCancelChecker.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language

import com.itsaky.androidide.progress.ICancelChecker
import io.github.rosemoe.sora.lang.completion.CompletionCancelledException
import io.github.rosemoe.sora.lang.completion.CompletionPublisher

/**
 * [CompletionPublisher] implementation which exposes the `checkCancelled` method.
 *
 * @author Akash Yadav
 */
class CompletionCancelChecker(private val publisher: CompletionPublisher) :
  ICancelChecker.Default() {

  /** Check if the completion is cancelled. */
  @Throws(CompletionCancelledException::class)
  override fun abortIfCancelled() {
    publisher.checkCancelled()
    super.abortIfCancelled()
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/IDELanguage.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.editor.language

import android.os.Bundle
import com.itsaky.androidide.editor.api.IEditor
import com.itsaky.androidide.editor.ui.IDECompletionPublisher
import com.itsaky.androidide.lookup.Lookup
import com.itsaky.androidide.lsp.api.ILanguageServer
import com.itsaky.androidide.lsp.debug.model.BreakpointDefinition
import com.itsaky.androidide.lsp.debug.model.BreakpointRequest
import com.itsaky.androidide.preferences.internal.EditorPreferences
import com.itsaky.androidide.progress.ICancelChecker
import io.github.rosemoe.sora.lang.Language
import io.github.rosemoe.sora.lang.completion.CompletionCancelledException
import io.github.rosemoe.sora.lang.completion.CompletionPublisher
import io.github.rosemoe.sora.lang.format.Formatter
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.ContentReference
import org.slf4j.LoggerFactory
import java.io.File
import java.nio.file.Paths

/**
 * Base class for language implementations in the IDE.
 *
 * @author Akash Yadav
 */
abstract class IDELanguage : Language {

  private var formatter: Formatter? = null

  protected open val languageServer: ILanguageServer?
    get() = null

  open fun getTabSize(): Int {
    return EditorPreferences.tabSize
  }

  open fun addBreakpoint(line: Int) {}
  open fun addBreakpoints(lines: Iterable<Int>) = lines.forEach(::addBreakpoint)
  open fun removeBreakpoint(line: Int) {}
  open fun removeBreakpoints(lines: Iterable<Int>) = lines.forEach(::removeBreakpoint)
  open fun removeAllBreakpoints() {}
  open fun toggleBreakpoint(line: Int) {}
  open fun highlightLine(line: Int) {}
  open fun unhighlightLines() {}

  @Throws(CompletionCancelledException::class)
  override fun requireAutoComplete(
    content: ContentReference,
    position: CharPosition,
    publisher: CompletionPublisher,
    extraArguments: Bundle
  ) {
    try {
      val cancelChecker = CompletionCancelChecker(publisher)
      Lookup.getDefault().register(ICancelChecker::class.java, cancelChecker)
      doComplete(content, position, publisher, cancelChecker, extraArguments)
    } finally {
      Lookup.getDefault().unregister(
        ICancelChecker::class.java)
    }
  }

  private fun doComplete(
    content: ContentReference,
    position: CharPosition,
    publisher: CompletionPublisher,
    cancelChecker: CompletionCancelChecker,
    extraArguments: Bundle
  ) {
    val server = languageServer ?: return
    val path = extraArguments.getString(IEditor.KEY_FILE, null)
    if (path == null) {
      log.warn("Cannot provide completions. No file provided.")
      return
    }

    val completionProvider = CommonCompletionProvider(server, cancelChecker)
    val file = Paths.get(path)
    val completionItems = completionProvider.complete(content, file,
      position) { checkIsCompletionChar(it) }
    publisher.setUpdateThreshold(1)
    (publisher as IDECompletionPublisher).addLSPItems(completionItems)
  }

  /**
   * Check if the given character is a completion character.
   *
   * @param c The character to check.
   * @return `true` if the character is completion char, `false` otherwise.
   */
  protected open fun checkIsCompletionChar(c: Char): Boolean {
    return false
  }

  override fun useTab(): Boolean {
    return !EditorPreferences.useSoftTab
  }

  override fun getFormatter(): Formatter {
    return formatter ?: LSPFormatter(languageServer).also { formatter = it }
  }

  override fun getIndentAdvance(
    content: ContentReference,
    line: Int,
    column: Int
  ): Int {
    return getIndentAdvance(content.getLine(line).substring(0, column))
  }

  open fun getIndentAdvance(line: String): Int {
    return 0
  }

  companion object {

    private val log = LoggerFactory.getLogger(IDELanguage::class.java)
  }
}


================================================
File: java/com/itsaky/androidide/editor/language/LSPFormatter.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language

import com.itsaky.androidide.lsp.api.ILanguageServer
import com.itsaky.androidide.lsp.models.CodeFormatResult
import com.itsaky.androidide.lsp.models.FormatCodeParams
import com.itsaky.androidide.models.Position
import com.itsaky.androidide.models.Range
import io.github.rosemoe.sora.lang.format.AsyncFormatter
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.text.TextRange

/**
 * An [AsyncFormatter] implementation which uses the LSP implementation to format code.
 *
 * @author Akash Yadav
 */
class LSPFormatter(val server: ILanguageServer? = null) : AsyncFormatter() {
  
  override fun formatAsync(text: Content, cursorRange: TextRange): TextRange {
    return doFormat(text, cursorRange)
  }

  override fun formatRegionAsync(
    text: Content,
    rangeToFormat: TextRange,
    cursorRange: TextRange
  ): TextRange {
    return doFormat(text, cursorRange, rangeToFormat)
  }

  private fun doFormat(
    text: Content,
    cursorRange: TextRange,
    rangeToFormat: TextRange? = null
  ): TextRange {
    if (server == null) {
      return cursorRange
    }

    val range =
      (rangeToFormat?.asRange() ?: text.wholeRange()).apply {
        start.apply {
          index = (if (line == 0 && column == 0) 0 else text.getCharIndex(line, column))
        }
        end.apply { index = (if (line == 0 && column == 0) 0 else text.getCharIndex(line, column)) }
      }
    val result = server.formatCode(FormatCodeParams(text, range))

    if (!result.hasEdits() ) {
      // Deselect the selected content
      return TextRange(cursorRange.start, cursorRange.start)
    }

    if (result.isIndexed) {
      result.indexedTextEdits.forEach { text.replace(it.start, it.end, it.newText) }
    } else {
      result.edits.forEach {
        text.replace(
          it.range.start.line,
          it.range.start.column,
          it.range.end.line,
          it.range.end.column,
          it.newText
        )
      }
    }
    // Deselect the selected content
    return TextRange(cursorRange.start, cursorRange.start)
  }
}

private fun CodeFormatResult.hasEdits() =
  this.indexedTextEdits.isNotEmpty() || this.edits.isNotEmpty()

private fun TextRange.asRange(): Range {
  return Range().also {
    it.start = this.start.asPosition()
    it.end = this.end.asPosition()
  }
}

private fun Content.wholeRange(): Range {
  return Range(Position(0, 0), Position(lineCount - 1, getColumnCount(lineCount - 1)))
}

private fun CharPosition.asPosition(): Position {
  return Position(this.line, this.column, this.index)
}

private fun Range.asTextRange(): TextRange {
  return TextRange(this.start.asCharPosition(), this.end.asCharPosition())
}

private fun Position.asCharPosition(): CharPosition {
  return CharPosition().also {
    it.line = this.line
    it.column = this.column
    it.index = this.index
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/cpp/CppAnalyzer.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.cpp;

import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.LITERAL;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.OPERATOR;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.TEXT_NORMAL;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.TYPE_NAME;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.forComment;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.forKeyword;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.forString;
import static io.github.rosemoe.sora.lang.styling.TextStyle.makeStyle;

import com.itsaky.androidide.editor.language.incremental.BaseIncrementalAnalyzeManager;
import com.itsaky.androidide.editor.language.incremental.IncrementalToken;
import com.itsaky.androidide.editor.language.incremental.LineState;
import com.itsaky.androidide.lexers.cpp.CPP14Lexer;
import io.github.rosemoe.sora.lang.styling.Span;
import java.util.ArrayList;
import java.util.List;

public class CppAnalyzer extends BaseIncrementalAnalyzeManager {

  public CppAnalyzer() {
    super(CPP14Lexer.class);
  }

  @Override
  protected int[][] getMultilineTokenStartEndTypes() {
    final var start = new int[]{CPP14Lexer.Div, CPP14Lexer.Star};
    final var end = new int[]{CPP14Lexer.Star, CPP14Lexer.Div};
    return new int[][]{start, end};
  }

  @Override
  protected List<Span> generateSpans(final LineTokenizeResult<LineState, IncrementalToken> tokens) {
    final var spans = new ArrayList<Span>();
    spans.add(Span.obtain(0, makeStyle(TEXT_NORMAL)));
    for (int i = 0; i < tokens.tokens.size(); i++) {
      final var token = tokens.tokens.get(i);
      final var type = token.getType();
      final var offset = token.getStartIndex();

      switch (type) {
        case CPP14Lexer.Alignas:
        case CPP14Lexer.Alignof:
        case CPP14Lexer.Asm:
        case CPP14Lexer.Auto:
        case CPP14Lexer.Break:
        case CPP14Lexer.Class:
        case CPP14Lexer.Const:
        case CPP14Lexer.Catch:
        case CPP14Lexer.Case:
        case CPP14Lexer.Constexpr:
        case CPP14Lexer.Const_cast:
        case CPP14Lexer.Continue:
        case CPP14Lexer.Decltype:
        case CPP14Lexer.Default:
        case CPP14Lexer.Delete:
        case CPP14Lexer.Do:
        case CPP14Lexer.Dynamic_cast:
        case CPP14Lexer.Else:
        case CPP14Lexer.Enum:
        case CPP14Lexer.Explicit:
        case CPP14Lexer.Export:
        case CPP14Lexer.Extern:
        case CPP14Lexer.Final:
        case CPP14Lexer.For:
        case CPP14Lexer.Friend:
        case CPP14Lexer.Goto:
        case CPP14Lexer.If:
        case CPP14Lexer.Inline:
        case CPP14Lexer.Mutable:
        case CPP14Lexer.Namespace:
        case CPP14Lexer.New:
        case CPP14Lexer.Noexcept:
        case CPP14Lexer.Operator:
        case CPP14Lexer.Override:
        case CPP14Lexer.Private:
        case CPP14Lexer.Protected:
        case CPP14Lexer.Public:
        case CPP14Lexer.Register:
        case CPP14Lexer.Reinterpret_cast:
        case CPP14Lexer.Return:
        case CPP14Lexer.Sizeof:
        case CPP14Lexer.Signed:
        case CPP14Lexer.Static:
        case CPP14Lexer.Static_cast:
        case CPP14Lexer.Static_assert:
        case CPP14Lexer.Struct:
        case CPP14Lexer.Switch:
        case CPP14Lexer.Template:
        case CPP14Lexer.This:
        case CPP14Lexer.Throw:
        case CPP14Lexer.Thread_local:
        case CPP14Lexer.Try:
        case CPP14Lexer.Typedef:
        case CPP14Lexer.Typeid_:
        case CPP14Lexer.Typename_:
        case CPP14Lexer.Unsigned:
        case CPP14Lexer.Union:
        case CPP14Lexer.Using:
        case CPP14Lexer.Virtual:
        case CPP14Lexer.Volatile:
        case CPP14Lexer.While:
        case CPP14Lexer.Void:
          spans.add(Span.obtain(offset, forKeyword()));
          break;
        case CPP14Lexer.Bool:
        case CPP14Lexer.Char:
        case CPP14Lexer.Char16:
        case CPP14Lexer.Char32:
        case CPP14Lexer.Double:
        case CPP14Lexer.Float:
        case CPP14Lexer.Int:
        case CPP14Lexer.Long:
        case CPP14Lexer.Short:
        case CPP14Lexer.Wchar:
          spans.add(Span.obtain(offset, makeStyle(TYPE_NAME)));
          break;
        case CPP14Lexer.LeftParen:
        case CPP14Lexer.LeftBracket:
        case CPP14Lexer.LeftBrace:
        case CPP14Lexer.Dot:
        case CPP14Lexer.RightParen:
        case CPP14Lexer.RightBracket:
        case CPP14Lexer.RightBrace:
        case CPP14Lexer.Semi:
        case CPP14Lexer.Comma:
        case CPP14Lexer.Plus:
        case CPP14Lexer.Minus:
        case CPP14Lexer.Star:
        case CPP14Lexer.Div:
        case CPP14Lexer.Mod:
        case CPP14Lexer.Caret:
        case CPP14Lexer.And:
        case CPP14Lexer.Or:
        case CPP14Lexer.Tilde:
        case CPP14Lexer.Not:
        case CPP14Lexer.Assign:
        case CPP14Lexer.Less:
        case CPP14Lexer.Greater:
        case CPP14Lexer.PlusAssign:
        case CPP14Lexer.MinusAssign:
        case CPP14Lexer.StarAssign:
        case CPP14Lexer.DivAssign:
        case CPP14Lexer.ModAssign:
        case CPP14Lexer.XorAssign:
        case CPP14Lexer.AndAssign:
        case CPP14Lexer.OrAssign:
        case CPP14Lexer.RightShiftAssign:
        case CPP14Lexer.LeftShiftAssign:
        case CPP14Lexer.Equal:
        case CPP14Lexer.NotEqual:
        case CPP14Lexer.LessEqual:
        case CPP14Lexer.GreaterEqual:
        case CPP14Lexer.AndAnd:
        case CPP14Lexer.OrOr:
        case CPP14Lexer.PlusPlus:
        case CPP14Lexer.MinusMinus:
        case CPP14Lexer.Arrow:
        case CPP14Lexer.ArrowStar:
        case CPP14Lexer.Question:
        case CPP14Lexer.Colon:
        case CPP14Lexer.Doublecolon:
        case CPP14Lexer.DotStar:
        case CPP14Lexer.Ellipsis:
          spans.add(Span.obtain(offset, makeStyle(OPERATOR)));
          break;
        case CPP14Lexer.IntegerLiteral:
        case CPP14Lexer.DecimalLiteral:
        case CPP14Lexer.OctalLiteral:
        case CPP14Lexer.HexadecimalLiteral:
        case CPP14Lexer.BinaryLiteral:
        case CPP14Lexer.Integersuffix:
        case CPP14Lexer.CharacterLiteral:
        case CPP14Lexer.FloatingLiteral:
        case CPP14Lexer.BooleanLiteral:
        case CPP14Lexer.Nullptr:
        case CPP14Lexer.True_:
        case CPP14Lexer.False_:
          spans.add(Span.obtain(offset, makeStyle(LITERAL)));
          break;
        case CPP14Lexer.StringLiteral:
        case CPP14Lexer.MultiLineMacro:
        case CPP14Lexer.Directive:
          spans.add(Span.obtain(offset, forString()));
          break;
        case CPP14Lexer.BlockComment:
          spans.add(Span.obtain(offset, forComment()));
          break;
        case CPP14Lexer.LineComment:
          handleLineCommentSpan(token, spans, offset);
          break;
        default:
          spans.add(Span.obtain(offset, makeStyle(TEXT_NORMAL)));
          break;
      }
    }
    return spans;
  }

  @Override
  protected void handleIncompleteToken(final IncrementalToken token) {
    token.type = CPP14Lexer.BlockComment;
  }

  @Override
  protected int[] getCodeBlockTokens() {
    return new int[]{CPP14Lexer.LeftBrace, CPP14Lexer.RightBrace};
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/cpp/CppLanguage.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.editor.language.cpp;

import android.os.Bundle;
import androidx.annotation.NonNull;
import com.itsaky.androidide.editor.language.IDELanguage;
import com.itsaky.androidide.editor.language.newline.BracketsNewlineHandler;
import com.itsaky.androidide.editor.language.utils.CommonSymbolPairs;
import com.itsaky.androidide.lexers.cpp.CPP14Lexer;
import io.github.rosemoe.sora.lang.analysis.AnalyzeManager;
import io.github.rosemoe.sora.lang.completion.CompletionCancelledException;
import io.github.rosemoe.sora.lang.completion.CompletionPublisher;
import io.github.rosemoe.sora.lang.smartEnter.NewlineHandler;
import io.github.rosemoe.sora.text.CharPosition;
import io.github.rosemoe.sora.text.ContentReference;
import io.github.rosemoe.sora.widget.SymbolPairMatch;
import java.io.StringReader;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.Token;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CppLanguage extends IDELanguage {

  private static final Logger LOG = LoggerFactory.getLogger(CppLanguage.class);
  private final NewlineHandler[] newlineHandlers =
      new NewlineHandler[]{new BracketsNewlineHandler(this::getIndentAdvance, this::useTab)};
  private final CommonSymbolPairs symbolPairs = new CommonSymbolPairs();
  private CppAnalyzer analyzer;

  public CppLanguage() {
    analyzer = new CppAnalyzer();
  }

  @NonNull
  @Override
  public AnalyzeManager getAnalyzeManager() {
    return analyzer;
  }

  @Override
  public int getInterruptionLevel() {
    return INTERRUPTION_LEVEL_STRONG;
  }

  @Override
  public void requireAutoComplete(
      @NonNull ContentReference content,
      @NonNull CharPosition position,
      @NonNull CompletionPublisher publisher,
      @NonNull Bundle extraArguments)
      throws CompletionCancelledException {

    //  completer.complete(content, position, publisher, extraArguments);
  }

  @Override
  public int getIndentAdvance(@NonNull ContentReference content, int line, int column) {
    return getIndentAdvance(content.getLine(line).substring(0, column));
  }

  @Override
  public SymbolPairMatch getSymbolPairs() {
    return symbolPairs;
  }

  @Override
  public NewlineHandler[] getNewlineHandlers() {
    return newlineHandlers;
  }

  @Override
  public void destroy() {
    analyzer = null;
  }

  @Override
  public int getIndentAdvance(@NonNull String line) {
    try {
      CPP14Lexer lexer = new CPP14Lexer(CharStreams.fromReader(new StringReader(line)));
      Token token;
      int advance = 0;
      while (((token = lexer.nextToken()) != null && token.getType() != token.EOF)) {
        switch (token.getType()) {
          case CPP14Lexer.LeftBrace:
            advance++;
            break;
          case CPP14Lexer.RightBrace:
            advance--;
            break;
        }
      }
      advance = Math.max(0, advance);
      return advance * getTabSize();
    } catch (Throwable e) {
      LOG.error("Error calculating indent advance", e);
    }
    return 0;
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/groovy/GroovyAnalyzer.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.groovy

import com.itsaky.androidide.editor.language.incremental.BaseIncrementalAnalyzeManager
import com.itsaky.androidide.editor.language.incremental.IncrementalToken
import com.itsaky.androidide.editor.language.incremental.LineState
import com.itsaky.androidide.lexers.groovy.GroovyLexer
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import io.github.rosemoe.sora.lang.analysis.IncrementalAnalyzeManager.LineTokenizeResult
import io.github.rosemoe.sora.lang.styling.Span
import io.github.rosemoe.sora.lang.styling.SpanFactory
import io.github.rosemoe.sora.lang.styling.TextStyle

/** @author Akash Yadav */
class GroovyAnalyzer : BaseIncrementalAnalyzeManager(GroovyLexer::class.java) {

  override fun getCodeBlockTokens() = intArrayOf(GroovyLexer.LBRACE, GroovyLexer.RBRACE)

  override fun generateSpans(
    tokens: LineTokenizeResult<LineState, IncrementalToken>,
  ): List<Span> {
    val spans = mutableListOf<Span>()
    var previous = GroovyLexer.WS
    var first = true
    for (token in tokens.tokens) {
      val type = token.type
      val offset = token.startIndex
      when (type) {
        GroovyLexer.WS -> {
          if (first) {
            spans.add(SpanFactory.obtain(offset, TextStyle.makeStyle(SchemeAndroidIDE.TEXT_NORMAL)))
            first = false
          }
        }

        GroovyLexer.ABSTRACT,
        GroovyLexer.ASSERT,
        GroovyLexer.BREAK,
        GroovyLexer.CASE,
        GroovyLexer.CATCH,
        GroovyLexer.CLASS,
        GroovyLexer.CONST,
        GroovyLexer.CONTINUE,
        GroovyLexer.DEFAULT,
        GroovyLexer.DO,
        GroovyLexer.ELSE,
        GroovyLexer.EXTENDS,
        GroovyLexer.FINAL,
        GroovyLexer.FINALLY,
        GroovyLexer.FOR,
        GroovyLexer.IF,
        GroovyLexer.GOTO,
        GroovyLexer.IMPLEMENTS,
        GroovyLexer.IMPORT,
        GroovyLexer.INSTANCEOF,
        GroovyLexer.INTERFACE,
        GroovyLexer.NATIVE,
        GroovyLexer.NEW,
        GroovyLexer.PACKAGE,
        GroovyLexer.PRIVATE,
        GroovyLexer.PROTECTED,
        GroovyLexer.PUBLIC,
        GroovyLexer.RETURN,
        GroovyLexer.STATIC,
        GroovyLexer.STRICTFP,
        GroovyLexer.SUPER,
        GroovyLexer.SWITCH,
        GroovyLexer.SYNCHRONIZED,
        GroovyLexer.THIS,
        GroovyLexer.THROW,
        GroovyLexer.THROWS,
        GroovyLexer.TRANSIENT,
        GroovyLexer.TRY,
        GroovyLexer.VOID,
        GroovyLexer.VOLATILE,
        GroovyLexer.WHILE -> spans.add(SpanFactory.obtain(offset, SchemeAndroidIDE.forKeyword()))

        GroovyLexer.DECIMAL_LITERAL,
        GroovyLexer.HEX_LITERAL,
        GroovyLexer.OCT_LITERAL,
        GroovyLexer.BINARY_LITERAL,
        GroovyLexer.FLOAT_LITERAL,
        GroovyLexer.HEX_FLOAT_LITERAL,
        GroovyLexer.BOOL_LITERAL,
        GroovyLexer.CHAR_LITERAL,
        GroovyLexer.NULL_LITERAL,
        ->
          spans.add(SpanFactory.obtain(offset, TextStyle.makeStyle(SchemeAndroidIDE.LITERAL)))

        GroovyLexer.SINGLE_QUOTE_STRING,
        GroovyLexer.STRING_LITERAL -> spans.add(
          SpanFactory.obtain(offset, SchemeAndroidIDE.forString()))

        GroovyLexer.LPAREN,
        GroovyLexer.RPAREN,
        GroovyLexer.LBRACK,
        GroovyLexer.RBRACK,
        GroovyLexer.SEMI,
        GroovyLexer.COMMA,
        GroovyLexer.ASSIGN,
        GroovyLexer.GT,
        GroovyLexer.LT,
        GroovyLexer.BANG,
        GroovyLexer.TILDE,
        GroovyLexer.QUESTION,
        GroovyLexer.COLON,
        GroovyLexer.EQUAL,
        GroovyLexer.GE,
        GroovyLexer.LE,
        GroovyLexer.NOTEQUAL,
        GroovyLexer.AND,
        GroovyLexer.OR,
        GroovyLexer.INC,
        GroovyLexer.DEC,
        GroovyLexer.ADD,
        GroovyLexer.SUB,
        GroovyLexer.MUL,
        GroovyLexer.DIV,
        GroovyLexer.BITAND,
        GroovyLexer.BITOR,
        GroovyLexer.CARET,
        GroovyLexer.MOD,
        GroovyLexer.ADD_ASSIGN,
        GroovyLexer.SUB_ASSIGN,
        GroovyLexer.MUL_ASSIGN,
        GroovyLexer.DIV_ASSIGN,
        GroovyLexer.AND_ASSIGN,
        GroovyLexer.OR_ASSIGN,
        GroovyLexer.XOR_ASSIGN,
        GroovyLexer.MOD_ASSIGN,
        GroovyLexer.LSHIFT_ASSIGN,
        GroovyLexer.RSHIFT_ASSIGN,
        GroovyLexer.URSHIFT_ASSIGN,
        GroovyLexer.ARROW,
        GroovyLexer.COLONCOLON,
        GroovyLexer.ELLIPSIS,
        GroovyLexer.LBRACE,
        GroovyLexer.RBRACE,
        GroovyLexer.DOT,
        ->
          spans.add(SpanFactory.obtain(offset, TextStyle.makeStyle(SchemeAndroidIDE.OPERATOR)))

        GroovyLexer.BOOLEAN,
        GroovyLexer.BYTE,
        GroovyLexer.CHAR,
        GroovyLexer.DOUBLE,
        GroovyLexer.ENUM,
        GroovyLexer.FLOAT,
        GroovyLexer.INT,
        GroovyLexer.LONG,
        GroovyLexer.SHORT,
        ->
          spans.add(SpanFactory.obtain(offset, TextStyle.makeStyle(SchemeAndroidIDE.TYPE_NAME)))

        GroovyLexer.COMMENT -> spans.add(SpanFactory.obtain(offset, SchemeAndroidIDE.forComment()))
        GroovyLexer.LINE_COMMENT -> handleLineCommentSpan(token, spans, offset)
        GroovyLexer.AT ->
          spans.add(SpanFactory.obtain(offset, TextStyle.makeStyle(SchemeAndroidIDE.ANNOTATION)))

        GroovyLexer.IDENTIFIER -> {
          var colorId = SchemeAndroidIDE.TEXT_NORMAL
          if (previous == GroovyLexer.AT) {
            colorId = SchemeAndroidIDE.ANNOTATION
          }
          spans.add(SpanFactory.obtain(offset, TextStyle.makeStyle(colorId)))
        }

        else -> spans.add(
          SpanFactory.obtain(offset, TextStyle.makeStyle(SchemeAndroidIDE.TEXT_NORMAL)))
      }
      previous = type
    }

    return spans
  }

  override fun getMultilineTokenStartEndTypes(): Array<IntArray> {
    val start = intArrayOf(GroovyLexer.DIV, GroovyLexer.MUL)
    val end = intArrayOf(GroovyLexer.MUL, GroovyLexer.DIV)
    return arrayOf(start, end)
  }

  override fun handleIncompleteToken(token: IncrementalToken) {
    token.type = GroovyLexer.COMMENT
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/groovy/GroovyAutoComplete.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.editor.language.groovy;

import android.os.Bundle;
import com.blankj.utilcode.util.StringUtils;
import com.itsaky.androidide.lsp.models.CompletionItem;
import com.itsaky.androidide.lsp.models.CompletionItemKind;
import com.itsaky.androidide.lsp.models.InsertTextFormat;
import io.github.rosemoe.sora.lang.completion.CompletionHelper;
import io.github.rosemoe.sora.lang.completion.CompletionPublisher;
import io.github.rosemoe.sora.text.CharPosition;
import io.github.rosemoe.sora.text.ContentReference;
import io.github.rosemoe.sora.util.MyCharacter;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

public class GroovyAutoComplete {

  private static final List<String> ANDROIDX_ARTIFACTS = createArtifacts();
  private static final List<String> CONFIGURATIONS = createConfigs();
  private static final List<String> OTHERS = createOtherCompletions();

  private static List<String> createArtifacts() {
    var artifacts = new ArrayList<String>();
    artifacts.add("androidx.arch.core:core-common");
    artifacts.add("androidx.arch.core:core");
    artifacts.add("androidx.arch.core:core-testing");
    artifacts.add("androidx.arch.core:core-runtime");
    artifacts.add("androidx.lifecycle:lifecycle-common");
    artifacts.add("androidx.lifecycle:lifecycle-common-java8");
    artifacts.add("androidx.lifecycle:lifecycle-compiler");
    artifacts.add("androidx.lifecycle:lifecycle-extensions");
    artifacts.add("androidx.lifecycle:lifecycle-livedata");
    artifacts.add("androidx.lifecycle:lifecycle-livedata-core");
    artifacts.add("androidx.lifecycle:lifecycle-reactivestreams");
    artifacts.add("androidx.lifecycle:lifecycle-runtime");
    artifacts.add("androidx.lifecycle:lifecycle-viewmodel");
    artifacts.add("androidx.paging:paging-common");
    artifacts.add("androidx.paging:paging-runtime");
    artifacts.add("androidx.paging:paging-rxjava2");
    artifacts.add("androidx.room:room-common");
    artifacts.add("androidx.room:room-compiler");
    artifacts.add("androidx.room:room-guava");
    artifacts.add("androidx.room:room-migration");
    artifacts.add("androidx.room:room-runtime");
    artifacts.add("androidx.room:room-rxjava2");
    artifacts.add("androidx.room:room-testing");
    artifacts.add("androidx.sqlite:sqlite");
    artifacts.add("androidx.sqlite:sqlite-framework");
    artifacts.add("androidx.constraintlayout:constraintlayout");
    artifacts.add("androidx.constraintlayout:constraintlayout-solver");
    artifacts.add("androidx.test.espresso.idling:idling-concurrent");
    artifacts.add("androidx.test.espresso.idling:idling-net");
    artifacts.add("androidx.test.espresso:espresso-accessibility");
    artifacts.add("androidx.test.espresso:espresso-contrib");
    artifacts.add("androidx.test.espresso:espresso-core");
    artifacts.add("androidx.test.espresso:espresso-idling-resource");
    artifacts.add("androidx.test.espresso:espresso-intents");
    artifacts.add("androidx.test.espresso:espresso-remote");
    artifacts.add("androidx.test.espresso:espresso-web");
    artifacts.add("androidx.test.jank:janktesthelper");
    artifacts.add("androidx.test:test-services");
    artifacts.add("androidx.test.uiautomator:uiautomator");
    artifacts.add("androidx.test:monitor");
    artifacts.add("androidx.test:orchestrator");
    artifacts.add("androidx.test:rules");
    artifacts.add("androidx.test:runner");
    artifacts.add("androidx.vectordrawable:vectordrawable-animated");
    artifacts.add("androidx.appcompat:appcompat");
    artifacts.add("androidx.asynclayoutinflater:asynclayoutinflater");
    artifacts.add("androidx.car:car");
    artifacts.add("androidx.cardview:cardview");
    artifacts.add("androidx.collection:collection");
    artifacts.add("androidx.coordinatorlayout:coordinatorlayout");
    artifacts.add("androidx.cursoradapter:cursoradapter");
    artifacts.add("androidx.browser:browser");
    artifacts.add("androidx.customview:customview");
    artifacts.add("com.google.android.material:material");
    artifacts.add("androidx.documentfile:documentfile");
    artifacts.add("androidx.drawerlayout:drawerlayout");
    artifacts.add("androidx.exifinterface:exifinterface");
    artifacts.add("androidx.gridlayout:gridlayout");
    artifacts.add("androidx.heifwriter:heifwriter");
    artifacts.add("androidx.interpolator:interpolator");
    artifacts.add("androidx.leanback:leanback");
    artifacts.add("androidx.loader:loader");
    artifacts.add("androidx.localbroadcastmanager:localbroadcastmanager");
    artifacts.add("androidx.media2:media2");
    artifacts.add("androidx.media2:media2-exoplayer");
    artifacts.add("androidx.mediarouter:mediarouter");
    artifacts.add("androidx.multidex:multidex");
    artifacts.add("androidx.multidex:multidex-instrumentation");
    artifacts.add("androidx.palette:palette");
    artifacts.add("androidx.percentlayout:percentlayout");
    artifacts.add("androidx.leanback:leanback-preference");
    artifacts.add("androidx.legacy:legacy-preference-v14");
    artifacts.add("androidx.preference:preference");
    artifacts.add("androidx.print:print");
    artifacts.add("androidx.recommendation:recommendation");
    artifacts.add("androidx.recyclerview:recyclerview-selection");
    artifacts.add("androidx.recyclerview:recyclerview");
    artifacts.add("androidx.slice:slice-builders");
    artifacts.add("androidx.slice:slice-core");
    artifacts.add("androidx.slice:slice-view");
    artifacts.add("androidx.slidingpanelayout:slidingpanelayout");
    artifacts.add("androidx.annotation:annotation");
    artifacts.add("androidx.core:core");
    artifacts.add("androidx.contentpager:contentpager");
    artifacts.add("androidx.legacy:legacy-support-core-ui");
    artifacts.add("androidx.legacy:legacy-support-core-utils");
    artifacts.add("androidx.dynamicanimation:dynamicanimation");
    artifacts.add("androidx.emoji:emoji");
    artifacts.add("androidx.emoji:emoji-appcompat");
    artifacts.add("androidx.emoji:emoji-bundled");
    artifacts.add("androidx.fragment:fragment");
    artifacts.add("androidx.media:media");
    artifacts.add("androidx.tvprovider:tvprovider");
    artifacts.add("androidx.legacy:legacy-support-v13");
    artifacts.add("androidx.legacy:legacy-support-v4");
    artifacts.add("androidx.vectordrawable:vectordrawable");
    artifacts.add("androidx.swiperefreshlayout:swiperefreshlayout");
    artifacts.add("androidx.textclassifier:textclassifier");
    artifacts.add("androidx.transition:transition");
    artifacts.add("androidx.versionedparcelable:versionedparcelable");
    artifacts.add("androidx.viewpager:viewpager");
    artifacts.add("androidx.wear:wear");
    artifacts.add("androidx.webkit:webkit");

    artifacts.add("fileTree(dir: 'libs', include: ['*.jar'])");
    return artifacts;
  }

  private static List<String> createConfigs() {
    var configs = new ArrayList<String>();
    configs.add("androidApis");
    configs.add("androidTestAnnotationProcessor");
    configs.add("androidTestApi");
    configs.add("androidTestApk");
    configs.add("androidTestCompile");
    configs.add("androidTestCompileOnly");
    configs.add("androidTestDebugAnnotationProcessor");
    configs.add("androidTestDebugApi");
    configs.add("androidTestDebugApk");
    configs.add("androidTestDebugCompile");
    configs.add("androidTestDebugCompileOnly");
    configs.add("androidTestDebugImplementation");
    configs.add("androidTestDebugProvided");
    configs.add("androidTestDebugRuntimeOnly");
    configs.add("androidTestDebugWearApp");
    configs.add("androidTestImplementation");
    configs.add("androidTestProvided");
    configs.add("androidTestRuntimeOnly");
    configs.add("androidTestUtil");
    configs.add("androidTestWearApp");
    configs.add("annotationProcessor");
    configs.add("api");
    configs.add("apk");
    configs.add("archives");
    configs.add("compile");
    configs.add("compileOnly");
    configs.add("coreLibraryDesugaring");
    configs.add("debugAnnotationProcessor");
    configs.add("debugApi");
    configs.add("debugApk");
    configs.add("debugCompile");
    configs.add("debugCompileOnly");
    configs.add("debugImplementation");
    configs.add("debugProvided");
    configs.add("debugRuntimeOnly");
    configs.add("debugWearApp");
    configs.add("default");
    configs.add("implementation");
    configs.add("implementation platform()");
    configs.add("lintChecks");
    configs.add("lintClassPath");
    configs.add("lintPublish");
    configs.add("provided");
    configs.add("releaseAnnotationProcessor");
    configs.add("releaseApi");
    configs.add("releaseApk");
    configs.add("releaseCompile");
    configs.add("releaseCompileOnly");
    configs.add("releaseImplementation");
    configs.add("releaseProvided");
    configs.add("releaseRuntimeOnly");
    configs.add("releaseWearApp");
    configs.add("runtimeOnly");
    configs.add("testAnnotationProcessor");
    configs.add("testApi");
    configs.add("testApk");
    configs.add("testCompile");
    configs.add("testCompileOnly");
    configs.add("testDebugAnnotationProcessor");
    configs.add("testDebugApi");
    configs.add("testDebugApk");
    configs.add("testDebugCompile");
    configs.add("testDebugCompileOnly");
    configs.add("testDebugImplementation");
    configs.add("testDebugProvided");
    configs.add("testDebugRuntimeOnly");
    configs.add("testDebugWearApp");
    configs.add("testImplementation");
    configs.add("testProvided");
    configs.add("testReleaseAnnotationProcessor");
    configs.add("testReleaseApi");
    configs.add("testReleaseApk");
    configs.add("testReleaseCompile");
    configs.add("testReleaseCompileOnly");
    configs.add("testReleaseImplementation");
    configs.add("testReleaseProvided");
    configs.add("testReleaseRuntimeOnly");
    configs.add("testReleaseWearApp");
    configs.add("testRuntimeOnly");
    configs.add("testWearApp");
    configs.add("wearApp");
    return configs;
  }

  private static List<String> createOtherCompletions() {
    var others = new ArrayList<String>();

    // Common words that user may use
    others.add("android");
    others.add("applicationVariants");
    others.add("compileSdkVersion");
    others.add("buildToolsVersion");
    others.add("defaultConfig");
    others.add("applicationId");
    others.add("minSdkVersion");
    others.add("targetSdkVersion");
    others.add("versionCode");
    others.add("versionName");
    others.add("multiDexEnabled");
    others.add("vectorDrawables.useSupportLibrary");
    others.add("compileOptions");
    others.add("coreLibraryDesugaringEnabled");
    others.add("sourceCompatibility");
    others.add("targetCompatibility");
    others.add("JavaVersion.VERSION_1_8");
    others.add("JavaVersion.VERSION_1_7");

    // Lint options
    others.add("lintOptions");
    others.add("quiet");
    others.add("abortOnError");
    others.add("checkReleaseBuilds");
    others.add("ignoreWarnings");
    others.add("checkAllWarnings");
    others.add("warningsAsErrors");
    others.add("disable");
    others.add("enable");
    others.add("check");
    others.add("noLines");
    others.add("showAll");
    others.add("explainIssues");
    others.add("lintConfig");
    others.add("textReport");
    others.add("textOutput");
    others.add("xmlReport");
    others.add("xmlOutput");
    others.add("htmlReport");
    others.add("htmlOutput");
    others.add("fatal");
    others.add("error");
    others.add("warning");
    others.add("ignore");
    others.add("informational");
    others.add("baseline");
    others.add("checkTestSources");
    others.add("ignoreTestSources");
    others.add("checkGeneratedSources");
    others.add("checkDependencies");

    // buildFeatures options
    others.add("buildFeatures");
    others.add("aidl");
    others.add("buildConfig");
    others.add("compose");
    others.add("prefab");
    others.add("renderScript");
    others.add("resValues");
    others.add("shaders");
    others.add("viewBinding");

    // Signing configs and all
    others.add("signingConfigs");
    others.add("debug");
    others.add("storeFile");
    others.add("storePassword");
    others.add("keyAlias");
    others.add("keyPassword");
    others.add("release");
    others.add("storeFile");
    others.add("storePassword");
    others.add("keyAlias");
    others.add("keyPassword");
    others.add("buildTypes");
    others.add("debug");
    others.add("minifyEnabled");
    others.add("proguardFiles");
    others.add("signingConfig");
    others.add("stringfog.enable");
    others.add("release");
    others.add("minifyEnabled");
    others.add("proguardFiles");
    others.add("signingConfig");
    others.add("stringfog.enable");
    others.add("packagingOptions");
    others.add("exclude");

    // Maybe used in root project's build.gradle
    others.add("buildscript");
    others.add("ext");
    others.add("project.ext");
    others.add("repositories");
    others.add("maven");
    others.add("url");
    others.add("google()");
    others.add("mavenLocal()");
    others.add("mavenCentral()");
    others.add("jcenter()");
    others.add("classpath");
    others.add("allprojects");
    others.add("subprojects");
    return others;
  }

  public void complete(
    ContentReference content,
    CharPosition position,
    CompletionPublisher publisher,
    Bundle extraArguments) {
    publisher.setUpdateThreshold(0);
    final var prefix =
      CompletionHelper.computePrefix(content, position,
        c -> MyCharacter.isJavaIdentifierPart(c) || c == '.');
    if (StringUtils.isTrimEmpty(prefix)) {
      return;
    }
    for (String artifact : ANDROIDX_ARTIFACTS) {
      if (!artifact.toLowerCase(Locale.ROOT).startsWith(prefix.toLowerCase(Locale.ROOT))) {
        continue;
      }
      final var completionItem = createCompletionItem(artifact);
      completionItem.setMatchLevel(CompletionItem.matchLevel(artifact, prefix));
      publisher.addItem(completionItem);
    }

    for (String config : CONFIGURATIONS) {
      if (!config.toLowerCase(Locale.ROOT).startsWith(prefix.toLowerCase(Locale.ROOT))) {
        continue;
      }
      final var completionItem = createCompletionItem(config);
      completionItem.setMatchLevel(CompletionItem.matchLevel(config, prefix));
      publisher.addItem(completionItem);
    }

    for (String other : OTHERS) {
      if (!other.toLowerCase(Locale.ROOT).startsWith(prefix.toLowerCase(Locale.ROOT))) {
        continue;
      }
      final var completionItem = createCompletionItem(other);
      completionItem.setMatchLevel(CompletionItem.matchLevel(other, prefix));
      publisher.addItem(completionItem);
    }
  }

  private CompletionItem createCompletionItem(String itemLabel) {
    CompletionItem item = new CompletionItem();
    item.setIdeLabel(itemLabel);
    item.setDetail("");
    item.setInsertText(itemLabel);
    item.setIdeSortText("0" + itemLabel);
    item.setInsertTextFormat(InsertTextFormat.PLAIN_TEXT);
    item.setCompletionKind(CompletionItemKind.NONE);
    return item;
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/groovy/GroovyLanguage.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.editor.language.groovy;

import android.os.Bundle;
import androidx.annotation.NonNull;
import com.itsaky.androidide.editor.language.IDELanguage;
import com.itsaky.androidide.editor.language.newline.BracketsNewlineHandler;
import com.itsaky.androidide.editor.language.utils.CommonSymbolPairs;
import com.itsaky.androidide.lexers.groovy.GroovyLexer;
import com.itsaky.androidide.utils.CharSequenceReader;
import io.github.rosemoe.sora.lang.analysis.AnalyzeManager;
import io.github.rosemoe.sora.lang.completion.CompletionCancelledException;
import io.github.rosemoe.sora.lang.completion.CompletionPublisher;
import io.github.rosemoe.sora.lang.smartEnter.NewlineHandler;
import io.github.rosemoe.sora.text.CharPosition;
import io.github.rosemoe.sora.text.ContentReference;
import io.github.rosemoe.sora.widget.SymbolPairMatch;
import java.io.StringReader;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.Token;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class GroovyLanguage extends IDELanguage {

  private static final Logger LOG = LoggerFactory.getLogger(GroovyLanguage.class);
  private final GroovyAnalyzer analyzer;
  private final GroovyAutoComplete completer;
  private final NewlineHandler[] newlineHandlers =
    new NewlineHandler[]{new BracketsNewlineHandler(this::getIndentAdvance, this::useTab)};
  private final CommonSymbolPairs symbolPairs = new CommonSymbolPairs();

  public GroovyLanguage() {
    analyzer = new GroovyAnalyzer();
    completer = new GroovyAutoComplete();
  }

  @NonNull
  @Override
  public AnalyzeManager getAnalyzeManager() {
    return analyzer;
  }

  @Override
  public int getInterruptionLevel() {
    return INTERRUPTION_LEVEL_STRONG;
  }

  @Override
  public void requireAutoComplete(
    @NonNull ContentReference content,
    @NonNull CharPosition position,
    @NonNull CompletionPublisher publisher,
    @NonNull Bundle extraArguments)
    throws CompletionCancelledException {

    completer.complete(content, position, publisher, extraArguments);
  }

  @Override
  public int getIndentAdvance(@NonNull ContentReference content, int line, int column) {
    try {
      GroovyLexer lexer = new GroovyLexer(CharStreams.fromReader(new CharSequenceReader(content)));
      Token token;
      int advance = 0;
      while (((token = lexer.nextToken()) != null && token.getType() != token.EOF)) {
        switch (token.getType()) {
          case GroovyLexer.LBRACE:
            advance++;
            break;
          case GroovyLexer.RBRACE:
            advance--;
            break;
        }
      }
      advance = Math.max(0, advance);
      return advance * getTabSize();
    } catch (Throwable e) {
      LOG.error("Failed to calculate indent advance", e);
    }
    return 0;
  }

  @Override
  public SymbolPairMatch getSymbolPairs() {
    return symbolPairs;
  }

  @Override
  public NewlineHandler[] getNewlineHandlers() {
    return newlineHandlers;
  }

  @Override
  public void destroy() {
  }

  @Override
  public int getIndentAdvance(@NonNull String p1) {
    try {
      GroovyLexer lexer = new GroovyLexer(CharStreams.fromReader(new StringReader(p1)));
      Token token = null;
      int advance = 0;
      while (((token = lexer.nextToken()) != null && token.getType() != token.EOF)) {
        switch (token.getType()) {
          case GroovyLexer.LBRACE:
            advance++;
            break;
          case GroovyLexer.RBRACE:
            advance--;
            break;
        }
      }
      advance = Math.max(0, advance);
      return advance * getTabSize();
    } catch (Throwable e) {
      LOG.error("Failed to calculate indent advance", e);
    }
    return 0;
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/incremental/BaseIncrementalAnalyzeManager.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.incremental;

import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.FIXME_COMMENT;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.TODO_COMMENT;
import static com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE.withoutCompletion;

import androidx.annotation.NonNull;
import com.blankj.utilcode.util.ArrayUtils;
import com.google.common.base.Preconditions;
import com.google.common.collect.EvictingQueue;
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE;
import com.itsaky.androidide.utils.CharSequenceReader;
import io.github.rosemoe.sora.lang.analysis.AsyncIncrementalAnalyzeManager;
import io.github.rosemoe.sora.lang.styling.CodeBlock;
import io.github.rosemoe.sora.lang.styling.Span;
import io.github.rosemoe.sora.lang.styling.TextStyle;
import io.github.rosemoe.sora.text.Content;
import io.github.rosemoe.sora.util.IntPair;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Stack;
import java.util.stream.Collectors;
import kotlin.Pair;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.Token;

/**
 * Base class for implementing an {@link AsyncIncrementalAnalyzeManager} in AndroidIDE.
 *
 * @author Akash Yadav
 */
public abstract class BaseIncrementalAnalyzeManager extends
                                                    AsyncIncrementalAnalyzeManager<LineState, IncrementalToken> {

  protected final Lexer lexer;
  private final int[] multilineStartTypes;
  private final int[] multilineEndTypes;
  private final int[] blockTokens;

  public BaseIncrementalAnalyzeManager(final Class<? extends Lexer> lexer) {
    Objects.requireNonNull(lexer, "Cannot create analyzer manager for null lexer");
    this.lexer = createLexerInstance(lexer);

    var multilineTokenTypes = getMultilineTokenStartEndTypes();
    verifyMultilineTypes(multilineTokenTypes);

    this.multilineStartTypes = multilineTokenTypes[0];
    this.multilineEndTypes = multilineTokenTypes[1];

    var tokens = getCodeBlockTokens();
    if (tokens == null) {
      tokens = new int[0];
    }

    this.blockTokens = tokens;
  }

  @NonNull
  private Lexer createLexerInstance(final Class<? extends Lexer> lexer) {
    try {
      final var constructor = lexer.getConstructor(CharStream.class);
      if (!constructor.isAccessible()) {
        constructor.setAccessible(true);
      }
      return constructor.newInstance(createStream(""));
    } catch (Throwable err) {
      throw new RuntimeException("Unable to create Lexer instance", err);
    }
  }

  @NonNull
  protected CharStream createStream(@NonNull CharSequence source) {
    Objects.requireNonNull(source);
    try {
      return CharStreams.fromReader(new CharSequenceReader(source));
    } catch (IOException e) {
      throw new RuntimeException("Cannot create CharStream for source", e);
    }
  }

  private void verifyMultilineTypes(@NonNull final int[][] types) {
    Preconditions.checkState(types.length == 2,
      "There must be exact two inner int[] in multiline token types");

    final var start = types[0];
    final var end = types[1];
    Preconditions.checkState(start.length > 0, "Invalid start token types");
    Preconditions.checkState(end.length > 0, "Invalid end token types");
  }

  /**
   * Returns the token types which start and end a multiline token.
   *
   * @return A <b>2xn</b> matrix where int[] at index 0 specifies token types which start a
   * multiline token and int[] 1 specifies tokens which end the multiline token. For example,
   * <p>[['/', '*'], ['*', '/']].
   * <p>But instead of characters, there must be token types.
   */
  protected abstract int[][] getMultilineTokenStartEndTypes();

  /**
   * Get the token types for left and right braces.
   *
   * @return An array of left and right brace token types.
   */
  protected abstract int[] getCodeBlockTokens();

  @Override
  public LineState getInitialState() {
    return new LineState();
  }

  @Override
  public boolean stateEquals(final LineState state, final LineState another) {
    return state.equals(another);
  }

  @Override
  public LineTokenizeResult<LineState, IncrementalToken> tokenizeLine(final CharSequence lineText,
                                                                      final LineState state,
                                                                      final int line
  ) {
    final var tokens = new ArrayList<IncrementalToken>();
    var newState = 0;
    var stateObj = new LineState();
    if (state.state == LineState.NORMAL) {
      newState = tokenizeNormal(lineText, 0, tokens, stateObj, state.lexerMode);
    } else if (state.state == LineState.INCOMPLETE) {
      final var result = fillIncomplete(lineText, tokens, state.lexerMode);
      newState = IntPair.getFirst(result);
      if (newState == LineState.NORMAL) {
        newState = tokenizeNormal(lineText, IntPair.getSecond(result), tokens, stateObj,
          state.lexerMode);
      } else {
        newState = LineState.INCOMPLETE;
      }
    }
    stateObj.state = newState;
    stateObj.lexerMode = lexer._mode;
    return new LineTokenizeResult<>(stateObj, tokens);
  }

  @Override
  public List<Span> generateSpansForLine(
    final LineTokenizeResult<LineState, IncrementalToken> tokens
  ) {
    var result = generateSpans(tokens);

    Objects.requireNonNull(result);

    if (result.isEmpty()) {
      result.add(Span.obtain(0, TextStyle.makeStyle(SchemeAndroidIDE.TEXT_NORMAL)));
    }

    return result;
  }

  /**
   * Generate spans for the given {@link LineTokenizeResult}.
   *
   * @param tokens The tokenization result.
   * @return The spans for the tokens.
   */
  protected abstract List<Span> generateSpans(
    final LineTokenizeResult<LineState, IncrementalToken> tokens
  );

  @Override
  public List<CodeBlock> computeBlocks(final Content text,
                                       final AsyncIncrementalAnalyzeManager<LineState, IncrementalToken>.CodeBlockAnalyzeDelegate delegate
  ) {
    final var stack = new Stack<CodeBlock>();
    final var blocks = new ArrayList<CodeBlock>();
    var line = 0;
    var maxSwitch = 0;
    var currSwitch = 0;
    while (delegate.isNotCancelled() && line < text.getLineCount()) {
      final var tokens = getState(line);
      final var checkForIdentifiers = tokens.state.state == LineState.NORMAL ||
        (tokens.state.state == LineState.INCOMPLETE && tokens.tokens.size() > 1);
      if (!tokens.state.hasBraces && !checkForIdentifiers) {
        line++;
        continue;
      }

      for (int i = 0; i < tokens.tokens.size(); i++) {
        final var token = tokens.tokens.get(i);
        var offset = token.getStartIndex();
        if (isCodeBlockStart(token)) {
          if (stack.isEmpty()) {
            if (currSwitch > maxSwitch) {
              maxSwitch = currSwitch;
            }
            currSwitch = 0;
          }
          currSwitch++;
          CodeBlock block = new CodeBlock();
          block.startLine = line;
          block.startColumn = offset;
          stack.push(block);
        } else if (isCodeBlockEnd(token)) {
          if (!stack.isEmpty()) {
            CodeBlock block = stack.pop();
            block.endLine = line;
            block.endColumn = offset;
            if (block.startLine != block.endLine) {
              blocks.add(block);
            }
          }
        }
      }

      line++;
    }
    blocks.sort(CodeBlock.COMPARATOR_END);
    return blocks;
  }

  protected boolean isCodeBlockStart(IncrementalToken token) {
    return blockTokens.length == 2 && token.getType() == blockTokens[0];
  }

  protected boolean isCodeBlockEnd(IncrementalToken token) {
    return blockTokens.length == 2 && token.getType() == blockTokens[1];
  }

  @SuppressWarnings("UnstableApiUsage")
  protected boolean isIncompleteTokenStart(EvictingQueue<IncrementalToken> q) {
    return matchTokenTypes(this.multilineStartTypes, q);
  }

  @SuppressWarnings("UnstableApiUsage")
  protected boolean isIncompleteTokenEnd(EvictingQueue<IncrementalToken> q) {
    return matchTokenTypes(this.multilineEndTypes, q);
  }

  /**
   * Called when the analyzer finds an incomplete token in a lne.
   *
   * @param token The incomplete token.
   */
  protected abstract void handleIncompleteToken(IncrementalToken token);

  /**
   * Gets the next token from lexer and return an {@link IncrementalToken}.
   *
   * @return The next {@link IncrementalToken}.
   */
  protected IncrementalToken nextToken() {
    return new IncrementalToken(lexer.nextToken());
  }

  /**
   * Pop (remove) required number of tokens after an incomplete token has been encountered. <br>
   *
   * <p>For example: <br>
   * When ['/', '*'] tokens are encountered, the '*' token must be removed. In this case, <code>
   * incompleteToken</code> parameter will point to '/' token.
   *
   * <p>By default, this method removes only the last token.
   *
   * @param incompleteToken The token which is the start of the incomplete token.
   * @param tokens          The list of tokens from which extra tokens must be removed.
   */
  protected void popTokensAfterIncomplete(@NonNull IncrementalToken incompleteToken,
                                          @NonNull List<IncrementalToken> tokens
  ) {
    tokens.remove(tokens.size() - 1);
  }

  protected void handleLineCommentSpan(@NonNull IncrementalToken token, @NonNull List<Span> spans,
                                       int offset
  ) {
    var commentType = SchemeAndroidIDE.COMMENT;

    // highlight special line comments
    var commentText = token.getText();
    if (commentText.length() > 2) {
      commentText = commentText.substring(2);
      commentText = commentText.trim();
      if ("todo".equalsIgnoreCase(commentText.substring(0, 4))) {
        commentType = TODO_COMMENT;
      } else if ("fixme".equalsIgnoreCase(commentText.substring(0, 5))) {
        commentType = FIXME_COMMENT;
      }
    }
    spans.add(Span.obtain(offset, withoutCompletion(commentType)));
  }

  /**
   * Called when the <code>state</code> in {@link #tokenizeLine(CharSequence, LineState, int)} is
   * {@link LineState#NORMAL}.
   *
   * @param line   The line source.
   * @param column The column in <code>line</code>.
   * @param tokens The list of tokens that must be updated as the <code>line</code> is scanned.
   * @param st     The state object whose state must be after after the <code>line</code> has been
   *               scanned.
   * @return The new state.
   */
  @SuppressWarnings("UnstableApiUsage")
  protected int tokenizeNormal(final CharSequence line, final int column,
                               final List<IncrementalToken> tokens, final LineState st,
                               final int lexerMode
  ) {
    lexer.setInputStream(createStream(line));
    if (lexer._mode != lexerMode) {
      lexer.pushMode(lexerMode);
    }
    final var queues = createEvictingQueueForTokens();
    final var start = queues.getFirst();
    final var end = queues.getSecond();
    var isInIncompleteToken = false;
    var state = LineState.NORMAL;
    IncrementalToken token;
    IncrementalToken incompleteToken = null;

    while ((token = nextToken()) != null) {
      if (token.getType() == IncrementalToken.EOF) {
        break;
      }

      // Skip to the token just after 'column'
      if (token.getStartIndex() < column) {
        continue;
      }

      if (!isInIncompleteToken) {
        if (token.getStartIndex() == column && !tokens.isEmpty()) {
          token.type = tokens.get(tokens.size() - 1).getType();
        }

        tokens.add(token);
      }
      start.add(token);
      end.add(token);
      final var type = token.getType();
      if (ArrayUtils.contains(getCodeBlockTokens(), type)) {
        st.hasBraces = true;
      }

      if (start.remainingCapacity() == 0 && isIncompleteTokenStart(start)) {
        isInIncompleteToken = true;
        incompleteToken = start.poll();

        // Pop extra tokens from the list.
        popTokensAfterIncomplete(Objects.requireNonNull(incompleteToken), tokens);
      } else if (end.remainingCapacity() == 0 && isIncompleteTokenEnd(end)) {
        // This should most probably not happen because, if a comment starts and ends on the same
        // line, the lexer will create a token for the whole comment
        // But still we handle this case...
        isInIncompleteToken = false;
        incompleteToken = null;
      }

      if (isInIncompleteToken) {
        state = LineState.INCOMPLETE;
      }
    }

    if (incompleteToken != null) {
      incompleteToken.incomplete = true;
      handleIncompleteToken(incompleteToken);
    }

    return state;
  }

  /**
   * Called when the <code>state</code> in {@link #tokenizeLine(CharSequence, LineState, int)} is
   * {@link LineState#INCOMPLETE}.
   *
   * @param line   The line source.
   * @param tokens The list of tokens that must be updated as the <code>line</code> is scanned.
   * @return The state and offset.
   */
  @SuppressWarnings("UnstableApiUsage")
  protected long fillIncomplete(CharSequence line, final List<IncrementalToken> tokens,
                                final int lexerMode
  ) {
    lexer.setInputStream(createStream(line));
    if (lexer._mode != lexerMode) {
      lexer.pushMode(lexerMode);
    }
    final var queue = createEvictingQueueForTokens();
    final var end = queue.getSecond();
    final var allTokens = lexer.getAllTokens()
      .stream()
      .map(IncrementalToken::new)
      .collect(Collectors.toList());
    if (allTokens.isEmpty()) {
      return IntPair.pack(LineState.INCOMPLETE, 0);
    }
    var completed = false;
    var index = 0;
    for (index = 0; index < allTokens.size(); index++) {
      final IncrementalToken token = allTokens.get(index);
      if (token.getType() == Token.EOF) {
        break;
      }

      end.add(token);
      if (end.remainingCapacity() == 0 && isIncompleteTokenEnd(end)) {
        completed = true;
        break;
      }
    }

    final var first = allTokens.get(0);
    final int offset = allTokens.get(completed ? index : index - 1).getStartIndex();
    first.startIndex = 0;
    handleIncompleteToken(first);
    tokens.add(first);
    if (completed) {
      return IntPair.pack(LineState.NORMAL, offset);
    } else {
      return IntPair.pack(LineState.INCOMPLETE, offset);
    }
  }

  @SuppressWarnings("UnstableApiUsage")
  @NonNull
  private Pair<EvictingQueue<IncrementalToken>, EvictingQueue<IncrementalToken>> createEvictingQueueForTokens() {
    return new Pair<>(EvictingQueue.create(multilineStartTypes.length),
      EvictingQueue.create(multilineEndTypes.length));
  }

  @SuppressWarnings("UnstableApiUsage")
  private boolean matchTokenTypes(@NonNull int[] types,
                                  @NonNull EvictingQueue<IncrementalToken> tokens
  ) {
    final var arr = tokens.toArray(new IncrementalToken[0]);
    for (int i = 0; i < types.length; i++) {
      if (types[i] != arr[i].getType()) {
        return false;
      }
    }
    return true;
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/incremental/IncrementalToken.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.incremental

import org.antlr.v4.runtime.CharStream
import org.antlr.v4.runtime.Token
import org.antlr.v4.runtime.TokenSource

/**
 * Token used for incremental lexing tasks. Allows us to store other information to tokens.
 *
 * @author Akash Yadav
 */
class IncrementalToken(val token: Token) : Token {

  @JvmField var type = token.type
  @JvmField var startIndex = token.startIndex
  @JvmField var incomplete = false

  override fun getText(): String = token.text
  override fun getType() = type
  override fun getLine() = token.line
  override fun getCharPositionInLine() = token.charPositionInLine
  override fun getChannel() = token.channel
  override fun getTokenIndex() = token.tokenIndex
  override fun getStartIndex() = startIndex
  override fun getStopIndex() = token.stopIndex
  override fun getTokenSource(): TokenSource = token.tokenSource
  override fun getInputStream(): CharStream = token.inputStream
  override fun equals(other: Any?) = token == other
  override fun hashCode() = token.hashCode()
  override fun toString() = token.toString()
}



================================================
File: java/com/itsaky/androidide/editor/language/incremental/LineState.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.incremental

import org.antlr.v4.runtime.Lexer

/**
 * Tokenization state of a line.
 *
 * @param state The state of the line.
 * @param hasBraces `true` if the line has braces. `false` otherwise.
 * @param lexerMode The mode of the lexer. This MUST be preserved in the lexer.
 *
 * @author Akash Yadav
 */
data class LineState(
  @JvmField var state: Int = NORMAL,
  @JvmField var hasBraces: Boolean = false,
  @JvmField var lexerMode: Int = Lexer.DEFAULT_MODE
) {
  companion object {
    const val NORMAL = 0
    const val INCOMPLETE = 1
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/newline/BaseNewlineHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.newline

import io.github.rosemoe.sora.lang.smartEnter.NewlineHandler
import io.github.rosemoe.sora.lang.styling.Styles
import io.github.rosemoe.sora.lang.styling.StylesUtils
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.Content
import kotlin.math.max
import kotlin.math.min

/**
 * Base class for new line handler implementations.
 *
 * @author Akash Yadav
 */
abstract class BaseNewlineHandler : NewlineHandler {
  
  protected val openingBrackets = mutableListOf<String>()
  protected val closingBrackets = mutableListOf<String>()
  
  override fun matchesRequirement(text: Content, position: CharPosition, style: Styles?): Boolean {
    val line = text.getLine(position.line)
    return !StylesUtils.checkNoCompletion(style, position) &&
      (getNonEmptyTextBefore(line, position.column, 1) in openingBrackets) &&
      (getNonEmptyTextAfter(line, position.column, 1) in closingBrackets)
  }
  
  @Suppress("SameParameterValue")
  protected open fun getNonEmptyTextBefore(text: CharSequence, index: Int, length: Int): String {
    var idx = index
    while (idx > 0 && Character.isWhitespace(text[idx - 1])) {
      idx--
    }
    return text.subSequence(max(0, idx - length), idx).toString()
  }
  
  @Suppress("SameParameterValue")
  protected open fun getNonEmptyTextAfter(text: CharSequence, index: Int, length: Int): String {
    var idx = index
    while (idx < text.length && Character.isWhitespace(text[idx])) {
      idx++
    }
    return text.subSequence(idx, min(idx + length, text.length)).toString()
  }
}


================================================
File: java/com/itsaky/androidide/editor/language/newline/BracketsNewlineHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.newline

import io.github.rosemoe.sora.lang.smartEnter.NewlineHandleResult
import io.github.rosemoe.sora.lang.styling.Styles
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.text.TextUtils

internal open class BracketsNewlineHandler(
  val getIndentAdvance: (String?) -> Int,
  val useTab: () -> Boolean
) : CStyleBracketsHandler() {

  override fun handleNewline(
    text: Content,
    position: CharPosition,
    style: Styles?,
    tabSize: Int
  ): NewlineHandleResult {
    val line = text.getLine(position.line)
    val index = position.column
    val beforeText = line.subSequence(0, index).toString()
    val afterText = line.subSequence(index, line.length).toString()
    return handleNewline(beforeText, afterText, tabSize)
  }

  private fun handleNewline(
    beforeText: String?,
    afterText: String?,
    tabSize: Int
  ): NewlineHandleResult {
    val count = TextUtils.countLeadingSpaceCount(beforeText!!, tabSize)
    val advanceBefore: Int = getIndentAdvance(beforeText)
    val advanceAfter: Int = getIndentAdvance(afterText)
    var text: String
    val sb =
      StringBuilder("\n")
        .append(TextUtils.createIndent(count + advanceBefore, tabSize, useTab()))
        .append('\n')
        .append(TextUtils.createIndent(count + advanceAfter, tabSize, useTab()).also { text = it })
    val shiftLeft = text.length + 1
    return NewlineHandleResult(sb, shiftLeft)
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/newline/CStyleBracketsHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.newline

/**
 * Newline handler for brackets in Java language.
 *
 * @author Akash Yadav
 */
abstract class CStyleBracketsHandler : BaseNewlineHandler() {
  
  init {
    openingBrackets.add("{")
    closingBrackets.add("}")
    
    openingBrackets.add("(")
    closingBrackets.add(")")
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/newline/TSBracketsHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.newline

import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage
import io.github.rosemoe.sora.lang.smartEnter.NewlineHandleResult
import io.github.rosemoe.sora.lang.styling.Styles
import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.text.TextUtils

/**
 * Newline handler for tree-sitter languages.
 *
 * @author Akash Yadav
 */
abstract class TSBracketsHandler(private val language: TreeSitterLanguage) : BaseNewlineHandler() {

  override fun handleNewline(
    text: Content,
    position: CharPosition,
    style: Styles?,
    tabSize: Int
  ): NewlineHandleResult {
    val count = TextUtils.countLeadingSpaceCount(text.getLine(position.line), tabSize)
    var txt: String
    val sb =
      StringBuilder("\n")
        .append(TextUtils.createIndent(count + tabSize, tabSize, language.useTab()))
        .append("\n")
        .append(
          TextUtils.createIndent(count, tabSize, language.useTab()).also { txt = it }
        )
    return NewlineHandleResult(sb, txt.length + 1)
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/newline/TSCStyleBracketsHandler.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.newline

import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage

/**
 * C style brackets handler for tree-sitter languages.
 *
 * @author Akash Yadav
 */
class TSCStyleBracketsHandler(language: TreeSitterLanguage) : TSBracketsHandler(language) {
  
  init {
    openingBrackets.add("{")
    closingBrackets.add("}")
    
    openingBrackets.add("(")
    closingBrackets.add(")")
  }
}


================================================
File: java/com/itsaky/androidide/editor/language/treesitter/JavaLanguage.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.content.Context
import com.itsaky.androidide.editor.language.newline.TSBracketsHandler
import com.itsaky.androidide.editor.language.newline.TSCStyleBracketsHandler
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage.Factory
import com.itsaky.androidide.editor.language.utils.CommonSymbolPairs
import com.itsaky.androidide.lsp.api.ILanguageServer
import com.itsaky.androidide.lsp.api.ILanguageServerRegistry
import com.itsaky.androidide.lsp.java.JavaLanguageServer
import com.itsaky.androidide.treesitter.java.TSLanguageJava
import io.github.rosemoe.sora.lang.Language.INTERRUPTION_LEVEL_SLIGHT
import io.github.rosemoe.sora.util.MyCharacter
import io.github.rosemoe.sora.widget.SymbolPairMatch

/**
 * Tree Sitter language specification for Java.
 *
 * @author Akash Yadav
 */
class JavaLanguage(context: Context) :
  TreeSitterLanguage(context, TSLanguageJava.getInstance(), TS_TYPE) {

  companion object {

    const val TS_TYPE = "java"

    @JvmField
    val FACTORY = Factory { JavaLanguage(it) }
  }

  override val languageServer: ILanguageServer?
    get() = ILanguageServerRegistry.getDefault().getServer(JavaLanguageServer.SERVER_ID)

  override fun checkIsCompletionChar(c: Char): Boolean {
    return MyCharacter.isJavaIdentifierPart(c) || c == '.'
  }

  override fun getInterruptionLevel(): Int {
    return INTERRUPTION_LEVEL_SLIGHT
  }

  override fun getSymbolPairs(): SymbolPairMatch {
    return JavaSymbolPairs()
  }

  override fun createNewlineHandlers(): Array<TSBracketsHandler> {
    return arrayOf(TSCStyleBracketsHandler(this))
  }

  internal open class JavaSymbolPairs : CommonSymbolPairs() {
    init {
      super.putPair('<', SymbolPair("<", ">"))
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/JsonLanguage.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.content.Context
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage.Factory
import com.itsaky.androidide.treesitter.json.TSLanguageJson
import io.github.rosemoe.sora.lang.Language.INTERRUPTION_LEVEL_STRONG

/**
 * [TreeSitterLanguage] implementation for JSON files.
 *
 * @author Akash Yadav
 */
class JsonLanguage(context: Context) :
  TreeSitterLanguage(context, TSLanguageJson.getInstance(), TS_TYPE) {

  companion object {

    const val TS_TYPE = "json"

    @JvmField
    val FACTORY = Factory { JsonLanguage(it) }
  }

  override fun getInterruptionLevel(): Int {
    return INTERRUPTION_LEVEL_STRONG
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/KotlinLanguage.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.content.Context
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage.Factory
import com.itsaky.androidide.treesitter.kotlin.TSLanguageKotlin
import io.github.rosemoe.sora.lang.Language.INTERRUPTION_LEVEL_STRONG

/**
 * [TreeSitterLanguage] implementation for Kotlin.
 *
 * @author Akash Yadav
 */
open class KotlinLanguage(context: Context) :
  TreeSitterLanguage(context, TSLanguageKotlin.getInstance(), TS_TYPE_KT) {

  companion object {

    val FACTORY = Factory { KotlinLanguage(it) }
    const val TS_TYPE_KT = "kt"
    const val TS_TYPE_KTS = "kts"
  }

  override fun getInterruptionLevel(): Int {
    return INTERRUPTION_LEVEL_STRONG
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/LogLanguage.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.content.Context
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage.Factory
import com.itsaky.androidide.treesitter.log.TSLanguageLog

/**
 * Tree Sitter language implementation for logs.
 *
 * @author Akash Yadav
 */
class LogLanguage(context: Context) :
  TreeSitterLanguage(context, TSLanguageLog.getInstance(), TS_TYPE) {

  companion object {

    const val TS_TYPE = "log"

    @JvmField
    val FACTORY = Factory { LogLanguage(it) }
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/TSLanguageRegistry.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import com.itsaky.androidide.editor.language.treesitter.internal.TSLanguageRegistryImpl

/**
 * Registry for managing [TreeSitterLanguage factories][TreeSitterLanguage.Factory].
 *
 * @author Akash Yadav
 */
interface TSLanguageRegistry {

  companion object {

    @JvmStatic
    val instance by lazy { TSLanguageRegistryImpl() }
  }

  /**
   * Registers the given [factory] for the given file types.
   *
   * @param fileType The file extension for which the given factory should be used.
   * @param factory The factory which will create the [TreeSitterLanguage] instance.
   * @throws AlreadyRegisteredException If an instance of [TreeSitterLanguage.Factory] is already
   *   registered for the given file type.
   */
  fun <T : TreeSitterLanguage> register(fileType: String, factory: TreeSitterLanguage.Factory<T>)

  /**
   * Checks whether a [TreeSitterLanguage] has been registered for the given [file type][fileType].
   *
   * @return `true` if a [TreeSitterLanguage] has been registered for [fileType], `false` otherwise.
   */
  fun hasLanguage(fileType: String): Boolean

  /**
   * Returns the instance of the [TreeSitterLanguage.Factory] for the given file type.
   *
   * @param fileType The file type (extension) to create the language factory instance for.
   * @return The [TreeSitterLanguage.Factory] implmementation.
   * @throws NotRegisteredException If no [TreeSitterLanguage.Factory] is registered for the given
   *   file type.
   */
  fun <T : TreeSitterLanguage> getFactory(fileType: String): TreeSitterLanguage.Factory<T>

  /**
   * Destroys the language registry, removing all the registered language factory. This must be
   * called only when the application is exiting.
   */
  fun destroy()

  class AlreadyRegisteredException(type: String) :
    IllegalStateException(
      "An instance of TreeSitterLanguage.Factory is already registered for file type '$type'"
    )

  class NotRegisteredException(type: String) :
    RuntimeException("No TreeSitterLanguage.Factory registered for file type '$type'")
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/TreeSitterAnalyzeManager.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import com.itsaky.androidide.editor.schemes.LanguageScheme
import io.github.rosemoe.sora.editor.ts.TsAnalyzeManager
import io.github.rosemoe.sora.editor.ts.TsLanguageSpec
import io.github.rosemoe.sora.editor.ts.TsTheme
import io.github.rosemoe.sora.lang.styling.Styles

/**
 * [TsAnalyzeManager] implementation for tree sitter languages.
 *
 * @author Akash Yadav
 */
class TreeSitterAnalyzeManager(
  languageSpec: TsLanguageSpec,
  theme: TsTheme
) : TsAnalyzeManager(languageSpec, theme) {

  override var styles: Styles = Styles()
    set(value) {
      field = value
      resetSpanFactory(value, langScheme)
    }

  internal var langScheme: LanguageScheme? = null
    set(value) {
      field = value
      resetSpanFactory(styles, value)
    }

  init {
    resetSpanFactory(styles, langScheme)
  }

  private fun resetSpanFactory(styles: Styles, langScheme: LanguageScheme?) {
    spanFactory = TreeSitterSpanFactory(reference, languageSpec.tsQuery, styles, langScheme)
  }
}


================================================
File: java/com/itsaky/androidide/editor/language/treesitter/TreeSitterIndentProvider.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import androidx.collection.MutableLongObjectMap
import androidx.collection.mutableIntObjectMapOf
import androidx.collection.mutableLongObjectMapOf
import androidx.core.text.trimmedLength
import com.itsaky.androidide.editor.utils.getFirstNodeAtLine
import com.itsaky.androidide.editor.utils.getLastNodeAtLine
import com.itsaky.androidide.editor.utils.previousNonBlankLine
import com.itsaky.androidide.treesitter.TSNode
import com.itsaky.androidide.treesitter.TSParser
import com.itsaky.androidide.treesitter.TSPoint
import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryCapture
import com.itsaky.androidide.treesitter.TSQueryCursor
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSTree
import com.itsaky.androidide.treesitter.predicate.SetDirectiveHandler
import com.itsaky.androidide.utils.IntPair
import io.github.rosemoe.sora.editor.ts.TsAnalyzeWorker
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.text.TextUtils
import org.slf4j.LoggerFactory
import kotlin.math.max

/**
 * Computes indentation for tree sitter languages using the indents query.
 *
 * This is based on Neovim's implementation of indentation in `nvim-treesitter`.
 *
 * @see <a href="https://github.com/nvim-treesitter/nvim-treesitter/blob/9bc21966f27d48ab8eac4c42d5b130ef6c411304/lua/nvim-treesitter/indent.lua">nvim-treesitter's indent.lua</a>
 * @author Akash Yadav
 */
class TreeSitterIndentProvider(
  private val languageSpec: TreeSitterLanguageSpec,
  private val analyzer: TsAnalyzeWorker,
  private val indentSize: Int
) {

  companion object {

    private const val IDENT_AUTO = "indent.auto"
    private const val IDENT_BEGIN = "indent.begin"
    private const val IDENT_END = "indent.end"
    private const val IDENT_DEDENT = "indent.dedent"
    private const val IDENT_BRANCH = "indent.branch"
    private const val IDENT_IGNORE = "indent.ignore"
    private const val IDENT_ALIGN = "indent.align"
    private const val IDENT_ZERO = "indent.zero"

    private const val IDENT_TYP_COUNT = 8 // increment this when adding a new indent type above

    private val log = LoggerFactory.getLogger(TreeSitterIndentProvider::class.java)
    internal const val INDENTATION_ERR = Int.MIN_VALUE
    internal const val INDENT_ALIGN_ZERO = Int.MIN_VALUE
    internal const val INDENT_AUTO = Int.MAX_VALUE

    private val DELIMITER_REGEX = Regex("""[\-.+\[\]()$^\\?*]""")
  }

  fun getIndentsForLines(
    content: Content,
    positions: LongArray,
    default: Int = INDENTATION_ERR
  ): IntArray {
    log.debug("getIndentsForLine(Content({}),{})", content.length,
      positions.joinToString(",") { "${IntPair.getFirst(it)}:${IntPair.getSecond(it)}" })
    val defaultIndents = IntArray(positions.size) { default }

    // not really needed, but just in case
    if (content.isEmpty() || positions.isEmpty()) {
      return defaultIndents
    }

    val document = analyzer.document
    TSParser.create().use { parser ->
      parser.language = document.parser.language

      var closeTree = true
      val tree = if (content.documentVersion == document.version) {
        // avoid converting the content to string if not really needed
        log.info("Re-using cached tree from document version {}", document.version)
        closeTree = false
        document.tree
      } else {
        log.info(
          "Re-parsing content for indentation as document version {} does not match version {}",
          document.version,
          content.documentVersion
        )

        (document.tree?.copy() ?: return defaultIndents).use { copiedTree ->
          parser.parseString(copiedTree, content.toString())
        }
      }

      if (tree == null) {
        log.info("Parsed tree is null, returning default indent: {}", default)
        return defaultIndents
      }

      try {
        return computeIndents(tree, content, positions, defaultIndents)
          .also { indents ->
            log.debug("Computed indents: {}", indents.joinToString(","))
          }
      } finally {
        if (closeTree) {
          tree.close()
        }
      }
    }
  }

  private fun computeIndents(
    tree: TSTree,
    content: Content,
    positions: LongArray,
    defaultIndents: IntArray
  ): IntArray {
    val indentsQuery = languageSpec.indentsQuery ?: run {
      log.info("Cannot compute indents. Indents query is null.")
      return defaultIndents
    }

    val rootNode = tree.rootNode ?: run {
      log.info("Cannot compute indents. Root node is null.")
      return defaultIndents
    }

    return TSQueryCursor.create().use { cursor ->
      cursor.addPredicateHandler(SetDirectiveHandler())
      cursor.exec(indentsQuery, tree.rootNode)

      val indents = getIndents(languageSpec.indentsQuery, cursor)
      return@use IntArray(positions.size) { index ->
        val line = IntPair.getFirst(positions[index])
        val column = IntPair.getSecond(positions[index])
        computeIndentForLine(content, line, column, defaultIndents[index], rootNode, indents)
      }
    }
  }

  private fun computeIndentForLine(
    content: Content,
    line: Int,
    column: Int,
    default: Int,
    rootNode: TSNode,
    indents: IndentsContainer
  ): Int {
    val isEmptyLine = content.getLine(line).trimmedLength() == 0
    var node: TSNode?

    if (isEmptyLine) {
      val prevlnum = content.previousNonBlankLine(line)
      if (prevlnum == -1) {
        log.error("Cannot compute indents. Unable to get previous non-blank line.")
        return default
      } else {
        log.debug("Previous non-blank line: {}", prevlnum)
      }

      var prevline: CharSequence = content.getLine(prevlnum)
      val indentBytes = TextUtils.countLeadingSpaceCount(prevline, indentSize) shl 1
      prevline = prevline.trim()

      // The final position can be trailing spaces, which should not affect indentation
      node = content.getLastNodeAtLine(rootNode, prevlnum,
        (indentBytes + prevline.length shl 1) - 2
      ) ?: run {
        log.error("Unable to get last node at line: {}", prevlnum)
        return default
      }

      // TODO(itsaky): Make this an API
      //    Language defs must be able to specify captures which represent a comment
      if (node.type == "comment") {
        // The final node we capture of the previous line can be a comment node, which should also be ignored
        // Unless the last line is an entire line of comment, ignore the comment range and find the last node again
        val firstNode = content.getFirstNodeAtLine(rootNode, prevlnum, indentBytes)
        val scol = node.startPoint.column
        if (firstNode?.nodeId != node.nodeId) {
          // In case the last captured node is a trailing comment node, re-trim the string
          prevline = prevline.subSequence(0, (scol shr 1) - (indentBytes shr 1)).trim()
          val col = indentBytes + ((prevline.length - 1) shl 1)

          node = content.getLastNodeAtLine(rootNode, prevlnum, col)
        }
      }

      if (indents[IDENT_END]!![node?.nodeId ?: 0] != null) {
        node = content.getFirstNodeAtLine(rootNode, line)
      }
    } else {
      node = content.getFirstNodeAtLine(rootNode, line, column shl 1)
    }

    if (node == null || !node.canAccess()) {
      log.error(
        "Cannot compute indents. Unable to get node at line: {}. node={} node.canAccess={}", line,
        node, node?.canAccess())
      return default
    }

    var indent = 0

    if (indents[IDENT_ZERO]?.containsKey(node.nodeId) == true) {
      // indent.zero: align the node to the start of the line
      log.debug("Zero indent for node: {}", node)
      return INDENT_ALIGN_ZERO
    }

    // map to store whether a given line is already processed
    // this is to ensure that we do not accidentally apply multiple indent levels to the same line
    val processedLines = mutableIntObjectMapOf<Boolean>()

    while (node != null && node.canAccess()) {

      val srow = node.startPoint.line
      val erow = node.endPoint.line

      // do 'auto indent' if not marked as '@indent'
      if (!indents.hasNode(IDENT_BEGIN, node)
        && !indents.hasNode(IDENT_ALIGN, node)
        && indents.hasNode(IDENT_AUTO, node)
        && srow < line
        && line <= erow
      ) {
        log.debug("Auto indent for node: {}", node)
        return INDENT_AUTO
      }

      // Do not indent if we are inside an @ignore block.
      // If a node spans from L1,C1 to L2,C2, we know that lines where L1 < line <= L2 would
      // have their indentations contained by the node.
      if (!indents.hasNode(IDENT_BEGIN, node)
        && indents.hasNode(IDENT_IGNORE, node)
        && srow < line
        && line <= erow
      ) {
        log.debug("Ignore indent for node: {}", node)
        return default
      }

      var isProcessed = false

      if (!processedLines.containsKey(srow)
        && ((indents.hasNode(IDENT_BRANCH, node) && srow == line)
            || (indents.hasNode(IDENT_DEDENT, node) && srow != line))
      ) {
        indent -= indentSize
        isProcessed = true
      }

      // do not indent for nodes that starts-and-ends on same line and starts on target line (lnum)
      val shouldProcess = !processedLines.containsKey(srow)
      var isInError = false
      if (shouldProcess) {
        isInError = node.parent?.let { it.canAccess() && it.hasErrors() } == true
      }

      if (shouldProcess &&
        (indents.hasNode(IDENT_BEGIN, node)
            && (srow != erow || isInError || indents.hasMeta(IDENT_BEGIN, node,
          "indent.immediate"))
            && (srow != line || indents.hasMeta(IDENT_BEGIN, node, "indent.start_at_same_line")))
      ) {
        indent += indentSize
        isProcessed = true
      }

      if (isInError && !indents.hasNode(IDENT_ALIGN, node)) {
        // only when the node is in error, promote the
        // first child's aligned indent to the error node
        // to work around ((ERROR "X" . (_)) @aligned_indent (#set! "delimiter" "AB"))
        // matching for all X, instead set do
        // (ERROR "X" @aligned_indent (#set! "delimiter" "AB") . (_))
        // and we will fish it out here.

        for (i in 0 until node.childCount) {
          val child = node.getChild(i)
          if (indents.hasNode(IDENT_ALIGN, child)) {
            indents[IDENT_ALIGN]!![node.nodeId] = indents[IDENT_ALIGN]!![child.nodeId]!!
            break
          }
        }
      }

      // do not indent for nodes that starts-and-ends on same line and starts on target line (lnum)
      if (shouldProcess
        && indents.hasNode(IDENT_ALIGN, node)
        && (srow != erow || isInError)
        && (srow != line)
      ) {
        val meta = indents.getMeta(IDENT_ALIGN, node)!!
        var oDelimNode: TSNode?
        var oIsLastInLine = false
        var cDelimNode: TSNode?
        var cIsLastInLine = false
        var indentIsAbsolute = false

        if (meta.containsKey("indent.open_delimiter")) {
          val r = findDelimiter(content, node, meta["indent.open_delimiter"]!!)
          oDelimNode = r.first
          oIsLastInLine = r.second
        } else {
          oDelimNode = node
        }

        if (meta.containsKey("indent.close_delimiter")) {
          val r = findDelimiter(content, node, meta["indent.close_delimiter"]!!)
          cDelimNode = r.first
          cIsLastInLine = r.second
        } else {
          cDelimNode = node
        }

        if (oDelimNode != null) {
          val osrow = oDelimNode.startPoint.row
          val oscol = oDelimNode.startPoint.column
          var csrow: Int? = null
          if (cDelimNode != null) {
            csrow = cDelimNode.startPoint.row
          }

          if (oIsLastInLine) {
            // hanging indent (previous line ended with starting delimiter)
            // should be processed like indent
            if (shouldProcess) {
              indent += indentSize
              if (cIsLastInLine) {
                // If current line is outside the range of a node marked with `@aligned_indent`
                // Then its indent level shouldn't be affected by `@aligned_indent` node
                if (csrow != null && csrow < line) {
                  indent = max(indent - indentSize, 0)
                }
              }
            }
          } else {
            // aligned indent
            if (cIsLastInLine && csrow != null && osrow != csrow && csrow < line) {
              // If current line is outside the range of a node marked with `@aligned_indent`
              // Then its indent level shouldn't be affected by `@aligned_indent` node
              indent = max(indent - indentSize, 0)
            } else {
              indent = oscol + (meta.getInt("indent.increment") ?: 1)
              indentIsAbsolute = true
            }
          }

          // deal with final line
          var avoidLastMatchingNext = false
          if (csrow != null && csrow != osrow && csrow == line) {
            // delims end on current line, and are not open and closed same line.
            // then this last line may need additional indent to avoid clashes
            // with the next. `indent.avoid_last_matching_next` controls this behavior,
            // for example this is needed for function parameters.

            avoidLastMatchingNext = meta.getBolean("indent.avoid_last_matching_next")
              ?: false
          }

          if (avoidLastMatchingNext) {
            // last line must be indented more in cases where
            // it would be same indent as next line (we determine this as one
            // width more than the open indent to avoid confusing with any
            // hanging indents)
            val osrowIndent = TextUtils.countLeadingSpaceCount(content.getLine(osrow), indentSize)
            if (indent <= osrowIndent + indentSize) {
              indent += indentSize
            }
          }

          isProcessed = true
          if (indentIsAbsolute) {
            // don't allow further indenting by parent nodes, this is an absolute position
            return indent
          }
        }
      }

      processedLines[srow] = processedLines.getOrDefault(srow, isProcessed)

      node = node.parent
    }

    return indent
  }

  private fun findDelimiter(content: Content, node: TSNode,
    delimiter: String): Pair<TSNode?, Boolean> {
    for (i in 0 until node.childCount) {
      val child = node.getChild(i)
      if (child.type != delimiter) {
        continue
      }

      val start = node.startPoint
      val end = node.endPoint
      val line = content.getLine(start.line)
      val escapedDelim = delimiter.replace(DELIMITER_REGEX, "\\\\$0")
      val trimmedAfterDelim = line.substring((end.column shr 1) + 1)
        .replace(Regex("""[\s$escapedDelim]*"""), "")
      return child to trimmedAfterDelim.isEmpty()
    }

    return null to false
  }

  /**
   * Get the indents from the query.
   *
   * @return The indent captures from the query. The returned map has the following structure :
   * ```
   * map[indentType][node_id] = capture
   * ```
   * where `indentType` is one of the indent types defined in [TreeSitterIndentProvider.Companion]`.IDENT_XXX`
   * and `node_id` is same as [TSNode.getNodeId].
   */
  private fun getIndents(
    query: TSQuery,
    cursor: TSQueryCursor
  ): IndentsContainer {
    val indents = IndentsContainer()

    var match: TSQueryMatch? = cursor.nextMatch()
    while (match != null) {
      for (capture in match.captures) {
        val captureName = query.getCaptureNameForId(capture.index)
        if (!indents.containsKey(captureName)) {
          log.warn("Unknown capture name in indents query: {}", captureName)
          continue
        }

        indents[captureName]!![capture.node.nodeId] = capture to match.metadata
      }
      match = cursor.nextMatch()
    }

    return indents
  }

  private inner class IndentsContainer {

    private val data = HashMap<String, MutableLongObjectMap<Pair<TSQueryCapture, TSQueryMatch.Metadata>>>(
      IDENT_TYP_COUNT)

    init {
      // pre-fill the indents type so we could report any unknown indent types later
      data[IDENT_AUTO] = mutableLongObjectMapOf()
      data[IDENT_BEGIN] = mutableLongObjectMapOf()
      data[IDENT_END] = mutableLongObjectMapOf()
      data[IDENT_DEDENT] = mutableLongObjectMapOf()
      data[IDENT_BRANCH] = mutableLongObjectMapOf()
      data[IDENT_IGNORE] = mutableLongObjectMapOf()
      data[IDENT_ALIGN] = mutableLongObjectMapOf()
      data[IDENT_ZERO] = mutableLongObjectMapOf()
    }

    fun containsKey(key: String): Boolean {
      return data.containsKey(key)
    }

    fun get(type: String, node: TSNode) = get(type, node.nodeId)
    fun get(type: String, nodeId: Long) = data[type]?.get(nodeId)

    fun hasNode(type: String, node: TSNode) = hasNode(type, node.nodeId)
    fun hasNode(type: String, nodeId: Long) = data[type]?.get(nodeId) != null

    fun hasMeta(type: String, node: TSNode, metaKey: String) = hasMeta(type, node.nodeId, metaKey)
    fun hasMeta(type: String, nodeId: Long, metaKey: String) =
      data[type]?.get(nodeId)?.second?.get<Any>(metaKey) != null

    fun getMeta(type: String, node: TSNode) = getMeta(type, node.nodeId)
    fun getMeta(type: String, nodeId: Long) = data[type]?.get(nodeId)?.second

    fun <T : Any?> getMetaValue(type: String, node: TSNode, metaKey: String) =
      getMetaValue<T>(type, node.nodeId, metaKey)

    fun <T : Any?> getMetaValue(type: String, nodeId: Long, metaKey: String) =
      data[type]?.get(nodeId)?.second?.get<T>(metaKey)

    operator fun get(
      key: String): MutableLongObjectMap<Pair<TSQueryCapture, TSQueryMatch.Metadata>>? {
      return data[key]
    }

    operator fun set(key: String,
      value: MutableLongObjectMap<Pair<TSQueryCapture, TSQueryMatch.Metadata>>) {
      data[key] = value
    }
  }
}

/**
 * Alias for [TSPoint.row].
 */
private val TSPoint.line: Int
  get() = this.row

private fun TSQueryMatch.Metadata.getInt(key: String) = getString(key).toIntOrNull()
private fun TSQueryMatch.Metadata.getBolean(key: String) = getString(key).toBooleanStrictOrNull()


================================================
File: java/com/itsaky/androidide/editor/language/treesitter/TreeSitterLanguage.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.content.Context
import com.itsaky.androidide.editor.language.IDELanguage
import com.itsaky.androidide.editor.language.newline.TSBracketsHandler
import com.itsaky.androidide.editor.language.utils.CommonSymbolPairs
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.editor.schemes.LanguageScheme
import com.itsaky.androidide.editor.schemes.LanguageSpecProvider.getLanguageSpec
import com.itsaky.androidide.editor.schemes.LocalCaptureSpecProvider.newLocalCaptureSpec
import com.itsaky.androidide.editor.utils.isNonBlankLine
import com.itsaky.androidide.treesitter.TSLanguage
import com.itsaky.androidide.utils.IntPair
import io.github.rosemoe.sora.editor.ts.TsTheme
import io.github.rosemoe.sora.lang.Language.INTERRUPTION_LEVEL_STRONG
import io.github.rosemoe.sora.lang.analysis.AnalyzeManager
import io.github.rosemoe.sora.text.ContentReference
import io.github.rosemoe.sora.widget.SymbolPairMatch
import org.slf4j.LoggerFactory
import java.io.File

/**
 * Tree Sitter language implementation.
 *
 * @author Akash Yadav
 */
abstract class TreeSitterLanguage(
  context: Context,
  lang: TSLanguage,
  private val langType: String
) : IDELanguage() {

  private var languageSpec =
    getLanguageSpec(context, langType, lang, newLocalCaptureSpec(langType))
  private var tsTheme = TsTheme(languageSpec.spec.tsQuery)
  private lateinit var _indentProvider: TreeSitterIndentProvider
  private val analyzer by lazy { TreeSitterAnalyzeManager(languageSpec.spec, tsTheme) }
  private val newlineHandlersLazy by lazy { createNewlineHandlers() }

  private var languageScheme: LanguageScheme? = null

  private val indentProvider: TreeSitterIndentProvider
    get() {
      if (!this::_indentProvider.isInitialized) {
        this._indentProvider = TreeSitterIndentProvider(
          languageSpec,
          analyzer.analyzeWorker!!,
          getTabSize()
        )
      }

      return _indentProvider
    }

  companion object {

    private val log = LoggerFactory.getLogger(TreeSitterLanguage::class.java)
    private const val DEF_IDENT_ADV = 0
  }

  fun setupWith(scheme: IDEColorScheme?) {
    val langScheme = scheme?.languages?.get(langType)
    this.languageScheme = langScheme
    this.analyzer.langScheme = languageScheme
    langScheme?.styles?.forEach { tsTheme.putStyleRule(it.key, it.value.makeStyle()) }
  }

  override fun addBreakpoint(line: Int) {
    this.analyzer.addBreakpoint(line)
  }

  override fun removeBreakpoint(line: Int) {
    this.analyzer.removeBreakpoint(line)
  }

  override fun removeAllBreakpoints() {
    this.analyzer.removeAllBreakpoints()
  }

  override fun toggleBreakpoint(line: Int) {
    this.analyzer.toggleBreakpoint(line)
  }

  override fun highlightLine(line: Int) {
    this.analyzer.highlightLine(line)
  }

  override fun unhighlightLines() {
    this.analyzer.unhighlightLines()
  }

  override fun getAnalyzeManager(): AnalyzeManager {
    return this.analyzer
  }

  override fun getSymbolPairs(): SymbolPairMatch {
    return CommonSymbolPairs()
  }

  open fun createNewlineHandlers(): Array<TSBracketsHandler> {
    return emptyArray()
  }

  override fun getNewlineHandlers(): Array<TSBracketsHandler> {
    return newlineHandlersLazy
  }

  override fun getInterruptionLevel(): Int {
    return INTERRUPTION_LEVEL_STRONG
  }

  override fun getIndentAdvance(
    content: ContentReference,
    line: Int,
    column: Int,
    spaceCountOnLine: Int,
    tabCountOnLine: Int
  ): Int {
    return try {
      if (line == content.reference.lineCount - 1) {
        // line + 1 does not exist
        // TODO(itsaky): Update this implementation when this behavior is fixed in sora-editor
        return DEF_IDENT_ADV
      }

      var linesToReq = LongArray(1)
      linesToReq[0] = IntPair.pack(line, column)

      if (content.reference.isNonBlankLine(line + 1)) {
        // consider the indentation of the next line only if it is non-blank
        linesToReq += IntPair.pack(line + 1, 0)
      }

      val indents = this.indentProvider.getIndentsForLines(
        content = content.reference,
        positions = linesToReq,
      )

      if (indents.size == 1) {
        val indent = indents[0]
        if (indent == TreeSitterIndentProvider.INDENTATION_ERR) {
          return DEF_IDENT_ADV
        }

        return indent - (spaceCountOnLine + (tabCountOnLine * getTabSize()))
      }

      val (indentLine, indentNxtLine) = indents
      if (indentLine == TreeSitterIndentProvider.INDENTATION_ERR
        || indentNxtLine == TreeSitterIndentProvider.INDENTATION_ERR) {
        log.debug(
          "expectedIndent[{}]={}, expectedIndentNextLine[{}]={}, returning default indent advance",
          line, indentLine, line + 1, indentNxtLine)
        return DEF_IDENT_ADV
      }

      return indentNxtLine - indentLine
    } catch (e: Exception) {
      log.error("An error occurred computing indentation at line:column::{}:{}", line, column, e)
      DEF_IDENT_ADV
    }

  }

  override fun destroy() {
    this.languageSpec.close()
    this.languageScheme = null
  }

  /** A [Factory] creates instance of a specific [TreeSitterLanguage] implementation. */
  fun interface Factory<T : TreeSitterLanguage> {

    /**
     * Create the instance of the [TreeSitterLanguage] implementation.
     *
     * @param context The current context.
     */
    fun create(context: Context): T
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/TreeSitterLanguageProvider.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.content.Context
import java.io.File

/**
 * Provides instance of [TreeSitterLanguage] implementations.
 *
 * @author Akash Yadav
 */
object TreeSitterLanguageProvider {

  fun hasTsLanguage(file: File) : Boolean {
    return TSLanguageRegistry.instance.hasLanguage(file.extension)
  }

  fun forFile(file: File, context: Context): TreeSitterLanguage? {
    if (!hasTsLanguage(file)) {
      return null
    }

    return forType(file.extension, context)
  }

  fun forType(type: String, context: Context): TreeSitterLanguage? {
    return try {
      TSLanguageRegistry.instance.getFactory<TreeSitterLanguage>(type).create(context)
    } catch (e: TSLanguageRegistry.NotRegisteredException) {
      null
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/TreeSitterLanguageSpec.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import com.itsaky.androidide.treesitter.TSLanguage
import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryError
import io.github.rosemoe.sora.editor.ts.TsLanguageSpec
import java.io.Closeable

/**
 * Extension of [TsLanguageSpec] for AndroidIDE.
 *
 * @author Akash Yadav
 */
class TreeSitterLanguageSpec
@JvmOverloads constructor(
  val spec: TsLanguageSpec,
  indentsQueryScm: String = ""
) : Closeable {

  // <editor-fold desc="Proxy properties">
  val language: TSLanguage
    get() = spec.language
  // </editor-fold>

  val indentsQuery: TSQuery? = if (indentsQueryScm.isBlank()) {
    TSQuery.EMPTY
  } else {
    TSQuery.create(language, indentsQueryScm)
      .let { if (it.canAccess()) it else null }
  }

  init {
    indentsQuery?.validateOrThrow(name = "indents")
  }

  override fun close() {
    indentsQuery?.close()
    if (spec.language.isExternal) {
      spec.language.close()
    }
    spec.close()
  }
}

private fun TSQuery.validateOrThrow(name: String) {
  if (errorType != TSQueryError.None) {
    throw IllegalArgumentException(
      "query(name:$name) parsing failed: ${errorType.name} at text offset $errorOffset")
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/TreeSitterSpanFactory.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.graphics.Color
import androidx.core.graphics.ColorUtils
import com.itsaky.androidide.editor.schemes.LanguageScheme
import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryCapture
import com.itsaky.androidide.utils.parseHexColor
import io.github.rosemoe.sora.editor.ts.spans.DefaultSpanFactory
import io.github.rosemoe.sora.editor.ts.spans.TsSpanFactory
import io.github.rosemoe.sora.lang.styling.Span
import io.github.rosemoe.sora.lang.styling.SpanFactory
import io.github.rosemoe.sora.lang.styling.Styles
import io.github.rosemoe.sora.lang.styling.span.SpanConstColorResolver
import io.github.rosemoe.sora.lang.styling.span.SpanExtAttrs
import io.github.rosemoe.sora.text.ContentReference
import org.slf4j.LoggerFactory

/**
 * [TsSpanFactory] for tree sitter languages.
 *
 * @author Akash Yadav
 */
class TreeSitterSpanFactory(
  private var content: ContentReference?,
  private var query: TSQuery?,
  private var styles: Styles?,
  private var langScheme: LanguageScheme?
) : DefaultSpanFactory() {

  companion object {

    private val log = LoggerFactory.getLogger(TreeSitterSpanFactory::class.java)

    @JvmStatic
    private val HEX_REGEX = "#\\b([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})\\b".toRegex()
  }

  override fun close() {
    content = null
    query = null
    styles = null
    langScheme = null
  }

  override fun createSpans(capture: TSQueryCapture, column: Int, spanStyle: Long): List<Span> {
    val content = this.content?.reference ?: return super.createSpans(capture, column, spanStyle)
    val query = this.query ?: return super.createSpans(capture, column, spanStyle)
    val langScheme = this.langScheme ?: return super.createSpans(capture, column, spanStyle)

    val captureName = query.getCaptureNameForId(capture.index)
    val styleDef = langScheme.getStyles()[captureName]
    if (styleDef?.maybeHexColor != true) {
      return super.createSpans(capture, column, spanStyle)
    }

    val (start, end) = content.indexer.run {
      getCharPosition(capture.node.startByte / 2) to getCharPosition(capture.node.endByte / 2)
    }

    if (start.line != end.line || start.column != column) {
      // A HEX color can only be defined on a single line
      return super.createSpans(capture, column, spanStyle)
    }

    val text = content.subContent(start.line, start.column, end.line, end.column)
    val results = HEX_REGEX.findAll(text)
    val spans = mutableListOf<Span>()
    var s = -1
    var e = -1
    results.forEach { result ->
      if (e != -1 && e < result.range.first) {
        // there is some interval between previous color span
        // and this color span
        // fill the gap
        spans.add(Span.obtain(column + e + 1, spanStyle))
      }

      if (s == -1) {
        s = result.range.first
      }
      e = result.range.last

      val color = try {
        parseHexColor(result.groupValues[1]).toInt()
      } catch (e: Exception) {
        log.error("An error occurred parsing hex color. text={}", text, e)
        return@forEach
      }

      val textColor = if (ColorUtils.calculateLuminance(color) > 0.5f) {
        Color.BLACK
      } else {
        Color.WHITE
      }

      val col = column + result.range.first
      val span = SpanFactory.obtain(
        col,
        styleDef.makeStaticStyle()
      )

      span.setSpanExt(SpanExtAttrs.EXT_COLOR_RESOLVER, SpanConstColorResolver(textColor, color))

      spans.add(span)
    }

    if (spans.isEmpty()) {
      return super.createSpans(capture, column, spanStyle)
    }

    // make sure that the default style is used for unmatched regions
    if (s != 0) {
      spans.add(0, SpanFactory.obtain(column, spanStyle))
    }

    if (e != text.lastIndex) {
      spans.add(SpanFactory.obtain(column + e + 1, spanStyle))
    }

    return spans
  }
}


================================================
File: java/com/itsaky/androidide/editor/language/treesitter/XMLLanguage.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import android.content.Context
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage.Factory
import com.itsaky.androidide.lsp.api.ILanguageServer
import com.itsaky.androidide.lsp.api.ILanguageServerRegistry
import com.itsaky.androidide.lsp.xml.XMLLanguageServer
import com.itsaky.androidide.treesitter.xml.TSLanguageXml
import io.github.rosemoe.sora.lang.Language.INTERRUPTION_LEVEL_STRONG
import io.github.rosemoe.sora.util.MyCharacter

/**
 * Tree Sitter language XML language.
 *
 * @author Akash Yadav
 */
class XMLLanguage(context: Context) :
  TreeSitterLanguage(context, lang = TSLanguageXml.getInstance(), langType = TS_TYPE) {

  override val languageServer: ILanguageServer?
    get() = ILanguageServerRegistry.getDefault().getServer(XMLLanguageServer.SERVER_ID)

  companion object {

    const val TS_TYPE = "xml"

    @JvmField
    val FACTORY = Factory { XMLLanguage(it) }
  }

  override fun checkIsCompletionChar(c: Char): Boolean {
    return MyCharacter.isJavaIdentifierPart(c) || c == '<' || c == '/'
  }

  override fun getInterruptionLevel(): Int {
    return INTERRUPTION_LEVEL_STRONG
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/common.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter

import com.itsaky.androidide.editor.schemes.LanguageScheme

typealias LangScheme = Pair<String, LanguageScheme>


================================================
File: java/com/itsaky/androidide/editor/language/treesitter/internal/TSLanguageRegistryImpl.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.internal

import com.itsaky.androidide.editor.language.treesitter.TSLanguageRegistry
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage
import java.util.concurrent.ConcurrentHashMap

/**
 * Default implementation of [TSLanguageRegistry].
 *
 * @author Akash Yadav
 */
class TSLanguageRegistryImpl : TSLanguageRegistry {

  private val registry =
    ConcurrentHashMap<String, TreeSitterLanguage.Factory<out TreeSitterLanguage>>()

  override fun <T : TreeSitterLanguage> register(
    fileType: String,
    factory: TreeSitterLanguage.Factory<T>
  ) {
    val older = registry.put(fileType, factory)
    if (older != null) {
      registry[fileType] = older
      throw TSLanguageRegistry.AlreadyRegisteredException(fileType)
    }
  }

  override fun hasLanguage(fileType: String): Boolean {
    return registry.containsKey(fileType)
  }

  @Suppress("UNCHECKED_CAST")
  override fun <T : TreeSitterLanguage> getFactory(
    fileType: String
  ): TreeSitterLanguage.Factory<T> {
    return (registry[fileType] ?: throw TSLanguageRegistry.NotRegisteredException(fileType))
        as TreeSitterLanguage.Factory<T>
  }

  override fun destroy() {
    registry.clear()
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/predicates/AnyOfPredicate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.predicates

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSQueryPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.PredicateResult
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCaptureContainer
import io.github.rosemoe.sora.editor.ts.predicate.builtin.getCaptureContent

/**
 * [TsPredicate] implementation for '#any-of?' query predicates.
 *
 * Syntax : `"#any-of?" @capture "string" ["string", ... ] Done`
 *
 * Checks if the text of `@capture` matches (literally) any of the `"string"` defined.
 *
 * @author Akash Yadav
 */
object AnyOfPredicate : TreeSitterPredicate() {

  override val name: String
    get() = "any-of"

  override fun canHandle(steps: List<TsClientPredicateStep>): Boolean {
    return steps.size > 4 &&
        steps.let {
          it[0].predicateType == TSQueryPredicateStep.Type.String &&
              it[1].predicateType == TSQueryPredicateStep.Type.Capture &&
              it[it.lastIndex].predicateType == TSQueryPredicateStep.Type.Done &&
              it.subList(2, it.lastIndex - 1).all { step ->
                step.predicateType == TSQueryPredicateStep.Type.String
              }
        }
  }

  override fun doPredicateInternal(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult {
    val captured = getCaptureContent(tsQuery, match, predicateSteps[1].content, text)
    val toMatch = predicateSteps.subList(2, predicateSteps.lastIndex - 1).map { it.content }
    for (capture in captured) {
      if (capture !in toMatch) {
        return PredicateResult.REJECT
      }
    }
    return PredicateResult.ACCEPT
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/predicates/EqualPredicate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.predicates

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSQueryPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.PredicateResult
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCaptureContainer
import io.github.rosemoe.sora.editor.ts.predicate.builtin.getCaptureContent

/**
 * [TsPredicate] implementation for '#eq?' query predicates.
 *
 * Syntax : `"#eq?" @capture @capture | "string" Done`
 *
 * Checks if the contents of the first capture is equal to the given string or contents of the
 * second capture.
 *
 * @author Akash Yadav
 */
object EqualPredicate : TreeSitterPredicate() {

  override val name: String
    get() = "eq"

  override fun canHandle(steps: List<TsClientPredicateStep>): Boolean {
    return steps.size == 4 &&
        steps[0].predicateType == TSQueryPredicateStep.Type.String &&
        steps[1].predicateType == TSQueryPredicateStep.Type.Capture &&
        steps[2].predicateType.let {
          it == TSQueryPredicateStep.Type.Capture || it == TSQueryPredicateStep.Type.String
        } &&
        steps[3].predicateType == TSQueryPredicateStep.Type.Done
  }

  override fun doPredicateInternal(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult {
    val first = getCaptureContent(tsQuery, match, predicateSteps[1].content, text)
    val second =
      predicateSteps[2].let {
        check(
          it.predicateType == TSQueryPredicateStep.Type.String ||
              it.predicateType == TSQueryPredicateStep.Type.Capture
        ) {
          "Second predicate step of #eq? predicate must be a string or a capture"
        }

        if (it.predicateType == TSQueryPredicateStep.Type.Capture) {
          getCaptureContent(tsQuery, match, it.content, text)
        } else {
          it.content
        }
      }

    return if (first == second) {
      PredicateResult.ACCEPT
    } else {
      PredicateResult.REJECT
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/predicates/InvertingPredicate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.predicates

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import io.github.rosemoe.sora.editor.ts.predicate.PredicateResult
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCaptureContainer

/**
 * A [TreeSitterPredicate] which inverts the result of another predicate.
 *
 * @author Akash Yadav
 */
open class InvertingPredicate(override val name: String,
  private val predicate: TreeSitterPredicate) :
  TreeSitterPredicate() {

  override fun canHandle(steps: List<TsClientPredicateStep>): Boolean {
    return predicate.canHandle(steps)
  }

  override fun doPredicateInternal(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult {
    return when (val result = this.predicate.doPredicateInternal(tsQuery, text, match,
      predicateSteps, syntheticCaptures)) {
      PredicateResult.ACCEPT -> PredicateResult.REJECT
      PredicateResult.REJECT -> PredicateResult.ACCEPT
      else -> result
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/predicates/MatchPredicate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.predicates

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import com.itsaky.androidide.treesitter.TSQueryPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.PredicateResult
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCaptureContainer
import io.github.rosemoe.sora.editor.ts.predicate.builtin.getCaptureContent
import io.github.rosemoe.sora.editor.ts.predicate.builtin.parametersMatch
import java.util.concurrent.ConcurrentHashMap
import java.util.regex.PatternSyntaxException

/**
 * [TsPredicate] implementation for '#match?' query predicates.
 *
 * @author Akash Yadav
 */
object MatchPredicate : TreeSitterPredicate() {

  override val name: String
    get() = "match"

  @JvmField
  val PARAMETERS =
    arrayOf(
      TSQueryPredicateStep.Type.String,
      TSQueryPredicateStep.Type.Capture,
      TSQueryPredicateStep.Type.String,
      TSQueryPredicateStep.Type.Done
    )

  private val cache = ConcurrentHashMap<String, Regex>()

  override fun doPredicateInternal(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult {
    val captured = getCaptureContent(tsQuery, match, predicateSteps[1].content, text)
    try {
      var regex = cache[predicateSteps[2].content]
      if (regex == null) {
        regex = Regex(predicateSteps[2].content)
        cache[predicateSteps[2].content] = regex
      }
      for (str in captured) {
        if (regex.find(str) == null) {
          return PredicateResult.REJECT
        }
      }
      return PredicateResult.ACCEPT
    } catch (e: PatternSyntaxException) {
      e.printStackTrace()
      return PredicateResult.UNHANDLED
    }
  }

  override fun canHandle(steps: List<TsClientPredicateStep>): Boolean {
    return parametersMatch(steps, PARAMETERS)
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/predicates/NotEqualPredicate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.predicates

import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate

/**
 * [TsPredicate] implementation for '#not-eq?' query predicates.
 *
 * Syntax : `"#not-eq?" @capture @capture | "string" Done`
 *
 * Checks if the contents of the first capture is NOT equal to the given string or contents of the
 * second capture.
 *
 * @author Akash Yadav
 */
object NotEqualPredicate : InvertingPredicate("not-eq", EqualPredicate)



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/predicates/NotMatchPredicate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.predicates

import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate

/**
 * [TsPredicate] implementation for '#not-match?' query predicates.
 *
 * @author Akash Yadav
 */
object NotMatchPredicate : InvertingPredicate("not-match", MatchPredicate)



================================================
File: java/com/itsaky/androidide/editor/language/treesitter/predicates/TreeSitterPredicate.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.treesitter.predicates

import com.itsaky.androidide.treesitter.TSQuery
import com.itsaky.androidide.treesitter.TSQueryMatch
import io.github.rosemoe.sora.editor.ts.predicate.PredicateResult
import io.github.rosemoe.sora.editor.ts.predicate.TsClientPredicateStep
import io.github.rosemoe.sora.editor.ts.predicate.TsPredicate
import io.github.rosemoe.sora.editor.ts.predicate.TsSyntheticCaptureContainer

/**
 * Base class for tree-sitter predicate implementations.
 *
 * @author Akash Yadav
 */
abstract class TreeSitterPredicate : TsPredicate {

  /** The name of the predicate that will be used to match. */
  abstract val name: String

  /**
   * Whether the implmentation can handle the given predicate steps.
   *
   * @param steps The predicate steps.
   * @return `true` if and only if the implementatin can handle the given predicate steps, `false`
   *   otherwise.
   */
  abstract fun canHandle(steps: List<TsClientPredicateStep>): Boolean

  /**
   * Performs the predicate check.
   *
   * @param tsQuery The [TSQuery] for the predicate.
   * @param text The editor text.
   * @param match The [TSQueryMatch] object.
   * @param predicateSteps The predicate steps.
   * @return The result of the predicate check.
   */
  internal abstract fun doPredicateInternal(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult

  override fun doPredicate(
    tsQuery: TSQuery,
    text: CharSequence,
    match: TSQueryMatch,
    predicateSteps: List<TsClientPredicateStep>,
    syntheticCaptures: TsSyntheticCaptureContainer
  ): PredicateResult {

    if (
      predicateSteps.isEmpty() ||
      predicateSteps[0].content != "${name}?" ||
      !canHandle(predicateSteps)
    ) {
      return PredicateResult.UNHANDLED
    }

    return doPredicateInternal(tsQuery, text, match, predicateSteps, syntheticCaptures)
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/utils/CommonSymbolPairs.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.utils

import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.widget.SymbolPairMatch
import io.github.rosemoe.sora.widget.SymbolPairMatch.SymbolPair.SymbolPairEx

/**
 * Common symbol pairs that can be used in any language.
 *
 * @author Akash Yadav
 */
internal open class CommonSymbolPairs : SymbolPairMatch() {

  private val isSelected =
    object : SymbolPairEx {
      override fun shouldDoAutoSurround(content: Content?): Boolean {
        return content?.cursor?.isSelected ?: false
      }
    }

  init {
    super.putPair('{', SymbolPair("{", "}"))
    super.putPair('(', SymbolPair("(", ")"))
    super.putPair('[', SymbolPair("[", "]"))
    super.putPair('"', SymbolPair("\"", "\"", isSelected))
    super.putPair('\'', SymbolPair("'", "'", isSelected))
  }
}



================================================
File: java/com/itsaky/androidide/editor/language/utils/CompletionHelper.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.language.utils

import io.github.rosemoe.sora.text.CharPosition
import io.github.rosemoe.sora.text.ContentReference

/**
 * Utility functions for completion providers.
 *
 * @author Akash Yadav
 */
object CompletionHelper {

  /**
   * Searches backward on the line, with the given checker to check chars.
   * Returns the longest text that matches the requirement.
   *
   * This is a variant of [CompletionHelper.computePrefix][io.github.rosemoe.sora.lang.completion.CompletionHelper.computePrefix]
   * which inlines the predicate for better performance.
   */
  inline fun computePrefix(
    ref: ContentReference, pos: CharPosition,
    checker: (Char) -> Boolean
  ): String {
    var begin = pos.column
    val line = ref.getLine(pos.line)
    while (begin > 0) {
      if (!checker(line[begin - 1])) {
        break
      }
      begin--
    }
    return line.substring(begin, pos.column)
  }
}


================================================
File: java/com/itsaky/androidide/editor/schemes/IDEColorScheme.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes

import androidx.collection.MutableIntIntMap
import com.itsaky.androidide.editor.schemes.internal.parser.SchemeParser
import com.itsaky.androidide.syntax.colorschemes.DynamicColorScheme
import io.github.rosemoe.sora.lang.styling.TextStyle
import io.github.rosemoe.sora.widget.schemes.EditorColorScheme
import java.io.File
import java.util.TreeSet

class IDEColorScheme(internal val file: File, val key: String) : DynamicColorScheme() {

  internal val colorIds = MutableIntIntMap()
  internal val editorScheme = MutableIntIntMap()
  internal val languages = mutableMapOf<String, LanguageScheme>()

  var name: String = ""
    internal set

  var version: Int = 0
    internal set

  var isDarkScheme: Boolean = false
    internal set

  var darkVariant: IDEColorScheme? = null
    internal set

  var definitions: Map<String, Int> = emptyMap()
    internal set

  private var colorId = endColorId

  internal fun load() {
    SchemeParser { name -> File(this.file.parentFile, name) }.load(this)
  }

  fun getLanguageScheme(type: String): LanguageScheme? {
    return this.languages[type]
  }

  internal fun putColor(color: Int): Int {
    this.colorIds[++colorId] = color
    return colorId
  }

  @Suppress("UNNECESSARY_SAFE_CALL", "USELESS_ELVIS")
  override fun getColor(type: Int): Int {
    // getColor is called in superclass constructor
    // in this case, the below properties will be null
    val defaultValue = super.getColor(type)
    return editorScheme?.getOrElse(type) {
      colorIds?.getOrDefault(type, defaultValue) ?: defaultValue
    } ?: defaultValue
  }

  override fun isDark(): Boolean {
    return this.isDarkScheme
  }
}

/**
 * Color scheme for a language.
 *
 * @property files The file types for this language color scheme.
 * @property styles The highlight styles.
 * @author Akash Yadav
 */
class LanguageScheme {

  internal val files = mutableListOf<String>()
  internal val styles = mutableMapOf<String, StyleDef>()
  internal val localScopes = TreeSet<String>()
  internal val localMembersScopes = TreeSet<String>()
  internal val localDefs = TreeSet<String>()
  internal val localDefVals = TreeSet<String>()
  internal val localRefs = TreeSet<String>()

  fun getFileTypes(): List<String> = files
  fun getStyles(): Map<String, StyleDef> = styles

  fun isLocalScope(capture: String): Boolean {
    return localScopes.contains(capture)
  }

  fun isMembersScope(capture: String): Boolean {
    return localMembersScopes.contains(capture)
  }

  fun isLocalDef(capture: String): Boolean {
    return localDefs.contains(capture)
  }

  fun isLocalDefVal(capture: String): Boolean {
    return localDefVals.contains(capture)
  }

  fun isLocalRef(capture: String): Boolean {
    return localRefs.contains(capture)
  }
}

/**
 * A color scheme style definition.
 *
 * @property fg The foreground color.
 * @property bg The background color.
 * @property bold Whether the highlighted region should have bold text.
 * @property italic Whether the highlighted region should have italic text.
 * @property strikeThrough Whether the highlighted region should have strikethrough text.
 * @property completion Whether code completions can be performed in the highlighted region.
 * @property maybeHexColor Whether the node represented by this style can contain HEX color strings.
 * If this value is `true`, the node's text will be parsed to check if it represents a valid HEX color.
 * If it does, that color will be used as the node's background color. The foreground color of the node
 * will be automatically selected based on the HEX color's brightness.
 */
data class StyleDef(
  var fg: Int = EditorColorScheme.TEXT_NORMAL,
  var bg: Int = 0,
  var bold: Boolean = false,
  var italic: Boolean = false,
  var strikeThrough: Boolean = false,
  var completion: Boolean = true,
  var maybeHexColor: Boolean = false
) {

  /**
   * Make the style for the style definition.
   *
   * @see TextStyle.makeStyle
   */
  fun makeStyle(): Long {
    return TextStyle.makeStyle(fg, bg, bold, italic, strikeThrough, !completion)
  }

  /**
   * Make the static style for this style definition. The background color ID in the returned style is
   * always [EditorColorScheme.STATIC_SPAN_BACKGROUND] and the foreground color ID is always
   * [EditorColorScheme.STATIC_SPAN_FOREGROUND].
   */
  fun makeStaticStyle(): Long {
    return TextStyle.makeStyle(
      EditorColorScheme.STATIC_SPAN_FOREGROUND,
      EditorColorScheme.STATIC_SPAN_BACKGROUND,
      bold,
      italic,
      strikeThrough,
      !completion
    )
  }
}



================================================
File: java/com/itsaky/androidide/editor/schemes/IDEColorSchemeProvider.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes

import android.content.Context
import androidx.annotation.WorkerThread
import com.itsaky.androidide.eventbus.events.editor.ColorSchemeInvalidatedEvent
import com.itsaky.androidide.preferences.internal.EditorPreferences
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import com.itsaky.androidide.utils.Environment
import com.itsaky.androidide.utils.isSystemInDarkMode
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.greenrobot.eventbus.EventBus
import org.slf4j.LoggerFactory
import java.io.File
import java.io.FileFilter
import java.util.Properties
import java.util.concurrent.ConcurrentHashMap
import kotlin.coroutines.CoroutineContext

/** @author Akash Yadav */
object IDEColorSchemeProvider {

  private val log = LoggerFactory.getLogger(IDEColorSchemeProvider::class.java)
  private val schemesDir = File(Environment.ANDROIDIDE_UI, "editor/schemes")

  private val schemes = ConcurrentHashMap<String, IDEColorScheme>()

  private const val SCHEME_NAME = "scheme.name"
  private const val SCHEME_VERSION = "scheme.version"
  private const val SCHEME_IS_DARK = "scheme.isDark"
  private const val SCHEME_FILE = "scheme.file"

  private var isDefaultSchemeLoaded = false
  private var isCurrentSchemeLoaded = false

  /**
   * The default color scheme.
   *
   * This property must not be accessed from the main thread as we may need to perform
   * I/O operations if the scheme isn't loaded yet.
   */
  private var defaultScheme: IDEColorScheme? = null
    get() {
      return field ?: getColorScheme(EditorPreferences.DEFAULT_COLOR_SCHEME).also { scheme ->
        field = scheme
        isDefaultSchemeLoaded = scheme != null
      }
    }

  /**
   * The current color scheme.
   *
   * This property must not be accessed from the main thread as we may need to perform
   * I/O operations if the scheme isn't loaded yet.
   */
  private var currentScheme: IDEColorScheme? = null
    get() {
      return field ?: getColorScheme(EditorPreferences.colorScheme).also { scheme ->
        field = scheme
        isCurrentSchemeLoaded = scheme != null
      }
    }

  /**
   * Get the color scheme with the given [name]. This reads the color schemes
   * from file system if the scheme isn't loaded yet.
   */
  @WorkerThread
  private fun getColorScheme(name: String): IDEColorScheme? {
    return schemes[name]?.also(this::loadColorScheme)
  }

  /**
   * Loads the given [color scheme][scheme], then returns the same [scheme].
   */
  private fun loadColorScheme(scheme: IDEColorScheme): IDEColorScheme? {
    return try {
      scheme.load()
      scheme.darkVariant?.load()
      scheme
    } catch (err: Exception) {
      log.error("An error occurred while loading color scheme '{}'", EditorPreferences.colorScheme,
        err)
      null
    }
  }

  /**
   * Initialize the color schemes. This lists the available color schemes
   * (by reading the `scheme.prop` file), but does not load them.
   */
  @JvmStatic
  @WorkerThread
  fun init() {
    val schemeDirs =
      schemesDir.listFiles(FileFilter { it.isDirectory && File(it, "scheme.prop").exists() })
        ?: run {
          log.error("No color schemes found")
          return
        }

    for (schemeDir in schemeDirs) {
      val prop = File(schemeDir, "scheme.prop")
      val props =
        try {
          prop.reader().use { reader ->
            Properties().apply { load(reader) }
          }
        } catch (err: Exception) {
          log.error("Failed to read properties for scheme '{}'", schemeDir.name)
          continue
        }

      val name = props.getProperty(SCHEME_NAME, "Unknown")
      val version = props.getProperty(SCHEME_VERSION, "0").toInt()
      val isDark = props.getProperty(SCHEME_IS_DARK, "false").toBoolean()
      val file =
        props.getProperty(SCHEME_FILE)
          ?: run {
            log.error(
              "Scheme '${schemeDir.name}' does not specify 'scheme.file' in scheme.prop file"
            )
            ""
          }

      if (version <= 0) {
        log.warn("Version code of color scheme '{}' must be set to >= 1", schemeDir)
      }

      if (file.isBlank()) {
        continue
      }

      val scheme = IDEColorScheme(File(schemeDir, file), schemeDir.name)
      scheme.name = name
      scheme.version = version
      scheme.isDarkScheme = isDark
      schemes[schemeDir.name] = scheme
    }

    schemes.values.forEach {
      it.darkVariant = schemes["${it.key}-dark"]
    }
  }

  /**
   * Initializes the color schemes if the no color schemes are available.
   *
   * @see init
   */
  @JvmStatic
  fun initIfNeeded() {
    if (this.schemes.isEmpty()) {
      init()
    }
  }

  /**
   * Reads the current color scheme asynchronously from file system if it is not already loaded,
   * then invokes the [callback].
   *
   * @param context Context used to determine whether the system is in dark mode.
   * @param coroutineScope The scope used to read the scheme asynchronously.
   * @param callback The callback to receive the [SchemeAndroidIDE] instance.
   * @see readScheme
   */
  @JvmOverloads
  fun readSchemeAsync(
    context: Context,
    coroutineScope: CoroutineScope,
    type: String? = null,
    callbackContext: CoroutineContext = Dispatchers.Main.immediate,
    callback: (SchemeAndroidIDE?) -> Unit
  ) {

    // If the scheme has already been loaded, do not bother to dispatch an IO coroutine
    // simply invoke the callback on the requested context providing the already loaded scheme
    val loadedScheme = if (isCurrentSchemeLoaded && (type == null || currentScheme?.getLanguageScheme(
        type) != null)
    ) {
      currentScheme
    } else if (isDefaultSchemeLoaded) {
      defaultScheme
    } else {
      null
    }

    if (loadedScheme != null) {
      coroutineScope.launch(callbackContext) {
        callback(readScheme(context, type))
      }
      return
    }

    // scheme has not been loaded
    // load the scheme using the IO dispatcher
    coroutineScope.launch(Dispatchers.IO) {
      val scheme = readScheme(context, type)
      withContext(callbackContext) {
        callback(scheme)
      }
    }
  }

  /**
   * Reads the current color scheme synchronously.
   *
   * @see readSchemeAsync
   */
  @JvmOverloads
  @WorkerThread
  fun readScheme(
    context: Context,
    type: String? = null
  ): SchemeAndroidIDE? {
    val scheme = getColorSchemeForType(type)
    if (scheme == null) {
      log.error("Failed to read color scheme")
      return null
    }

    val dark = scheme.darkVariant
    if (context.isSystemInDarkMode() && dark != null) {
      return dark
    }

    return scheme
  }

  /**
   * Get the color scheme for the given [file type][type]. If the current color scheme does not
   * support the given file type, the [default color scheme][defaultScheme] is returned.
   */
  @WorkerThread
  fun getColorSchemeForType(type: String?): IDEColorScheme? {
    if (type == null) {
      return currentScheme
    }

    return currentScheme?.let { scheme ->
      return@let if (scheme.getLanguageScheme(type) == null) {
        log.warn("Color scheme '{}' does not support '{}'", scheme.name, type)
        log.warn("Falling back to default color scheme")
        null
      } else {
        scheme
      }
    } ?: defaultScheme
  }

  /**
   * Get all available color schemes. The returned list does not include the `-dark` variant of
   * the color schemes.
   */
  fun list(): List<IDEColorScheme> {
    // filter out schemes that are dark variants of other schemes
    // schemes with both light and dark variant will be used according to system's dark mode
    return this.schemes.values.filter { !it.key.endsWith("-dark") }.toList()
  }

  /**
   * Destroy the loaded color schemes.
   */
  fun destroy() {
    this.schemes.clear()
    this.currentScheme = null
    this.isCurrentSchemeLoaded = false

    this.defaultScheme = null
    this.isDefaultSchemeLoaded = false
  }

  @WorkerThread
  fun reload() {
    destroy()
    init()
    // notify editors
    EventBus.getDefault().post(ColorSchemeInvalidatedEvent())
  }
}



================================================
File: java/com/itsaky/androidide/editor/schemes/LanguageSpecProvider.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes

import android.content.Context
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguageSpec
import com.itsaky.androidide.editor.language.treesitter.predicates.AnyOfPredicate
import com.itsaky.androidide.editor.language.treesitter.predicates.EqualPredicate
import com.itsaky.androidide.editor.language.treesitter.predicates.MatchPredicate
import com.itsaky.androidide.editor.language.treesitter.predicates.NotEqualPredicate
import com.itsaky.androidide.editor.language.treesitter.predicates.NotMatchPredicate
import com.itsaky.androidide.treesitter.TSLanguage
import io.github.rosemoe.sora.editor.ts.LocalsCaptureSpec
import io.github.rosemoe.sora.editor.ts.TsLanguageSpec
import org.slf4j.LoggerFactory
import java.io.FileNotFoundException

/**
 * Provides language spec instances for tree sitter languages.
 *
 * @author Akash Yadav
 */
object LanguageSpecProvider {

  private const val BASE_SPEC_PATH = "editor/treesitter"
  private val log = LoggerFactory.getLogger(LanguageSpecProvider::class.java)

  @JvmStatic
  @JvmOverloads
  fun getLanguageSpec(
    context: Context,
    type: String,
    lang: TSLanguage,
    localsCaptureSpec: LocalsCaptureSpec = LocalsCaptureSpec.DEFAULT
  ): TreeSitterLanguageSpec {
    val editorLangSpec =
      TsLanguageSpec(
        language = lang,
        highlightScmSource = readScheme(context, type, "highlights"),
        localsScmSource = readScheme(context, type, "locals"),
        codeBlocksScmSource = readScheme(context, type, "blocks"),
        bracketsScmSource = readScheme(context, type, "brackets"),
        localsCaptureSpec = localsCaptureSpec,
        predicates =
        listOf(
          MatchPredicate,
          NotMatchPredicate,
          EqualPredicate,
          NotEqualPredicate,
          AnyOfPredicate
        )
      )
    return TreeSitterLanguageSpec(
      spec = editorLangSpec,
      indentsQueryScm = readScheme(context, type, "indents")
    )
  }

  private fun readScheme(context: Context, type: String, name: String): String {
    return try {
      context.assets.open("${BASE_SPEC_PATH}/${type}/${name}.scm").reader().readText()
    } catch (e: Exception) {
      if (e !is FileNotFoundException) {
        // log everything except FileNotFoundException
        log.error("Failed to read scheme file {} for type {}", name, type, e)
      }
      ""
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/schemes/LocalCaptureSpecProvider.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes

import io.github.rosemoe.sora.editor.ts.LocalsCaptureSpec
import org.slf4j.LoggerFactory

/**
 * Provides local
 *
 * @author Akash Yadav
 */
object LocalCaptureSpecProvider {

  private val log = LoggerFactory.getLogger(LocalCaptureSpecProvider::class.java)

  @JvmStatic
  fun newLocalCaptureSpec(type: String): LocalsCaptureSpec {
    val lang =
      IDEColorSchemeProvider.getColorSchemeForType(type)?.languages?.get(type)
        ?: run {
          log.error(
            "Cannot create LocalsCaptureSpec. Failed to load current color scheme. Falling back to default implementation"
          )
          return LocalsCaptureSpec.DEFAULT
        }
    return object : LocalsCaptureSpec() {

      override fun isDefinitionCapture(captureName: String): Boolean {
        return lang.isLocalDef(captureName)
      }

      override fun isDefinitionValueCapture(captureName: String): Boolean {
        return lang.isLocalDefVal(captureName)
      }

      override fun isReferenceCapture(captureName: String): Boolean {
        return lang.isLocalRef(captureName)
      }

      override fun isScopeCapture(captureName: String): Boolean {
        return lang.isLocalScope(captureName)
      }

      override fun isMembersScopeCapture(captureName: String): Boolean {
        return lang.isMembersScope(captureName)
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/schemes/internal/parser/EditorSchemeParser.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes.internal.parser

import com.google.gson.stream.JsonReader
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.editor.schemes.internal.parser.SchemeParser.EditorColors

/**
 * Parses editor scheme from a JSON color scheme file.
 *
 * @author Akash Yadav
 */
class EditorSchemeParser(private val reader: JsonReader) {
  
  fun parse(scheme: IDEColorScheme) {
    scheme.apply {
      reader.beginObject()
      while (reader.hasNext()) {
        val color = EditorColors.forKey(reader.nextName())
        val value = reader.nextString()
        editorScheme[color.id] = parseColorValue(value, false)
      }
      reader.endObject()
    }
  }
}


================================================
File: java/com/itsaky/androidide/editor/schemes/internal/parser/LanguageParser.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes.internal.parser

import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonToken.BEGIN_OBJECT
import com.google.gson.stream.JsonToken.STRING
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.editor.schemes.LanguageScheme
import com.itsaky.androidide.editor.schemes.StyleDef

/**
 * Parses language definitions in JSON color scheme files.
 *
 * @author Akash Yadav
 */
class LanguageParser(private var reader: JsonReader) {

  fun parseLang(scheme: IDEColorScheme): LanguageScheme {
    return scheme.run {
      doParseLang()
    }
  }

  private fun IDEColorScheme.doParseLang(): LanguageScheme {
    reader.beginObject()
    val lang = LanguageScheme()
    while (reader.hasNext()) {
      var name = reader.nextName()
      when (name) {
        "types" -> parseLangTypes(lang)
        "local.scopes" -> parseLangLocalScopes(lang)
        "local.scopes.members" -> parseLangLocalsMembersScopes(lang)
        "local.definitions" -> parseLocalLangDefs(lang)
        "local.definitions.values" -> parseLocalLangDefVals(lang)
        "local.references" -> parseLocalLangRefs(lang)
        "styles" -> {
          reader.beginObject()
          while (reader.hasNext()) {
            name = reader.nextName()
            if (reader.peek() == BEGIN_OBJECT) {
              lang.styles[name] = parseStyleDef(reader)
            } else if (reader.peek() == STRING) {
              val color = parseColorValue(reader.nextString())
              lang.styles[name] = StyleDef(fg = color)
            } else throw ParseException("A style definition must an object or a string value")
          }
          reader.endObject()
        }
        else -> throw ParseException("Unexpected key '$name' in language object")
      }
    }
    reader.endObject()

    if (lang.files.isEmpty()) {
      throw ParseException("A language must specify the file types")
    }

    return lang
  }

  private fun parseLocalLangRefs(lang: LanguageScheme) {
    addArrStrings(lang.localRefs)
  }

  private fun parseLocalLangDefVals(lang: LanguageScheme) {
    addArrStrings(lang.localDefVals)
  }

  private fun parseLocalLangDefs(lang: LanguageScheme) {
    addArrStrings(lang.localDefs)
  }

  private fun parseLangLocalScopes(lang: LanguageScheme) {
    addArrStrings(lang.localScopes)
  }
  
  private fun parseLangLocalsMembersScopes(lang: LanguageScheme) {
    addArrStrings(lang.localMembersScopes)
  }

  private fun parseLangTypes(lang: LanguageScheme) {
    addArrStrings(lang.files)
  }

  private fun addArrStrings(collection: MutableCollection<String>) {
    reader.beginArray()
    while (reader.hasNext()) {
      collection.add(reader.nextString())
    }
    reader.endArray()
  }
}



================================================
File: java/com/itsaky/androidide/editor/schemes/internal/parser/ParseException.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes.internal.parser

import com.google.gson.JsonParseException

/**
 * Thrown when an error occurs while parsing the color scheme for editor.
 *
 * @author Akash Yadav
 */
class ParseException @JvmOverloads constructor(
  msg: String?,
  cause: Throwable? = null
) : JsonParseException(msg, cause)


================================================
File: java/com/itsaky/androidide/editor/schemes/internal/parser/SchemeParser.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes.internal.parser

import com.google.gson.stream.JsonReader
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import io.github.rosemoe.sora.widget.schemes.EditorColorScheme
import java.io.File

/**
 * Parses editor's color scheme.
 *
 * @author Akash Yadav
 */
class SchemeParser(private val resolveFileRef: (String) -> File) {

  enum class EditorColors(val key: String, val id: Int) {
    BG("bg", EditorColorScheme.WHOLE_BACKGROUND),
    LINE_CURRENT("line.current", EditorColorScheme.CURRENT_LINE),
    LINE_DIVIDER("line.divider", EditorColorScheme.LINE_DIVIDER),
    LINE_NUMBER("line.num", EditorColorScheme.LINE_NUMBER),
    LINE_NUMBER_CURRENT("line.num.current", EditorColorScheme.LINE_NUMBER_CURRENT),
    LINE_NUMBER_BACKGROUND("line.num.bg", EditorColorScheme.LINE_NUMBER_BACKGROUND),
    LINE_NUMBER_PANEL("line.num.panel", EditorColorScheme.LINE_NUMBER_PANEL),
    LINE_NUMBER_PANEL_TEXT("line.num.panel.text", EditorColorScheme.LINE_NUMBER_PANEL_TEXT),
    TEXT_NORMAL("text.normal", EditorColorScheme.TEXT_NORMAL),
    TEXT_SELECTED("text.selected", EditorColorScheme.TEXT_SELECTED),
    
    CURSOR("text.cursor", EditorColorScheme.SELECTION_INSERT),
    SELECTION_HANDLE("text.selection.handle", EditorColorScheme.SELECTION_HANDLE),
    UNDERLINE("text.underline", EditorColorScheme.UNDERLINE),
    
    MATCHED_TEXT_BACKGROUND("text.matched.bg", EditorColorScheme.MATCHED_TEXT_BACKGROUND),
    SELECTED_TEXT_BACKGROUND("text.selected.bg", EditorColorScheme.SELECTED_TEXT_BACKGROUND),
    SNIPPET_BG_EDITING("snippet.bg.editing", EditorColorScheme.SNIPPET_BACKGROUND_EDITING),
    SNIPPET_BG_INACTIVE("snippet.bg.inactive", EditorColorScheme.SNIPPET_BACKGROUND_INACTIVE),
    SNIPPET_BG_RELATED("snippet.bg.related", EditorColorScheme.SNIPPET_BACKGROUND_RELATED),
    SCROLL_BAR_THUMB("scrollbar.thumb", EditorColorScheme.SCROLL_BAR_THUMB),
    SCROLL_BAR_THUMB_PRESSED("scrollbar.thumb.pressed", EditorColorScheme.SCROLL_BAR_THUMB_PRESSED),
    SCROLL_BAR_TRACK("scrollbar.track", EditorColorScheme.SCROLL_BAR_TRACK),
    CODE_BLOCK_LINE("code.block.line", EditorColorScheme.BLOCK_LINE),
    CODE_BLOCK_LINE_CURRENT("code.block.line.current", EditorColorScheme.BLOCK_LINE_CURRENT),
    CODE_BLOCK_LINE_SIDE("code.block.line.side", EditorColorScheme.SIDE_BLOCK_LINE),
    COMPLETION_WINDOW_BG("completion.window.bg", EditorColorScheme.COMPLETION_WND_BACKGROUND),
    COMPLETION_WINDOW_OUTLINE("completion.window.outline", EditorColorScheme.COMPLETION_WND_CORNER),
    COMPLETION_WND_TEXT_LABEL(
      "completion.window.text.label",
      SchemeAndroidIDE.COMPLETION_WND_TEXT_LABEL
    ),
    COMPLETION_WND_TEXT_DETAIL(
      "completion.window.text.detail",
      SchemeAndroidIDE.COMPLETION_WND_TEXT_DETAIL
    ),
    COMPLETION_WND_TEXT_API("completion.window.text.api", SchemeAndroidIDE.COMPLETION_WND_TEXT_API),
    COMPLETION_WND_TEXT_TYPE(
      "completion.window.text.type",
      SchemeAndroidIDE.COMPLETION_WND_TEXT_TYPE
    ),
    COMPLETION_WND_BG_CURRENT_ITEM(
      "completion.window.item.current",
      SchemeAndroidIDE.COMPLETION_WND_BG_CURRENT_ITEM
    ),
    NON_PRINTABLE_CHAR("non_printable_char", EditorColorScheme.NON_PRINTABLE_CHAR),
    HIGHLIGHTED_DELIMITERS_UNDERLINE(
      "highlighted.delimiters.underline",
      EditorColorScheme.HIGHLIGHTED_DELIMITERS_UNDERLINE
    ),
    HIGHLIGHTED_DELIMITERS_BACKGROUND(
      "highlighted.delimiters.bg",
      EditorColorScheme.HIGHLIGHTED_DELIMITERS_BACKGROUND
    ),
    HIGHLIGHTED_DELIMITERS_FOREGROUND(
      "highlighted.delimiters.fg",
      EditorColorScheme.HIGHLIGHTED_DELIMITERS_FOREGROUND
    ),
    BREAKPOINT_INDICATOR(
      "breakpoint.line.indicator",
      SchemeAndroidIDE.BREAKPOINT_LINE_INDICATOR
    ),
    BREAKPOINT_LINE_BG(
      "breakpoint.line.bg",
      SchemeAndroidIDE.BREAKPOINT_LINE_BG
    );

    companion object {
      @JvmStatic
      fun forKey(key: String): EditorColors {
        return values().find { it.key == key }
          ?: throw IllegalArgumentException("No editor color scheme available for key: '$key'")
      }
    }
  }

  companion object {
    const val KEY_DEFINITIONS = "definitions"
    const val KEY_EDITOR = "editor"
    const val KEY_LANGUAGES = "languages"
  }

  fun parse(file: File, name: String, isDark: Boolean): IDEColorScheme {
    require(file.exists() && file.isFile) { "File does not exist or is not a file" }
    val scheme = IDEColorScheme(file, name)
    scheme.name = name
    scheme.isDarkScheme = isDark
    load(scheme)
    return scheme
  }
  
  internal fun load(scheme: IDEColorScheme) {
    JsonReader(scheme.file.reader()).use { reader ->
      reader.beginObject()
      while (reader.hasNext()) {
        when (reader.nextName()) {
          KEY_DEFINITIONS -> scheme.definitions = scheme.parseDefinitions(reader)
          KEY_EDITOR -> scheme.parseEditorScheme(reader, resolveFileRef)
          KEY_LANGUAGES -> scheme.parseLanguages(reader, resolveFileRef)
        }
      }
      reader.endObject()
  
      if (scheme.name.isBlank()) {
        throw ParseException("A color scheme must a valid name. Current name is '${scheme.name}'")
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/schemes/internal/parser/common.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.schemes.internal.parser

import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonToken.STRING
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.editor.schemes.LanguageScheme
import com.itsaky.androidide.editor.schemes.StyleDef
import com.itsaky.androidide.utils.parseHexColor
import java.io.File

/** @author Akash Yadav */
fun IDEColorScheme.parseEditorScheme(reader: JsonReader, resolveFileRef: (String) -> File) {
  val newReader = if (reader.peek() == STRING) {
    readerForFileRef(reader, "editor", resolveFileRef)
  } else reader

  try {
    EditorSchemeParser(newReader).parse(this)
  } finally {
    if (reader !== newReader) {
      newReader.close()
    }
  }
}

/**
 * Parses the color and returns the color ID. If [colorId] is `false`, returns the int color value
 * instead.
 */
fun IDEColorScheme.parseColorValue(value: String?, colorId: Boolean = true): Int {
  require(!value.isNullOrBlank()) { "Color value is not expected to be null or blank" }
  if (value[0] == '@') {
    val refName = value.substring(1)
    val refValue =
      definitions[refName] ?: throw ParseException("Referenced color '$value' not found")
    return if (colorId) refValue else colorIds.getOrDefault(refValue, 0)
  }

  if (value[0] == '#') {
    val color =
      try {
        parseHexColor(value).toInt()
      } catch (err: Throwable) {
        throw ParseException("Invalid hex color code: '$value'", err)
      }
    return if (colorId) putColor(color) else color
  }

  throw ParseException("Unsupported color value '$value'")
}

fun IDEColorScheme.parseDefinitions(reader: JsonReader): Map<String, Int> {
  val result = mutableMapOf<String, Int>()
  reader.beginObject()
  while (reader.hasNext()) {
    val name = reader.nextName()
    val value = reader.nextString()
    result[name] = parseColorValue(value)
  }
  reader.endObject()
  return result
}

fun IDEColorScheme.parseLanguages(reader: JsonReader, resolveFileRef: (String) -> File) {
  reader.beginArray()
  while (reader.hasNext()) {
    val lang = parseLanguage(reader, resolveFileRef)
    lang.files.forEach { languages[it] = lang }
  }
  reader.endArray()
}

fun IDEColorScheme.parseLanguage(
  reader: JsonReader,
  resolveFileRef: (String) -> File
): LanguageScheme {
  val newReader =
    if (reader.peek() == STRING) {
      readerForFileRef(reader, "language", resolveFileRef)
    } else reader

  return try {
    LanguageParser(newReader).parseLang(this)
  } finally {
    if (reader !== newReader) {
      newReader.close()
    }
  }
}

private fun readerForFileRef(reader: JsonReader, scheme: String,
  resolveFileRef: (String) -> File): JsonReader {
  val value = reader.nextString()
  if (value.length <= 1 || value[0] != '@') {
    throw ParseException("Expected a $scheme scheme file reference but was '$value'")
  }

  val langFile = resolveFileRef(value.substring(1))
  if (!langFile.exists() || !langFile.isFile) {
    throw ParseException("Referenced file does not exist or is not a file '$langFile'")
  }
  return JsonReader(langFile.reader())
}

fun IDEColorScheme.parseStyleDef(reader: JsonReader): StyleDef {
  reader.beginObject()
  val def = StyleDef(fg = 0)
  while (reader.hasNext()) {
    when (reader.nextName()) {
      "fg" -> def.fg = parseColorValue(reader.nextString())
      "bg" -> def.bg = parseColorValue(reader.nextString())
      "bold" -> def.bold = reader.nextBoolean()
      "italic" -> def.italic = reader.nextBoolean()
      "strikethrough" -> def.strikeThrough = reader.nextBoolean()
      "completion" -> def.completion = reader.nextBoolean()
      "maybeHexColor" -> def.maybeHexColor = reader.nextBoolean()
    }
  }
  if (def.fg == 0) {
    throw ParseException("A style definition must specify a valid foreground color")
  }
  reader.endObject()
  return def
}



================================================
File: java/com/itsaky/androidide/editor/snippets/AbstractSnippetVariableResolver.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.snippets

import io.github.rosemoe.sora.widget.snippet.variable.ISnippetVariableResolver

/**
 * Base class for snippet variable resolvers.
 *
 * @author Akash Yadav
 */
interface AbstractSnippetVariableResolver : ISnippetVariableResolver, AutoCloseable {
  override fun close() {
  }
}



================================================
File: java/com/itsaky/androidide/editor/snippets/FileVariableResolver.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.snippets

import com.itsaky.androidide.editor.ui.IDEEditor
import com.itsaky.androidide.projects.IProjectManager
import io.github.rosemoe.sora.widget.snippet.variable.FileBasedSnippetVariableResolver

/**
 * Resolver for resolving snippet variables related to the file opened in an editor.
 *
 * @author Akash Yadav
 */
class FileVariableResolver(editor: IDEEditor) : FileBasedSnippetVariableResolver(), AbstractSnippetVariableResolver {

  var editor: IDEEditor? = editor
    private set

  companion object {
    private const val TM_FILENAME = "TM_FILENAME"
    private const val TM_FILENAME_BASE = "TM_FILENAME_BASE"
    private const val TM_DIRECTORY = "TM_DIRECTORY"
    private const val TM_FILEPATH = "TM_FILEPATH"
    private const val RELATIVE_FILEPATH = "RELATIVE_FILEPATH"
  }

  override fun resolve(name: String): String {
    val file = editor?.file ?: return ""
    return when (name) {
      TM_FILENAME -> file.name
      TM_FILENAME_BASE -> file.nameWithoutExtension
      TM_DIRECTORY -> file.parentFile?.absolutePath ?: ""
      TM_FILEPATH -> file.absolutePath
      RELATIVE_FILEPATH -> file.relativeTo(IProjectManager.getInstance().projectDir).absolutePath
      else -> ""
    }
  }

  override fun getResolvableNames(): Array<String> {
    return arrayOf(TM_FILENAME, TM_FILENAME_BASE, TM_DIRECTORY, TM_FILEPATH, RELATIVE_FILEPATH)
  }

  override fun close() {
    editor = null
  }
}



================================================
File: java/com/itsaky/androidide/editor/snippets/WorkspaceVariableResolver.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.snippets

import com.itsaky.androidide.projects.IProjectManager
import io.github.rosemoe.sora.widget.snippet.variable.WorkspaceBasedSnippetVariableResolver

/**
 * Resolver for resolving snippet variables related to the opened workspace folder (project).
 *
 * @author Akash Yadav
 */
class WorkspaceVariableResolver :
  WorkspaceBasedSnippetVariableResolver(), AbstractSnippetVariableResolver {

  companion object {

    private const val WORKSPACE_NAME = "WORKSPACE_NAME"
    private const val WORKSPACE_FOLDER = "WORKSPACE_FOLDER"
  }

  override fun resolve(name: String): String {
    val directory = IProjectManager.getInstance().projectDir
    return when (name) {
      WORKSPACE_NAME -> directory.name
      WORKSPACE_FOLDER -> directory.absolutePath
      else -> ""
    }
  }

  override fun getResolvableNames(): Array<String> {
    return arrayOf(WORKSPACE_NAME, WORKSPACE_FOLDER)
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/AbstractPopupWindow.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import io.github.rosemoe.sora.widget.CodeEditor
import io.github.rosemoe.sora.widget.base.EditorPopupWindow
import org.slf4j.LoggerFactory

/**
 * Abstract class for all [IDEEditor] popup windows.
 *
 * @author Akash Yadav
 */
abstract class AbstractPopupWindow(editor: CodeEditor, features: Int) :
  EditorPopupWindow(editor, features) {

  companion object {

    private val log = LoggerFactory.getLogger(AbstractPopupWindow::class.java)
  }

  override fun show() {
    (editor as? IDEEditor)?.ensureWindowsDismissed()
    if (!editor.isAttachedToWindow) {
      log.error("Trying to show popup window '{}' when editor is not attached to window",
        javaClass.name)
      return
    }

    super.show()
  }

  override fun isShowing(): Boolean {
    @Suppress("UNNECESSARY_SAFE_CALL", "USELESS_ELVIS")
    return popup?.isShowing ?: false
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/BaseEditorWindow.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui;

import static android.view.View.MeasureSpec.AT_MOST;
import static android.view.View.MeasureSpec.makeMeasureSpec;
import static com.blankj.utilcode.util.SizeUtils.dp2px;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.util.TypedValue;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import androidx.annotation.NonNull;
import com.itsaky.androidide.resources.R;
import com.itsaky.androidide.utils.ContextUtilsKt;
import io.github.rosemoe.sora.widget.base.EditorPopupWindow;

/**
 * An {@link EditorPopupWindow} implementation which shows only a single textview.
 *
 * @author Akash Yadav
 */
public abstract class BaseEditorWindow extends AbstractPopupWindow {

  protected final TextView text;

  /**
   * Create a popup window for editor
   *
   * @param editor The editor
   * @see #FEATURE_SCROLL_AS_CONTENT
   * @see #FEATURE_SHOW_OUTSIDE_VIEW_ALLOWED
   * @see #FEATURE_HIDE_WHEN_FAST_SCROLL
   */
  public BaseEditorWindow(@NonNull IDEEditor editor) {
    super(editor, getFeatureFlags());

    this.text = onCreateTextView(editor);
    setContentView(onCreateContentView(editor.getContext()));
  }

  private static int getFeatureFlags() {
    return FEATURE_SCROLL_AS_CONTENT | FEATURE_SHOW_OUTSIDE_VIEW_ALLOWED;
  }

  protected View onCreateContentView(@NonNull Context context) {
    return this.text;
  }

  protected TextView onCreateTextView(@NonNull IDEEditor editor) {
    final var context = editor.getContext();
    final var dp4 = dp2px(4);
    final var dp8 = dp4 * 2;

    final var text = new TextView(context);
    text.setBackground(createBackground(context));
    text.setTextColor(ContextUtilsKt.resolveAttr(context, R.attr.colorOnPrimaryContainer));
    text.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14);
    text.setClickable(false);
    text.setFocusable(false);
    text.setPaddingRelative(dp8, dp4, dp8, dp4);
    text.setLayoutParams(
      new ViewGroup.LayoutParams(
        ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
    return text;
  }

  protected Drawable createBackground(final Context context) {
    GradientDrawable background = new GradientDrawable();
    background.setShape(GradientDrawable.RECTANGLE);
    background.setColor(ContextUtilsKt.resolveAttr(context, R.attr.colorSurface));
    background.setStroke(dp2px(1f), ContextUtilsKt.resolveAttr(context, R.attr.colorOutline));
    background.setCornerRadius(8);
    return background;
  }

  public void displayWindow() {
    final var dp16 = dp2px(16f);
    final int width = getEditor().getWidth() - dp16;
    final int height = getEditor().getHeight() - dp16;
    final var widthMeasureSpec = makeMeasureSpec(width, AT_MOST);
    final var heightMeasureSpec = makeMeasureSpec(height, AT_MOST);
    this.getRootView().measure(widthMeasureSpec, heightMeasureSpec);
    this.setSize(this.getRootView().getMeasuredWidth(), this.getRootView().getMeasuredHeight());

    final var line = getEditor().getCursor().getLeftLine();
    final var column = getEditor().getCursor().getLeftColumn();
    int x = (int) ((getEditor().getOffset(line, column) - (getWidth() / 2)));
    int y = (int) (getEditor().getRowHeight() * line) - getEditor().getOffsetY() - getHeight() - 5;
    setLocationAbsolutely(x, y);
    show();
  }

  protected View getRootView() {
    return this.text;
  }

  @NonNull
  @Override
  public IDEEditor getEditor() {
    return (IDEEditor) super.getEditor();
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/DiagnosticWindow.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */
package com.itsaky.androidide.editor.ui

import com.itsaky.androidide.lsp.models.DiagnosticItem

/**
 * Popup window used to show diagnostic messages.
 *
 * @author Akash Yadav
 */
class DiagnosticWindow(editor: IDEEditor) : BaseEditorWindow(editor) {
  /**
   * Show the given diagnostic item.
   *
   * @param diagnostic The diagnostic item to show.
   */
  fun showDiagnostic(diagnostic: DiagnosticItem?) {
    if (diagnostic == null) {
      if (isShowing) {
        dismiss()
      }
      return
    }
    val message = diagnostic.message
    text.text = message
    displayWindow()
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/EditorActionsMenu.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.annotation.SuppressLint
import android.content.res.ColorStateList
import android.graphics.RectF
import android.graphics.drawable.GradientDrawable
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.view.View.MeasureSpec
import android.view.ViewGroup
import androidx.appcompat.view.menu.MenuBuilder
import androidx.appcompat.view.menu.MenuItemImpl
import androidx.appcompat.view.menu.SubMenuBuilder
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.recyclerview.widget.RecyclerView.ViewHolder
import androidx.transition.ChangeBounds
import androidx.transition.TransitionManager
import com.blankj.utilcode.util.SizeUtils
import com.itsaky.androidide.actions.ActionData
import com.itsaky.androidide.actions.ActionItem
import com.itsaky.androidide.actions.ActionsRegistry
import com.itsaky.androidide.actions.ActionsRegistry.Companion.getInstance
import com.itsaky.androidide.actions.EditorActionItem
import com.itsaky.androidide.actions.FillMenuParams
import com.itsaky.androidide.editor.databinding.LayoutPopupMenuItemBinding
import com.itsaky.androidide.editor.ui.EditorActionsMenu.ActionsListAdapter.VH
import com.itsaky.androidide.lsp.api.ILanguageServerRegistry
import com.itsaky.androidide.lsp.java.JavaLanguageServer
import com.itsaky.androidide.lsp.models.DiagnosticItem
import com.itsaky.androidide.lsp.xml.XMLLanguageServer
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.resolveAttr
import io.github.rosemoe.sora.event.HandleStateChangeEvent
import io.github.rosemoe.sora.event.ScrollEvent
import io.github.rosemoe.sora.event.SelectionChangeEvent
import io.github.rosemoe.sora.event.SubscriptionReceipt
import io.github.rosemoe.sora.text.Cursor
import io.github.rosemoe.sora.widget.CodeEditor
import io.github.rosemoe.sora.widget.EditorTouchEventHandler
import java.io.File
import kotlin.math.max
import kotlin.math.min

/**
 * PopupMenu for showing editor's text and code actions.
 *
 * @author Akash Yadav
 */
@SuppressLint("RestrictedApi")
open class EditorActionsMenu(val editor: IDEEditor) :
  AbstractPopupWindow(editor, FEATURE_SHOW_OUTSIDE_VIEW_ALLOWED),
  ActionsRegistry.ActionExecListener,
  MenuBuilder.Callback {

  companion object {

    const val DELAY: Long = 200
  }

  private val touchHandler: EditorTouchEventHandler = editor.eventHandler
  private val receipts: MutableList<SubscriptionReceipt<*>> = mutableListOf()
  private val list = RecyclerView(editor.context)
  private var mLastScroll: Long = 0
  private var mLastPosition: Int = 0

  private val contentHeight by lazy {
    // approximated size is around 56dp
    SizeUtils.dp2px(56f)
  }

  private val menu: MenuBuilder = MenuBuilder(editor.context)
  protected open var location = ActionItem.Location.EDITOR_TEXT_ACTIONS

  open fun init() {
    subscribe()
    applyBackground()

    list.apply {
      clipChildren = true
      clipToOutline = true
      isVerticalFadingEdgeEnabled = true
      isVerticalScrollBarEnabled = true
      layoutParams =
        ViewGroup.LayoutParams(
          ViewGroup.LayoutParams.WRAP_CONTENT,
          ViewGroup.LayoutParams.WRAP_CONTENT
        )

      setFadingEdgeLength(SizeUtils.dp2px(42f))
      setPaddingRelative(paddingStart, paddingTop, SizeUtils.dp2px(16f), paddingBottom)
    }

    popup.contentView = this.list
    popup.animationStyle = R.style.PopupAnimation

    val menu = getMenu()
    if (menu is MenuBuilder) {
      menu.setCallback(this)
    }
  }

  open fun subscribe() {
    receipts.add(
      editor.subscribeEvent(SelectionChangeEvent::class.java) { event, _ ->
        this.onSelectionChanged(event)
      }
    )
    receipts.add(editor.subscribeEvent(ScrollEvent::class.java) { _, _ -> this.onScrollEvent() })
    receipts.add(
      editor.subscribeEvent(HandleStateChangeEvent::class.java) { event, _ ->
        this.onHandleStateChanged(event)
      }
    )
  }

  open fun unsubscribeEvents() {
    for (receipt in receipts) {
      receipt.unsubscribe()
    }
  }

  fun destroy() {
    if (this.receipts.isNotEmpty()) {
      unsubscribeEvents()
    }

    getInstance().unregisterActionExecListener(this)
  }

  protected open fun onSelectionChanged(event: SelectionChangeEvent) {
    if (touchHandler.hasAnyHeldHandle()) {
      return
    }
    if (event.isSelected) {
      editor.post { displayWindow(isShowing) }
      mLastPosition = -1
    } else {
      var show = false
      if (
        event.cause == SelectionChangeEvent.CAUSE_TAP &&
        event.left.index == mLastPosition &&
        !isShowing &&
        !editor.text.isInBatchEdit
      ) {
        editor.post(::displayWindow)
        show = true
      } else {
        dismiss()
      }
      mLastPosition =
        if (event.cause == SelectionChangeEvent.CAUSE_TAP && !show) {
          event.left.index
        } else {
          -1
        }
    }
  }

  protected open fun onScrollEvent() {
    val last = mLastScroll
    mLastScroll = System.currentTimeMillis()
    if (mLastScroll - last < DELAY) {
      postDisplay()
    }
  }

  protected open fun onHandleStateChanged(
    event: HandleStateChangeEvent,
  ) {
    if (event.isHeld) {
      postDisplay()
    }
  }

  protected open fun applyBackground() {
    val drawable = GradientDrawable()
    drawable.shape = GradientDrawable.RECTANGLE
    drawable.cornerRadius = SizeUtils.dp2px(28f).toFloat() // Recommeneded size is 28dp
    drawable.color = ColorStateList.valueOf(editor.context.resolveAttr(R.attr.colorSurface))
    drawable.setStroke(SizeUtils.dp2px(1f), editor.context.resolveAttr(R.attr.colorOutline))
    list.background = drawable
  }

  private fun postDisplay() {
    if (!isShowing) {
      return
    }
    dismiss()
    if (!editor.cursor.isSelected) {
      return
    }
    editor.postDelayed(
      object : Runnable {
        override fun run() {
          if (
            !touchHandler.hasAnyHeldHandle() &&
            System.currentTimeMillis() - mLastScroll > DELAY &&
            touchHandler.scroller.isFinished
          ) {
            displayWindow()
          } else {
            editor.postDelayed(this, DELAY)
          }
        }
      },
      DELAY
    )
  }

  private fun selectTop(rect: RectF): Int {
    val rowHeight = editor.rowHeight
    // when the window is being shown for the first time, the height is 0
    val height = if (this.height == 0) contentHeight else this.height
    return if (rect.top - rowHeight * 3 / 2f > height) {
      (rect.top - rowHeight * 3 / 2 - height).toInt()
    } else {
      (rect.bottom + rowHeight / 2).toInt()
    }
  }

  @JvmOverloads
  open fun displayWindow(update: Boolean = false) {
    var top: Int
    val cursor = editor.cursor
    top =
      if (cursor.isSelected) {
        val leftRect = editor.leftHandleDescriptor.position
        val rightRect = editor.rightHandleDescriptor.position
        val top1 = selectTop(leftRect)
        val top2 = selectTop(rightRect)
        min(top1, top2)
      } else {
        selectTop(editor.insertHandleDescriptor.position)
      }
    top = max(0, min(top, editor.height - height - 5))
    val handleLeftX = editor.getOffset(editor.cursor.leftLine, editor.cursor.leftColumn)
    val handleRightX = editor.getOffset(editor.cursor.rightLine, editor.cursor.rightColumn)
    val panelX = computePanelX(cursor, handleLeftX, handleRightX)
    setLocationAbsolutely(panelX, top)
    if (!update) {
      show()
    }
  }

  private fun computePanelX(cursor: Cursor, handleLeftX: Float, handleRightX: Float): Int {
    return if (cursor.isSelected) {
      ((handleLeftX + handleRightX) / 2f).toInt()
    } else {
      var x = (handleLeftX - (width / 2f)).toInt()
      if (x <= 0) {
        x = (handleRightX + SizeUtils.dp2px(10f)).toInt()
      } else if (x >= editor.width) {
        x = editor.width - SizeUtils.dp2px(10f)
      }
      x
    }
  }

  protected open fun fillMenu() {
    getMenu().clear()

    val data = onCreateActionData()

    val registry = getInstance()
    registry.registerActionExecListener(this)
    onFillMenu(registry, data)

    this.list.adapter = ActionsListAdapter(getMenu())
  }

  protected open fun onFillMenu(registry: ActionsRegistry, data: ActionData) {
    registry.fillMenu(FillMenuParams(data, onGetActionLocation(), getMenu()))
  }

  protected open fun onGetActionLocation() = location

  protected open fun onCreateActionData(): ActionData {
    val data = ActionData.create(editor.context)
    data.put(IDEEditor::class.java, this.editor)
    data.put(
      CodeEditor::class.java,
      editor
    ) // For LSP actions, as they cannot access IDEEditor class
    data.put(File::class.java, editor.file)
    data.put(DiagnosticItem::class.java, getDiagnosticAtCursor())
    data.put(com.itsaky.androidide.models.Range::class.java, editor.cursorLSPRange)
    data.put(
      JavaLanguageServer::class.java,
      ILanguageServerRegistry.getDefault().getServer(JavaLanguageServer.SERVER_ID)
          as? JavaLanguageServer?
    )
    data.put(
      XMLLanguageServer::class.java,
      ILanguageServerRegistry.getDefault().getServer(XMLLanguageServer.SERVER_ID)
          as? XMLLanguageServer?
    )
    return data
  }

  protected open fun getMenu(): Menu = menu

  private fun getDiagnosticAtCursor(): DiagnosticItem? {
    val start = editor.cursorLSPRange.start
    return editor.languageClient?.getDiagnosticAt(editor.file, start.line, start.column)
  }

  override fun onExec(action: ActionItem, result: Any) {
    if (action !is EditorActionItem || action.dismissOnAction()) {
      dismiss()
    }
  }

  override fun show() {
    if (list.parent != null) {
      (list.parent as ViewGroup).removeView(list)
    }

    this.list.layoutManager = LinearLayoutManager(editor.context, RecyclerView.HORIZONTAL, false)

    fillMenu()

    measureActionsList()

    val height = list.measuredHeight
    val width = min(editor.width - SizeUtils.dp2px(32f), list.measuredWidth)
    setSize(width, height)
    super.show()
  }

  private fun measureActionsList() {
    val dp8 = SizeUtils.dp2px(8f)
    val dp16 = dp8 * 2
    this.list.measure(
      MeasureSpec.makeMeasureSpec(editor.width - dp16 * 2, MeasureSpec.AT_MOST),
      MeasureSpec.makeMeasureSpec((260 * editor.dpUnit).toInt() - dp16 * 2, MeasureSpec.AT_MOST)
    )
  }

  private class ActionsListAdapter(val menu: Menu?, val forceShowTitle: Boolean = false) :
    RecyclerView.Adapter<VH>() {

    override fun getItemCount(): Int {
      return menu?.size() ?: 0
    }

    fun getItem(position: Int): MenuItem? = menu?.getItem(position)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
      return VH(
        LayoutPopupMenuItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
      )
    }

    override fun onBindViewHolder(holder: VH, position: Int) {
      val item = getItem(position) ?: return
      val button = holder.binding.root
      button.text = if (forceShowTitle) item.title else ""
      button.tooltipText = item.title

      button.icon =
        item.icon ?: run {
          button.text = item.title

          val widthSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)
          val heightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)
          button.measure(widthSpec, heightSpec)

          button.layoutParams.width = button.measuredWidth

          null
        }

      button.setOnClickListener {
        (item as MenuItemImpl).invoke()
      }
    }

    inner class VH(val binding: LayoutPopupMenuItemBinding) : ViewHolder(binding.root)
  }

  override fun onMenuItemSelected(menu: MenuBuilder, item: MenuItem): Boolean {
    // Click event of MenuItems without SubMenu is consumed by the ActionsRegistry
    // So we only need to handle click event of SubMenus
    if (!item.hasSubMenu()) {
      return false
    }

    if (item.hasSubMenu() && item.subMenu is SubMenuBuilder) {
      (item.subMenu as SubMenuBuilder).setCallback(this)
    }

    this.editor.post {
      TransitionManager.beginDelayedTransition(this.list, ChangeBounds())
      this.list.layoutManager = LinearLayoutManager(editor.context)
      this.list.adapter = ActionsListAdapter(item.subMenu, true)

      this.list.post {
        measureActionsList()
        val safeItemWidth = this.list.measuredWidth + this.list.paddingEnd + this.list.paddingStart
        popup.update(safeItemWidth, this.list.measuredHeight)
      }
    }

    return true
  }

  override fun onMenuModeChange(menu: MenuBuilder) {}
}



================================================
File: java/com/itsaky/androidide/editor/ui/EditorCompletionLayout.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.graphics.drawable.GradientDrawable
import android.view.ViewGroup
import android.view.ViewGroup.MarginLayoutParams
import androidx.core.view.updateLayoutParams
import com.itsaky.androidide.editor.R
import io.github.rosemoe.sora.widget.component.DefaultCompletionLayout
import io.github.rosemoe.sora.widget.schemes.EditorColorScheme

/**
 * An implementation of [DefaultCompletionLayout] which customizes some attributes of the default
 * completion window layout.
 *
 * @author Akash Yadav
 */
class EditorCompletionLayout : DefaultCompletionLayout() {

  override fun onApplyColorScheme(colorScheme: EditorColorScheme) {

    val resources = completionList.context.resources
    val cornerRadius = resources.getDimensionPixelSize(R.dimen.completion_window_corner_radius)
      .toFloat()

    val strokeWidth = resources
      .getDimensionPixelSize(R.dimen.completion_window_stroke_width)

    (completionList.parent as? ViewGroup?)?.background = GradientDrawable().apply {
      setCornerRadius(cornerRadius)
      setStroke(strokeWidth, colorScheme.getColor(EditorColorScheme.COMPLETION_WND_CORNER))
      setColor(colorScheme.getColor(EditorColorScheme.COMPLETION_WND_BACKGROUND))
    }

    if (completionList.layoutParams is MarginLayoutParams) {
      completionList.updateLayoutParams<MarginLayoutParams> {
        marginStart = strokeWidth
        topMargin = strokeWidth
        marginEnd = strokeWidth
        bottomMargin = strokeWidth
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/EditorCompletionWindow.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.app.Activity
import android.content.Intent
import android.util.Log
import android.widget.ListView
import com.itsaky.androidide.activities.editor.HelpActivity
import com.itsaky.androidide.idetooltips.IDETooltipItem
import com.itsaky.androidide.idetooltips.TooltipManager
import com.itsaky.androidide.lsp.util.DocumentationReferenceProvider
import com.itsaky.androidide.progress.ProgressManager
import com.itsaky.androidide.utils.KeyboardUtils
import io.github.rosemoe.sora.lang.completion.CompletionItem
import io.github.rosemoe.sora.widget.component.CompletionLayout
import io.github.rosemoe.sora.widget.component.EditorAutoCompletion
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.adfa.constants.CONTENT_KEY
import org.adfa.constants.CONTENT_TITLE_KEY
import org.slf4j.LoggerFactory
import java.lang.ref.WeakReference
import kotlin.math.min

/**
 * Completion window for the editor.
 *
 * @author Akash Yadav
 */
class EditorCompletionWindow(val editor: IDEEditor) : EditorAutoCompletion(editor) {

    private var listView: ListView? = null
    private val items: MutableList<CompletionItem> = mutableListOf()

    companion object {

        private val log = LoggerFactory.getLogger(EditorCompletionWindow::class.java)
    }

    init {
        setLayout(EditorCompletionLayout())
        setEnabledAnimation(true)
    }

    override fun isShowing(): Boolean {
        @Suppress("UNNECESSARY_SAFE_CALL", "USELESS_ELVIS")
        return popup?.isShowing ?: false
    }

    override fun setLayout(layout: CompletionLayout) {
        super.setLayout(layout)
        (layout.completionList as? ListView)?.let {
            listView = it
            it.adapter = this.adapter
            it.setOnItemLongClickListener { _, view, position, _ ->
                val data =
                    (items[position] as? com.itsaky.androidide.lsp.models.CompletionItem)?.data
                        ?: return@setOnItemLongClickListener false

                val tag = DocumentationReferenceProvider.getTag(data)
                    ?: return@setOnItemLongClickListener false

                // Dismiss the completion window before showing tooltip
                hide()

                val category = when (editor.file!!.extension) {
                    "java" -> "java"
                    "kt" -> "kotlin"
                    "xml" -> "xml"
                    else -> "ide"
                }
                Log.d("EditorCompletionWindow", "Showing tooltip for tag: $tag category: $category")

                val activity = editor.context as? Activity
                activity?.let { act ->


                    CoroutineScope(Dispatchers.Main).launch {
                        val item = TooltipManager.getTooltip(
                            context = editor.context,
                            category = category,
                            tag = tag
                        )

                        item?.let { tooltipData ->
                            TooltipManager.showIDETooltip(
                                editor.context,
                                editor,
                                0,
                                IDETooltipItem(
                                    tooltipCategory = category,
                                    tooltipTag = tooltipData.tooltipTag,
                                    detail = tooltipData.detail,
                                    summary = tooltipData.summary,
                                    buttons = tooltipData.buttons,
                                ),
                                { context, url, title ->
                                    val intent = Intent(context, HelpActivity::class.java).apply {
                                        putExtra(CONTENT_KEY, url)
                                        putExtra(CONTENT_TITLE_KEY, title)
                                    }
                                    context.startActivity(intent)
                                }
                            )
                        }
                    }
                }
                true
            }
        }
    }

    override fun select(pos: Int): Boolean {
        if (pos > adapter!!.count) {
            return false
        }
        return try {
            super.select(pos)
        } catch (e: Throwable) {
            log.warn("Unable to select completion item at {}", pos, e)
            false
        }
    }

    override fun select(): Boolean {
        return try {
            super.select()
        } catch (e: Throwable) {
            log.warn("Unable to select completion item", e)
            false
        }
    }

    override fun cancelCompletion() {
        if (completionThread != null) {
            ProgressManager.instance.cancel(completionThread)
        }
        super.cancelCompletion()
    }

    override fun requireCompletion() {
        if (cancelShowUp || !isEnabled || !editor.isAttachedToWindow) {
            return
        }

        val text = editor.text
        if (text.cursor.isSelected || checkNoCompletion()) {
            hide()
            return
        }

        if (System.nanoTime() - requestTime < editor.props.cancelCompletionNs) {
            hide()
            requestTime = System.nanoTime()
            return
        }

        cancelCompletion()
        requestTime = System.nanoTime()
        currentSelection = -1

        publisher =
            IDECompletionPublisher(
                editor.handler,
                {
                    val items = publisher.items

                    this.items.apply {
                        clear()
                        addAll(items)
                    }

                    if (lastAttachedItems == null || lastAttachedItems.get() != items) {
                        adapter.attachValues(this, items)
                        adapter.notifyDataSetInvalidated()
                        lastAttachedItems = WeakReference(items)
                    } else {
                        adapter.notifyDataSetChanged()
                    }

                    val newHeight = (adapter!!.itemHeight * adapter!!.count).toFloat()
                    if (newHeight == 0F) {
                        hide()
                    }

                    editor.getComponent(EditorAutoCompletion::class.java)
                        .updateCompletionWindowPosition()
                    setSize(width, min(newHeight, maxHeight.toFloat()).toInt())
                    if (!isShowing) {
                        show()
                    }

                    if (adapter!!.count >= 1
                        && KeyboardUtils.isHardKeyboardConnected(context)
                    ) {
                        currentSelection = 0
                    }
                },
                editor.editorLanguage.interruptionLevel
            )

        publisher.setUpdateThreshold(1)

        completionThread = CompletionThread(requestTime, publisher)
        completionThread.name = "CompletionThread-$requestTime"

        setLoading(true)

        completionThread.start()
    }

}



================================================
File: java/com/itsaky/androidide/editor/ui/EditorEventDispatcher.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import com.itsaky.androidide.eventbus.events.editor.DocumentChangeEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentCloseEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentOpenEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentSaveEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentSelectedEvent
import com.itsaky.androidide.projects.FileManager.onDocumentClose
import com.itsaky.androidide.projects.FileManager.onDocumentContentChange
import com.itsaky.androidide.projects.FileManager.onDocumentOpen
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.greenrobot.eventbus.EventBus
import org.slf4j.LoggerFactory
import java.util.concurrent.CancellationException
import java.util.concurrent.LinkedBlockingQueue

/**
 * Dispatches events for the editor.
 *
 * @author Akash Yadav
 */
class EditorEventDispatcher(
  var editor: IDEEditor? = null
) {

  private val eventQueue = LinkedBlockingQueue<DocumentEvent>()
  private var eventDispatcherJob: Job? = null

  companion object {

    private val log = LoggerFactory.getLogger(EditorEventDispatcher::class.java)
  }

  fun init(scope: CoroutineScope) {
    eventDispatcherJob = scope.launch(Dispatchers.Default) {
      while (isActive) {
        dispatchNextEvent()
      }
    }.also {
      it.invokeOnCompletion { error ->
        if (error != null && error !is CancellationException) {
          log.error("Failed to dispatch editor events", error)
        }
      }
    }
  }

  fun dispatch(event: DocumentEvent) {
    check(eventQueue.offer(event)) {
      "Failed to dispatch event: $event"
    }
  }

  private suspend fun dispatchNextEvent() {
    val event = withContext(Dispatchers.IO) {
      eventQueue.take()
    }

    if (editor?.isReleased != false) {
      return
    }

    when (event) {
      is DocumentOpenEvent -> dispatchOpen(event)
      is DocumentChangeEvent -> dispatchChange(event)
      is DocumentSaveEvent -> dispatchSave(event)
      is DocumentCloseEvent -> dispatchClose(event)
      is DocumentSelectedEvent -> dispatchSelected(event)
      else -> throw IllegalArgumentException("Unknown document event: $event")
    }
  }

  private fun dispatchOpen(event: DocumentOpenEvent) {
    onDocumentOpen(event)
    post(event)
  }

  private fun dispatchChange(event: DocumentChangeEvent) {
    onDocumentContentChange(event)
    post(event)
  }

  private fun dispatchSave(event: DocumentSaveEvent) {
    post(event)
  }

  private fun dispatchClose(event: DocumentCloseEvent) {
    onDocumentClose(event)
    post(event)
  }

  private fun dispatchSelected(event: DocumentSelectedEvent) {
    post(event)
  }

  private fun post(event: DocumentEvent) {
    EventBus.getDefault().post(event)
  }

  fun destroy() {
    editor = null
    eventDispatcherJob?.cancel(CancellationException("Cancellation requested"))
  }
}


================================================
File: java/com/itsaky/androidide/editor/ui/EditorFeatures.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import com.itsaky.androidide.editor.api.IEditor
import com.itsaky.androidide.editor.ui.IDEEditor.Companion.log
import com.itsaky.androidide.models.Position
import com.itsaky.androidide.models.Range
import io.github.rosemoe.sora.widget.SelectionMovement
import java.io.File

/**
 * Handler which implements various features in [IEditor].
 *
 * @author Akash Yadav
 */
class EditorFeatures(
  var editor: IDEEditor? = null
) : IEditor {

  override fun getFile(): File? = withEditor { _file }

  override fun isModified(): Boolean = withEditor { this.isModified } ?: false

  override fun setSelection(position: Position) {
    withEditor {
      setSelection(position.line, position.column)
    }
  }

  override fun setSelection(start: Position, end: Position) {
    withEditor {
      if (!isValidPosition(start, true) || !isValidPosition(end, true)) {
        log.warn("Invalid selection range: start={} end={}", start, end)
        return@withEditor
      }

      setSelectionRegion(start.line, start.column, end.line, end.column)
    }
  }

  override fun setSelectionAround(line: Int, column: Int) {
    withEditor {
      if (line < lineCount) {
        val columnCount = text.getColumnCount(line)
        setSelection(line, if (column > columnCount) columnCount else column)
      } else {
        setSelection(lineCount - 1, text.getColumnCount(lineCount - 1))
      }
    }
  }

  override fun getCursorLSPRange(): Range = withEditor {
    val end = cursor.right().let {
      Position(line = it.line, column = it.column, index = it.index)
    }
    return@withEditor Range(cursorLSPPosition, end)
  } ?: Range.NONE

  override fun getCursorLSPPosition(): Position = withEditor {
    return@withEditor cursor.left().let {
      Position(line = it.line, column = it.column, index = it.index)
    }
  } ?: Position.NONE

  override fun validateRange(range: Range) {
    withEditor {
      val start = range.start
      val end = range.end
      val text = text
      val lineCount = text.lineCount

      start.line = 0.coerceAtLeast(start.line).coerceAtMost(lineCount - 1)
      start.column = 0.coerceAtLeast(start.column).coerceAtMost(text.getColumnCount(start.line))

      end.line = 0.coerceAtLeast(end.line).coerceAtMost(lineCount - 1)
      end.column = 0.coerceAtLeast(end.column).coerceAtMost(text.getColumnCount(end.line))
    }
  }

  override fun isValidRange(range: Range?, allowColumnEqual: Boolean): Boolean = withEditor {
    if (range == null) {
      return@withEditor false
    }
    val start = range.start
    val end = range.end
    return@withEditor isValidPosition(start, allowColumnEqual)
        // make sure start position is before end position
        && isValidPosition(end, allowColumnEqual) && start < end
  } ?: false

  override fun isValidPosition(position: Position?, allowColumnEqual: Boolean): Boolean =
    withEditor {
      return@withEditor if (position == null) {
        false
      } else isValidLine(position.line) &&
          isValidColumn(position.line, position.column, allowColumnEqual)
    } ?: false

  override fun isValidLine(line: Int): Boolean =
    withEditor { line >= 0 && line < text.lineCount } ?: false

  override fun isValidColumn(line: Int, column: Int, allowColumnEqual: Boolean): Boolean =
    withEditor {
      val columnCount = text.getColumnCount(line)
      return@withEditor column >= 0 && (column < columnCount || allowColumnEqual && column == columnCount)
    } ?: false

  override fun append(text: CharSequence?): Int = withEditor {
    val content = getText()
    if (lineCount <= 0) {
      return@withEditor 0
    }

    val line = lineCount - 1
    var col = content.getColumnCount(line)
    if (col < 0) {
      col = 0
    }
    content.insert(line, col, text)
    return@withEditor line
  } ?: -1

  override fun replaceContent(newContent: CharSequence?) {
    withEditor {
      val lastLine = text.lineCount - 1
      val lastColumn = text.getColumnCount(lastLine)
      text.replace(0, 0, lastLine, lastColumn, newContent ?: "")
    }
  }

  override fun goToEnd() {
    withEditor {
      moveSelection(SelectionMovement.TEXT_END)
    }
  }

  private inline fun <T> withEditor(crossinline action: IDEEditor.() -> T): T? {
    return this.editor?.run {
      if (isReleased) {
        null
      } else action()
    }
  }
}


================================================
File: java/com/itsaky/androidide/editor/ui/EditorSearchLayout.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.annotation.SuppressLint
import android.content.Context
import android.text.TextUtils
import android.text.TextWatcher
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.inputmethod.EditorInfo
import android.widget.FrameLayout
import android.widget.PopupMenu
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.itsaky.androidide.editor.databinding.LayoutFindInFileBinding
import com.itsaky.androidide.editor.ui.ReplaceAction.doReplace
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.SingleTextWatcher
import io.github.rosemoe.sora.widget.EditorSearcher.SearchOptions
import java.util.regex.Pattern

/**
 * The search layout in [IDEEditor].
 *
 * @author Akash Yadav
 */
@SuppressLint("ViewConstructor") // Always created dynamically
class EditorSearchLayout(context: Context, val editor: IDEEditor) : FrameLayout(context) {

  private var searchInputTextWatcher: TextWatcher? = null
  private var searchOptions = SearchOptions(true, false)
  private val findInFileBinding: LayoutFindInFileBinding
  private val optionsMenu: PopupMenu

  private var isSearching = false

  init {
    findInFileBinding = LayoutFindInFileBinding.inflate(LayoutInflater.from(context))
    findInFileBinding.prev.setOnClickListener(::onSearchActionClick)
    findInFileBinding.next.setOnClickListener(::onSearchActionClick)
    findInFileBinding.replace.setOnClickListener(::onSearchActionClick)
    findInFileBinding.close.setOnClickListener(::onSearchActionClick)

    optionsMenu = PopupMenu(context, findInFileBinding.moreOptions, Gravity.TOP)
    optionsMenu.menu.add(0, 0, 0, R.string.msg_ignore_case).apply {
      isCheckable = true
      isChecked = true
    }

    optionsMenu.menu.add(0, 1, 0, R.string.msg_use_regex).apply {
      isCheckable = true
      isChecked = false
    }

    optionsMenu.setOnMenuItemClickListener {
      return@setOnMenuItemClickListener if (it.isCheckable) {
        it.isChecked = !it.isChecked

        val caseInsensitive = searchOptions.caseInsensitive
        val regex = searchOptions.type == SearchOptions.TYPE_REGULAR_EXPRESSION
        searchOptions =
          when (it.itemId) {
            0 -> SearchOptions(it.isChecked, regex)
            1 -> SearchOptions(caseInsensitive, it.isChecked)
            else -> searchOptions
          }
        editor.searcher.updateSearchOptions(searchOptions)

        true
      } else false
    }

    findInFileBinding.root.visibility = GONE
    findInFileBinding.moreOptions.setOnClickListener { optionsMenu.show() }

    addView(
      findInFileBinding.root,
      LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)
    )
  }

  fun beginSearchMode() {
    searchInputTextWatcher = SearchInputTextChangeListener(editor)
    findInFileBinding.searchInput.addTextChangedListener(searchInputTextWatcher)
    findInFileBinding.searchInput.setOnEditorActionListener { _, actionId, _ ->
      if (actionId == EditorInfo.IME_ACTION_NEXT) {
        onSearchActionClick(findInFileBinding.next)
      }
      false
    }
    findInFileBinding.root.visibility = VISIBLE

    findInFileBinding.searchInput.requestFocus()
    findInFileBinding.searchInput.post {
      ViewCompat.getWindowInsetsController(findInFileBinding.searchInput)?.show(WindowInsetsCompat.Type.ime())
    }
  }

  private fun onSearchActionClick(v: View) {
    val searcher = editor.searcher
    if (v.id == findInFileBinding.close.id) {
      if (this.searchInputTextWatcher == null) {
        return
      }
      findInFileBinding.searchInput.removeTextChangedListener(this.searchInputTextWatcher)
      findInFileBinding.root.visibility = GONE
      this.searchInputTextWatcher = null
      searcher.onClose()
    }
    if (!searcher.hasQuery()) {
      return
    }
    if (v.id == findInFileBinding.prev.id) {
      searcher.gotoPrevious()
      return
    }
    if (v.id == findInFileBinding.next.id) {
      searcher.gotoNext()
      return
    }
    if (v.id == findInFileBinding.replace.id) {
      doReplace(editor)
    }
  }

  inner class SearchInputTextChangeListener(val editor: IDEEditor?) : SingleTextWatcher() {

    override fun onTextChanged(
      s: CharSequence,
      start: Int,
      before: Int,
      count: Int,
    ) {
      if (editor == null) {
        return
      }
      if (TextUtils.isEmpty(s)) {
        editor.searcher.stopSearch()
        return
      }

      // Handle bad regexp
      val query =
        s.toString().let {
          if (searchOptions.type == SearchOptions.TYPE_REGULAR_EXPRESSION) {
            try {
              Pattern.compile(it)
              it
            } catch (error: Throwable) {
              ""
            }
          } else {
            it
          }
        }

      if (query.isNotBlank()) {
        editor.searcher.search(query, searchOptions)
      }
    }
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/IDECompletionPublisher.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.os.Handler
import io.github.rosemoe.sora.lang.completion.CompletionItem
import io.github.rosemoe.sora.lang.completion.CompletionPublisher

/**
 * [CompletionPublisher] implementation for AndroidIDE.
 *
 * @author Akash Yadav
 */
class IDECompletionPublisher(
  handler: Handler,
  callback: Runnable,
  languageInterruptionLevel: Int
) : CompletionPublisher(handler, callback, languageInterruptionLevel) {

  init {
    setUpdateThreshold(1)
  }

  /**
   * Adds the given [completion items][items] to the completion list.
   */
  fun <CompletionItemT : CompletionItem> addLSPItems(items: Collection<CompletionItemT>) {
    super.addItems(items)
  }
}


================================================
File: java/com/itsaky/androidide/editor/ui/IDEEditor.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.content.Context
import android.graphics.Rect
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.AttributeSet
import android.view.inputmethod.EditorInfo
import androidx.annotation.StringRes
import com.blankj.utilcode.util.FileUtils
import com.blankj.utilcode.util.SizeUtils
import com.itsaky.androidide.editor.R.string
import com.itsaky.androidide.editor.adapters.CompletionListAdapter
import com.itsaky.androidide.editor.api.IEditor
import com.itsaky.androidide.editor.api.ILspEditor
import com.itsaky.androidide.editor.events.FileUpdateEvent
import com.itsaky.androidide.editor.events.LanguageUpdateEvent
import com.itsaky.androidide.editor.language.IDELanguage
import com.itsaky.androidide.editor.language.cpp.CppLanguage
import com.itsaky.androidide.editor.language.groovy.GroovyLanguage
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguage
import com.itsaky.androidide.editor.language.treesitter.TreeSitterLanguageProvider
import com.itsaky.androidide.editor.schemes.IDEColorScheme
import com.itsaky.androidide.editor.schemes.IDEColorSchemeProvider
import com.itsaky.androidide.editor.snippets.AbstractSnippetVariableResolver
import com.itsaky.androidide.editor.snippets.FileVariableResolver
import com.itsaky.androidide.editor.snippets.WorkspaceVariableResolver
import com.itsaky.androidide.eventbus.events.editor.ChangeType
import com.itsaky.androidide.eventbus.events.editor.ColorSchemeInvalidatedEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentChangeEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentCloseEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentOpenEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentSaveEvent
import com.itsaky.androidide.eventbus.events.editor.DocumentSelectedEvent
import com.itsaky.androidide.flashbar.Flashbar
import com.itsaky.androidide.lsp.api.ILanguageClient
import com.itsaky.androidide.lsp.api.ILanguageServer
import com.itsaky.androidide.lsp.java.utils.CancelChecker
import com.itsaky.androidide.lsp.models.Command
import com.itsaky.androidide.lsp.models.DefinitionParams
import com.itsaky.androidide.lsp.models.DefinitionResult
import com.itsaky.androidide.lsp.models.ExpandSelectionParams
import com.itsaky.androidide.lsp.models.ReferenceParams
import com.itsaky.androidide.lsp.models.ReferenceResult
import com.itsaky.androidide.lsp.models.ShowDocumentParams
import com.itsaky.androidide.lsp.models.SignatureHelp
import com.itsaky.androidide.lsp.models.SignatureHelpParams
import com.itsaky.androidide.models.Position
import com.itsaky.androidide.models.Range
import com.itsaky.androidide.preferences.internal.EditorPreferences
import com.itsaky.androidide.progress.ICancelChecker
import com.itsaky.androidide.syntax.colorschemes.DynamicColorScheme
import com.itsaky.androidide.syntax.colorschemes.SchemeAndroidIDE
import com.itsaky.androidide.tasks.JobCancelChecker
import com.itsaky.androidide.tasks.cancelIfActive
import com.itsaky.androidide.tasks.launchAsyncWithProgress
import com.itsaky.androidide.utils.DocumentUtils
import com.itsaky.androidide.utils.flashError
import io.github.rosemoe.sora.event.ContentChangeEvent
import io.github.rosemoe.sora.event.SelectionChangeEvent
import io.github.rosemoe.sora.lang.EmptyLanguage
import io.github.rosemoe.sora.lang.Language
import io.github.rosemoe.sora.widget.CodeEditor
import io.github.rosemoe.sora.widget.EditorSearcher
import io.github.rosemoe.sora.widget.IDEEditorSearcher
import io.github.rosemoe.sora.widget.component.EditorAutoCompletion
import io.github.rosemoe.sora.widget.component.EditorBuiltinComponent
import io.github.rosemoe.sora.widget.component.EditorTextActionWindow
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.greenrobot.eventbus.EventBus
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode
import org.slf4j.LoggerFactory
import java.io.File

/**
 * [CodeEditor] implementation for the IDE.
 *
 * @author Akash Yadav
 */
open class IDEEditor @JvmOverloads constructor(
  context: Context,
  attrs: AttributeSet? = null,
  defStyleAttr: Int = 0,
  defStyleRes: Int = 0,
  private val editorFeatures: EditorFeatures = EditorFeatures()
) : CodeEditor(context, attrs, defStyleAttr, defStyleRes), IEditor by editorFeatures, ILspEditor {

  @Suppress("PropertyName")
  internal var _file: File? = null

  private var _actionsMenu: EditorActionsMenu? = null
  private var _signatureHelpWindow: SignatureHelpWindow? = null
  private var _diagnosticWindow: DiagnosticWindow? = null
  private var fileVersion = 0
  internal var isModified = false

  private val selectionChangeHandler = Handler(Looper.getMainLooper())
  private var selectionChangeRunner: Runnable? = Runnable {
    val languageClient = languageClient ?: return@Runnable
    val cursor = this.cursor ?: return@Runnable

    if (cursor.isSelected || _signatureHelpWindow?.isShowing == true) {
      return@Runnable
    }

    diagnosticWindow.showDiagnostic(
      languageClient.getDiagnosticAt(file, cursor.leftLine, cursor.leftColumn))
  }

  /**
   * The [CoroutineScope] for the editor.
   *
   * All the jobs in this scope are cancelled when the editor is released.
   */
  val editorScope = CoroutineScope(Dispatchers.Default + CoroutineName("IDEEditor"))

  protected val eventDispatcher = EditorEventDispatcher()

  private var setupTsLanguageJob: Job? = null
  private var sigHelpCancelChecker: ICancelChecker? = null

  var languageServer: ILanguageServer? = null
    private set

  var languageClient: ILanguageClient? = null
    private set

  /**
   * Whether the cursor position change animation is enabled for the editor.
   */
  var isEnsurePosAnimEnabled = true

  /**
   * The text searcher for the editor.
   */
  lateinit var searcher: IDEEditorSearcher

  /**
   * The signature help window for the editor.
   */
  val signatureHelpWindow: SignatureHelpWindow
    get() {
      return _signatureHelpWindow ?: SignatureHelpWindow(this).also { _signatureHelpWindow = it }
    }

  /**
   * The diagnostic window for the editor.
   */
  val diagnosticWindow: DiagnosticWindow
    get() {
      return _diagnosticWindow ?: DiagnosticWindow(this).also { _diagnosticWindow = it }
    }

  companion object {

    private const val SELECTION_CHANGE_DELAY = 500L

    internal val log = LoggerFactory.getLogger(IDEEditor::class.java)

    /**
     * Create input type flags for the editor.
     */
    fun createInputTypeFlags(): Int {
      var flags = EditorInfo.TYPE_CLASS_TEXT or EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE or EditorInfo.TYPE_TEXT_FLAG_NO_SUGGESTIONS
      if (EditorPreferences.visiblePasswordFlag) {
        flags = flags or EditorInfo.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD
      }
      return flags
    }
  }

  init {
    run {
      editorFeatures.editor = this
      eventDispatcher.editor = this
      eventDispatcher.init(editorScope)
      initEditor()
    }
  }

  /**
   * Set the file for this editor.
   */
  fun setFile(file: File?) {
    if (isReleased) {
      return
    }

    this._file = file
    dispatchEvent(FileUpdateEvent(file, this))

    file?.also {
      dispatchDocumentOpenEvent()
    }
  }

  override fun setLanguageServer(server: ILanguageServer?) {
    if (isReleased) {
      return
    }
    this.languageServer = server
    server?.also {
      this.languageClient = it.client
      snippetController.apply {
        fileVariableResolver = FileVariableResolver(this@IDEEditor)
        workspaceVariableResolver = WorkspaceVariableResolver()
      }
    }
  }

  override fun setLanguageClient(client: ILanguageClient?) {
    if (isReleased) {
      return
    }
    this.languageClient = client
  }

  override fun executeCommand(command: Command?) {
    if (isReleased) {
      return
    }
    if (command == null) {
      log.warn("Cannot execute command in editor. Command is null.")
      return
    }

    log.info(String.format("Executing command '%s' for completion item.", command.title))
    when (command.command) {
      Command.TRIGGER_COMPLETION -> {
        val completion = getComponent(EditorAutoCompletion::class.java)
        completion.requireCompletion()
      }

      Command.TRIGGER_PARAMETER_HINTS -> signatureHelp()
      Command.FORMAT_CODE -> formatCodeAsync()
    }
  }

  override fun signatureHelp() {
    if (isReleased) {
      return
    }
    val languageServer = this.languageServer ?: return
    val file = this.file ?: return

    this.languageClient ?: return

    sigHelpCancelChecker?.also { it.cancel() }

    val cancelChecker = JobCancelChecker().also {
      this.sigHelpCancelChecker = it
    }

    editorScope.launch(Dispatchers.Default) {
      cancelChecker.job = coroutineContext[Job]

      val help = safeGet("signature help request") {
        val params = SignatureHelpParams(file.toPath(), cursorLSPPosition, cancelChecker)
        languageServer.signatureHelp(params)
      }

      withContext(Dispatchers.Main) {
        showSignatureHelp(help)
      }
    }.logError("signature help request")
  }

  override fun showSignatureHelp(help: SignatureHelp?) {
    if (isReleased) {
      return
    }
    signatureHelpWindow.setupAndDisplay(help)
  }

  override fun findDefinition() {
    if (isReleased) {
      return
    }
    val languageServer = this.languageServer ?: return
    val file = file ?: return

    launchCancellableAsyncWithProgress(string.msg_finding_definition) { _, cancelChecker ->
      val result = safeGet("definition request") {
        val params = DefinitionParams(file.toPath(), cursorLSPPosition, cancelChecker)
        languageServer.findDefinition(params)
      }

      onFindDefinitionResult(result)
    }?.logError("definition request")
  }

  override fun findReferences() {
    if (isReleased) {
      return
    }
    val languageServer = this.languageServer ?: return
    val file = file ?: return

    launchCancellableAsyncWithProgress(string.msg_finding_references) { _, cancelChecker ->
      val result = safeGet("references request") {
        val params = ReferenceParams(file.toPath(), cursorLSPPosition, true, cancelChecker)
        languageServer.findReferences(params)
      }

      onFindReferencesResult(result)
    }?.logError("references request")
  }

  override fun expandSelection() {
    if (isReleased) {
      return
    }
    val languageServer = this.languageServer ?: return
    val file = file ?: return

    launchCancellableAsyncWithProgress(string.please_wait) { _, _ ->
      val initialRange = cursorLSPRange
      val result = safeGet("expand selection request") {
        val params = ExpandSelectionParams(file.toPath(), initialRange)
        languageServer.expandSelection(params)
      } ?: initialRange

      withContext(Dispatchers.Main) {
        setSelection(result)
      }
    }?.logError("expand selection request")
  }

  override fun ensureWindowsDismissed() {
    if (_diagnosticWindow?.isShowing == true) {
      _diagnosticWindow?.dismiss()
    }

    if (_signatureHelpWindow?.isShowing == true) {
      _signatureHelpWindow?.dismiss()
    }

    if (_actionsMenu?.isShowing == true) {
      _actionsMenu?.dismiss()
    }
  }

  // not overridable!
  final override fun <T : EditorBuiltinComponent?> replaceComponent(clazz: Class<T>,
    replacement: T & Any) {
    super.replaceComponent(clazz, replacement)
  }

  // not overridable
  final override fun <T : EditorBuiltinComponent?> getComponent(clazz: Class<T>): T & Any {
    return super.getComponent(clazz)
  }

  override fun release() {
    ensureWindowsDismissed()

    if (isReleased) {
      return
    }

    super.release()

    snippetController.apply {
      (fileVariableResolver as? AbstractSnippetVariableResolver?)?.close()
      (workspaceVariableResolver as? AbstractSnippetVariableResolver?)?.close()

      fileVariableResolver = null
      workspaceVariableResolver = null
    }

    _actionsMenu?.destroy()

    _actionsMenu = null
    _signatureHelpWindow = null
    _diagnosticWindow = null

    languageServer = null
    languageClient = null

    _file = null
    fileVersion = 0
    markUnmodified()

    editorFeatures.editor = null
    eventDispatcher.editor = null

    eventDispatcher.destroy()

    selectionChangeRunner?.also { selectionChangeHandler.removeCallbacks(it) }
    selectionChangeRunner = null

    if (EventBus.getDefault().isRegistered(this)) {
      EventBus.getDefault().unregister(this)
    }

    setupTsLanguageJob?.cancel("Editor is releasing resources.")

    if (editorScope.isActive) {
      editorScope.cancelIfActive("Editor is releasing resources.")
    }
  }

  override fun getSearcher(): EditorSearcher {
    return this.searcher
  }

  override fun getExtraArguments(): Bundle {
    return super.getExtraArguments().apply {
      putString(IEditor.KEY_FILE, file?.absolutePath)
    }
  }

  override fun ensurePositionVisible(line: Int, column: Int, noAnimation: Boolean) {
    super.ensurePositionVisible(line, column, !isEnsurePosAnimEnabled || noAnimation)
  }

  override fun getTabWidth(): Int {
    return EditorPreferences.tabSize
  }

  override fun beginSearchMode() {
    throw UnsupportedOperationException(
      "Search ActionMode is not supported. Use CodeEditorView.beginSearch() instead.")
  }

  override fun onFocusChanged(gainFocus: Boolean, direction: Int, previouslyFocusedRect: Rect?) {
    super.onFocusChanged(gainFocus, direction, previouslyFocusedRect)
    if (!gainFocus) {
      ensureWindowsDismissed()
    }
  }

  /**
   * Analyze the opened file and publish the diagnostics result.
   */
  open fun analyze() {
    if (isReleased) {
      return
    }
    if (editorLanguage !is IDELanguage) {
      return
    }

    val languageServer = languageServer ?: return
    val file = file ?: return

    editorScope.launch {
      val result = safeGet("LSP file analysis") { languageServer.analyze(file.toPath()) }
      languageClient?.publishDiagnostics(result)
    }.logError("LSP file analysis")
  }

  /**
   * Mark this editor as NOT modified.
   */
  open fun markUnmodified() {
    this.isModified = false
  }

  /**
   * Mark this editor as modified.
   */
  open fun markModified() {
    this.isModified = true
  }

  /**
   * Notify the language server that the file in this editor is about to be closed.
   */
  open fun notifyClose() {
    if (isReleased) {
      return
    }
    file ?: run {
      log.info("Cannot notify language server. File is null.")
      return
    }

    dispatchDocumentCloseEvent()

    _actionsMenu?.unsubscribeEvents()
    selectionChangeRunner?.also {
      selectionChangeHandler.removeCallbacks(it)
    }

    selectionChangeRunner = null

    ensureWindowsDismissed()
  }

  /**
   * Called when this editor is selected and visible to the user.
   */
  open fun onEditorSelected() {
    if (isReleased) {
      return
    }

    file ?: return
    dispatchDocumentSelectedEvent()
  }

  /**
   * Dispatches the [DocumentSaveEvent] for this editor.
   */
  open fun dispatchDocumentSaveEvent() {
    markUnmodified()
    if (isReleased) {
      return
    }
    if (file == null) {
      return
    }
    eventDispatcher.dispatch(DocumentSaveEvent(file!!.toPath()))
  }

  /**
   * Called when the color scheme has been invalidated. This usually happens when the user reloads
   * the color schemes.
   */
  @Suppress("unused")
  @Subscribe(threadMode = ThreadMode.MAIN_ORDERED)
  open fun onColorSchemeInvalidated(event: ColorSchemeInvalidatedEvent?) {
    val file = file ?: return
    setupLanguage(file)
  }

  /**
   * Setup the editor language for the given [file].
   *
   * This applies a proper [Language] and the color scheme to the editor.
   */
  open fun setupLanguage(file: File?) {
    if (isReleased) {
      return
    }
    if (file == null) {
      return
    }

    createLanguage(file) { language ->
      val extension = file.extension
      if (language is TreeSitterLanguage) {
        IDEColorSchemeProvider.readSchemeAsync(context = context, coroutineScope = editorScope,
          type = extension) { scheme ->
          applyTreeSitterLang(language, extension, scheme)
        }
      } else {
        setEditorLanguage(language)
      }
    }
  }

  /**
   * Applies the given [TreeSitterLanguage] and the [color scheme][scheme] for the given [file type][type].
   */
  open fun applyTreeSitterLang(language: TreeSitterLanguage, type: String,
    scheme: SchemeAndroidIDE?) {
    applyTreeSitterLangInternal(language, type, scheme)
  }

  private fun applyTreeSitterLangInternal(language: TreeSitterLanguage, type: String,
    scheme: SchemeAndroidIDE?) {
    if (isReleased) {
      return
    }
    var finalScheme = if (scheme != null) {
      scheme
    } else {
      log.error("Failed to read current color scheme")
      SchemeAndroidIDE.newInstance(context)
    }

    if (finalScheme is IDEColorScheme) {

      language.setupWith(finalScheme)

      if (finalScheme.getLanguageScheme(type) == null) {
        log.warn("Color scheme does not support file type '{}'", type)
        finalScheme = SchemeAndroidIDE.newInstance(context)
      }
    }

    if (finalScheme is DynamicColorScheme) {
      finalScheme.apply(context)
    }

    colorScheme = finalScheme!!
    setEditorLanguage(language)
  }

  private inline fun createLanguage(file: File, crossinline callback: (Language?) -> Unit) {

    // 1 -> If the given File object does not represent a file, return emtpy language
    if (!file.isFile) {
      return callback(EmptyLanguage())
    }

    // 2 -> In case a TreeSitterLanguage has been registered for this file type,
    //      Initialize the TreeSitterLanguage asynchronously and then invoke the callback
    if (TreeSitterLanguageProvider.hasTsLanguage(file)) {

      // lazily create TS languages as they need to read files from assets
      setupTsLanguageJob = editorScope.launch {
        callback(TreeSitterLanguageProvider.forFile(file, context))
      }.also { job ->
        job.invokeOnCompletion { err ->
          if (err != null) {
            log.error("Failed to setup tree sitter language for file: {}", file, err)
          }

          setupTsLanguageJob = null
        }
      }

      return
    }

    // 3 -> Check if we have ANTLR4 lexer-based languages for this file,
    //      return the language if we do, otherwise return an empty language
    val lang = when (FileUtils.getFileExtension(file)) {
      "gradle" -> GroovyLanguage()
      "c", "h", "cc", "cpp", "cxx" -> CppLanguage()
      else -> EmptyLanguage()
    }

    callback(lang)
  }

  override fun setEditorLanguage(lang: Language?) {
    super.setEditorLanguage(lang)
    if (isReleased) {
      return
    }
    dispatchEvent(LanguageUpdateEvent(lang, this))
  }

  /**
   * Initialize the editor.
   */
  protected open fun initEditor() {

    lineNumberMarginLeft = SizeUtils.dp2px(2f).toFloat()

    _actionsMenu = EditorActionsMenu(this).also {
      it.init()
    }

    markUnmodified()

    searcher = IDEEditorSearcher(this)
    colorScheme = SchemeAndroidIDE.newInstance(context)
    inputType = createInputTypeFlags()

    val window = EditorCompletionWindow(this)
    window.setAdapter(CompletionListAdapter())
    replaceComponent(EditorAutoCompletion::class.java, window)

    getComponent(EditorTextActionWindow::class.java).isEnabled = false

    subscribeEvent(ContentChangeEvent::class.java) { event, _ ->
      if (isReleased) {
        return@subscribeEvent
      }

      markModified()
      file ?: return@subscribeEvent

      editorScope.launch {
        dispatchDocumentChangeEvent(event)
        checkForSignatureHelp(event)
      }
    }

    subscribeEvent(SelectionChangeEvent::class.java) { _, _ ->
      if (isReleased) {
        return@subscribeEvent
      }

      if (_diagnosticWindow?.isShowing == true) {
        _diagnosticWindow?.dismiss()
      }

      selectionChangeRunner?.also {
        selectionChangeHandler.removeCallbacks(it)
        selectionChangeHandler.postDelayed(it, SELECTION_CHANGE_DELAY)
      }
    }

    EventBus.getDefault().register(this)
  }

  private inline fun launchCancellableAsyncWithProgress(@StringRes message: Int,
    crossinline action: suspend CoroutineScope.(flashbar: Flashbar, cancelChecker: ICancelChecker) -> Unit): Job? {
    if (isReleased) {
      return null
    }

    return editorScope.launchAsyncWithProgress(configureFlashbar = { builder, cancelChecker ->
      configureFlashbar(builder, message, cancelChecker)
    }, action = action)
  }

  protected open suspend fun onFindDefinitionResult(
    result: DefinitionResult?,
  ) = withContext(Dispatchers.Main) {

    if (isReleased) {
      return@withContext
    }

    val languageClient = languageClient ?: run {
      log.error("No language client found to handle the definitions result")
      return@withContext
    }

    if (result == null) {
      log.error("Invalid definitions result from language server (null)")
      flashError(string.msg_no_definition)
      return@withContext
    }

    val locations = result.locations
    if (locations.isEmpty()) {
      log.error("No definitions found")
      flashError(string.msg_no_definition)
      return@withContext
    }

    if (locations.size != 1) {
      languageClient.showLocations(locations)
      return@withContext
    }

    val (file1, range) = locations[0]
    if (DocumentUtils.isSameFile(file1, file!!.toPath())) {
      setSelection(range)
      return@withContext
    }

    languageClient.showDocument(ShowDocumentParams(file1, range))
  }

  protected open suspend fun onFindReferencesResult(result: ReferenceResult?) =
    withContext(Dispatchers.Main) {

      if (isReleased) {
        return@withContext
      }

      val languageClient = languageClient ?: run {
        log.error("No language client found to handle the references result")
        return@withContext
      }

      if (result == null) {
        log.error("Invalid references result from language server (null)")
        flashError(string.msg_no_references)
        return@withContext
      }

      val locations = result.locations
      if (locations.isEmpty()) {
        log.error("No references found")
        flashError(string.msg_no_references)
        return@withContext
      }

      if (result.locations.size == 1) {
        val (file, range) = result.locations[0]

        if (DocumentUtils.isSameFile(file, getFile()!!.toPath())) {
          setSelection(range)
          return@withContext
        }
      }

      languageClient.showLocations(result.locations)
    }

  protected open fun dispatchDocumentOpenEvent() {
    if (isReleased) {
      return
    }

    val file = this.file ?: return

    this.fileVersion = 0

    val openEvent = DocumentOpenEvent(file.toPath(), text.toString(), fileVersion)

    eventDispatcher.dispatch(openEvent)
  }

  protected open fun dispatchDocumentChangeEvent(event: ContentChangeEvent) {
    if (isReleased) {
      return
    }

    val file = file?.toPath() ?: return
    var type = ChangeType.INSERT
    if (event.action == ContentChangeEvent.ACTION_DELETE) {
      type = ChangeType.DELETE
    } else if (event.action == ContentChangeEvent.ACTION_SET_NEW_TEXT) {
      type = ChangeType.NEW_TEXT
    }
    var changeDelta = if (type == ChangeType.NEW_TEXT) 0 else event.changedText.length
    if (type == ChangeType.DELETE) {
      changeDelta = -changeDelta
    }
    val start = event.changeStart
    val end = event.changeEnd
    val changeRange = Range(Position(start.line, start.column, start.index),
      Position(end.line, end.column, end.index))
    val changedText = event.changedText.toString()
    val changeEvent = DocumentChangeEvent(file, changedText, text.toString(), ++fileVersion, type,
      changeDelta, changeRange)

    eventDispatcher.dispatch(changeEvent)
  }

  protected open fun dispatchDocumentSelectedEvent() {
    if (isReleased) {
      return
    }
    val file = file ?: return
    eventDispatcher.dispatch(DocumentSelectedEvent(file.toPath()))
  }

  protected open fun dispatchDocumentCloseEvent() {
    if (isReleased) {
      return
    }
    val file = file ?: return

    eventDispatcher.dispatch(DocumentCloseEvent(file.toPath(), cursorLSPRange))
  }

  /**
   * Checks if the content change event should trigger signature help. Signature help trigger
   * characters are :
   *
   *
   *  * `'('` (parentheses)
   *  * `','` (comma)
   *
   *
   * @param event The content change event.
   */
  private fun checkForSignatureHelp(event: ContentChangeEvent) {
    if (isReleased) {
      return
    }
    if (languageServer == null) {
      return
    }
    val changeLength = event.changedText.length
    if (event.action != ContentChangeEvent.ACTION_INSERT || changeLength < 1 || changeLength > 2) {
      // change length will be 1 if ',' is inserted
      // changeLength will be 2 as '(' and ')' are inserted at the same time
      return
    }

    val ch = event.changedText[0]
    if (ch == '(' || ch == ',') {
      signatureHelp()
    }
  }

  private fun configureFlashbar(builder: Flashbar.Builder, @StringRes message: Int,
    cancelChecker: ICancelChecker) {
    builder.message(message).primaryActionText(android.R.string.cancel)
      .primaryActionTapListener { bar: Flashbar ->
        cancelChecker.cancel()
        bar.dismiss()
      }
  }

  private inline fun <T> safeGet(name: String, action: () -> T): T? {
    return try {
      action()
    } catch (err: Throwable) {
      logError(err, name)
      null
    }
  }

  private fun Job.logError(action: String): Job = apply {
    invokeOnCompletion { err -> logError(err, action) }
  }

  private fun logError(err: Throwable?, action: String) {
    err ?: return
    if (CancelChecker.isCancelled(err)) {
      log.warn("{} has been cancelled", action)
    } else {
      log.error("{} failed", action)
    }
  }

  override fun setSelectionAround(line: Int, column: Int) {
    editorFeatures.setSelectionAround(line, column)
  }
}


================================================
File: java/com/itsaky/androidide/editor/ui/ReplaceAction.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.view.LayoutInflater
import com.itsaky.androidide.editor.databinding.LayoutEditorFindReplaceBinding
import com.itsaky.androidide.resources.R
import com.itsaky.androidide.utils.DialogUtils
import org.slf4j.LoggerFactory

/**
 * Handles the replace action while searching in file.
 *
 * @author Akash Yadav
 */
object ReplaceAction {

  private val log = LoggerFactory.getLogger(ReplaceAction::class.java)

  @JvmStatic
  fun doReplace(editor: IDEEditor) {
    val context = editor.context
    val binding = LayoutEditorFindReplaceBinding.inflate(LayoutInflater.from(context))
    val builder = DialogUtils.newMaterialDialogBuilder(context)
    builder.setTitle(R.string.replace)
    builder.setView(binding.root)
    builder.setNegativeButton(android.R.string.cancel, null)
    builder.setPositiveButton(R.string.replace) { dialog, _ ->
      dialog.dismiss()
      val input = binding.replacementInput.editText
      if (input == null) {
        log.error("Unable to perform replace action. Input field is null")
        return@setPositiveButton
      }

      editor.searcher.replaceThis(input.text.toString())
    }
    builder.setNeutralButton(R.string.replaceAll) { dialog, _ ->
      dialog.dismiss()
      val input = binding.replacementInput.editText
      if (input == null) {
        log.error("Unable to perform replace action. Input field is null")
        return@setNeutralButton
      }

      editor.searcher.replaceAll(input.text.toString())
    }
    builder.show()
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/SignatureHelpWindow.java
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui;

import static com.itsaky.androidide.editor.R.attr;

import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.itsaky.androidide.lsp.models.SignatureHelp;
import com.itsaky.androidide.lsp.models.SignatureInformation;
import com.itsaky.androidide.utils.ContextUtilsKt;
import io.github.rosemoe.sora.event.SelectionChangeEvent;
import io.github.rosemoe.sora.widget.base.EditorPopupWindow;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * An {@link EditorPopupWindow} used to show signature help.
 *
 * @author Akash Yadav
 */
public class SignatureHelpWindow extends BaseEditorWindow {

  private static final Logger LOG = LoggerFactory.getLogger(SignatureHelpWindow.class);

  /**
   * Create a signature help popup window for editor
   *
   * @param editor The editor.
   */
  public SignatureHelpWindow(@NonNull IDEEditor editor) {
    super(editor);

    editor.subscribeEvent(
        SelectionChangeEvent.class,
        (event, unsubscribe) -> {
          if (isShowing()) {
            dismiss();
          }
        });
  }

  public void setupAndDisplay(SignatureHelp signature) {
    if (signature == null || signature.getSignatures().isEmpty()) {
      if (isShowing()) {
        dismiss();
      }

      return;
    }

    final var signatureText = createSignatureText(signature);

    if (signatureText == null) {
      return;
    }

    this.text.setText(signatureText);
    displayWindow();
  }

  @Nullable
  private CharSequence createSignatureText(@NonNull SignatureHelp signature) {
    final var signatures = signature.getSignatures();
    final var activeSignature = signature.getActiveSignature();
    final var activeParameter = signature.getActiveParameter();
    final SpannableStringBuilder sb = new SpannableStringBuilder();

    if (activeSignature < 0 || activeParameter < 0) {
      LOG.debug("activeSignature: {}, activeParameter: {}", activeSignature, activeParameter);
      return null;
    }

    var count = signatures.size();
    if (activeSignature >= count) {
      LOG.debug("Active signature is invalid. Size is {}", count);
      return null;
    }

    // remove all with non-applicable signatures
    signatures.removeIf(
        info -> {
          final var remove = activeParameter >= info.getParameters().size();
          if (remove) {
            LOG.debug("Removing {} params={} active={}", info, info.getParameters().size(),
                activeParameter);
          }
          return remove;
        });

    count = signatures.size();
    for (var i = 0; i < count; i++) {
      final var info = signatures.get(i);
      formatSignature(info, activeParameter, sb);
      if (i != count - 1) {
        sb.append('\n');
      }
    }

    return sb;
  }

  /**
   * Formats (highlights) a method signature
   *
   * @param signature  Signature information
   * @param paramIndex Currently active parameter index
   * @param result     The builder to append spanned text to.
   */
  private void formatSignature(
      @NonNull SignatureInformation signature,
      int paramIndex,
      SpannableStringBuilder result) {

    String name = signature.getLabel();
    name = name.substring(0, name.indexOf("("));

    final var foreground = ContextUtilsKt.resolveAttr(getEditor().getContext(),
        attr.colorOnSecondaryContainer);
    final var paramSelected = 0xffff6060;
    final var operators = 0xff4fc3f7;

    result.append(
        name, new ForegroundColorSpan(foreground), SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE);
    result.append(
        "(", new ForegroundColorSpan(operators), SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE);

    var params = signature.getParameters();
    for (int i = 0; i < params.size(); i++) {
      int color = i == paramIndex ? paramSelected : foreground;
      final var info = params.get(i);
      if (i == params.size() - 1) {
        result.append(
            info.getLabel(),
            new ForegroundColorSpan(color),
            SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE);
      } else {
        result.append(
            info.getLabel(),
            new ForegroundColorSpan(color),
            SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE);
        result.append(
            ",",
            new ForegroundColorSpan(operators),
            SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE);
        result.append(" ");
      }
    }
    result.append(
        ")", new ForegroundColorSpan(0xff4fc3f7), SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
}



================================================
File: java/com/itsaky/androidide/editor/ui/TracingEditorRenderer.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.ui

import android.graphics.Canvas
import android.graphics.Rect
import android.graphics.RectF
import android.graphics.RenderNode
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.collection.MutableIntList
import com.itsaky.androidide.editor.BuildConfig
import io.github.rosemoe.sora.lang.styling.CodeBlock
import io.github.rosemoe.sora.lang.styling.Spans
import io.github.rosemoe.sora.text.ContentLine
import io.github.rosemoe.sora.util.LongArrayList
import io.github.rosemoe.sora.util.MutableInt
import io.github.rosemoe.sora.widget.CodeEditor
import io.github.rosemoe.sora.widget.EditorRenderer

/**
 * An implementation of [EditorRenderer] which traces the whole drawing process for [IDEEditor].
 *
 * @author Akash Yadav
 */
class TracingEditorRenderer(
  private val enabled: Boolean = BuildConfig.DEBUG,
  editor: CodeEditor
) : EditorRenderer(editor) {

  override fun draw(canvas: Canvas) = trace("draw") {
    super.draw(canvas)
  }

  @RequiresApi(Build.VERSION_CODES.Q)
  override fun updateLineDisplayList(renderNode: RenderNode?, line: Int, spans: Spans.Reader?) =
    trace("updateLineDisplayList") {
      super.updateLineDisplayList(renderNode, line, spans)
    }

  override fun drawSingleTextLine(canvas: Canvas?, line: Int, offsetX: Float, offsetY: Float,
    spans: Spans.Reader?, visibleOnly: Boolean) = trace("drawSingleTextLine") {
    super.drawSingleTextLine(canvas, line, offsetX, offsetY, spans, visibleOnly)
  }

  override fun drawView(canvas: Canvas?) = trace("drawView") {
    super.drawView(canvas)
  }

  override fun drawUserGutterBackground(canvas: Canvas?, right: Int) =
    trace("drawUserGutterBackground") {
      super.drawUserGutterBackground(canvas, right)
    }

  override fun drawStuckLineNumbers(canvas: Canvas?, candidates: MutableList<CodeBlock>?,
    offset: Float, lineNumberWidth: Float, lineNumberColor: Int) = trace("drawStuckLineNumbers") {
    super.drawStuckLineNumbers(canvas, candidates, offset, lineNumberWidth, lineNumberColor)
  }

  override fun drawStuckLines(canvas: Canvas?, candidates: MutableList<CodeBlock>?, offset: Float) =
    trace("drawStuckLines") {
      super.drawStuckLines(canvas, candidates, offset)
    }

  override fun drawHardwrapMarker(canvas: Canvas?, offset: Float) = trace("drawHardwrapMarker") {
    super.drawHardwrapMarker(canvas, offset)
  }

  override fun drawSideIcons(canvas: Canvas?, offset: Float) = trace("drawSideIcons") {
    super.drawSideIcons(canvas, offset)
  }

  override fun drawFormatTip(canvas: Canvas?) = trace("drawFormatTip") {
    super.drawFormatTip(canvas)
  }

  override fun drawColor(canvas: Canvas?, color: Int, rect: RectF?) = trace("drawColor") {
    super.drawColor(canvas, color, rect)
  }

  override fun drawColor(canvas: Canvas?, color: Int, rect: Rect?) = trace("drawColor") {
    super.drawColor(canvas, color, rect)
  }

  override fun drawColorRound(canvas: Canvas?, color: Int, rect: RectF?) = trace("drawColorRound") {
    super.drawColorRound(canvas, color, rect)
  }

  override fun drawRowBackground(canvas: Canvas?, color: Int, row: Int) =
    trace("drawRowBackground") {
      super.drawRowBackground(canvas, color, row)
    }

  override fun drawRowBackground(canvas: Canvas?, color: Int, row: Int, right: Int) =
    trace("drawRowBackground") {
      super.drawRowBackground(canvas, color, row, right)
    }

  override fun drawLineNumber(canvas: Canvas?, line: Int, row: Int, offsetX: Float, width: Float,
    color: Int) = trace("drawLineNumber") {
    super.drawLineNumber(canvas, line, row, offsetX, width, color)
  }

  override fun drawLineNumberBackground(canvas: Canvas?, offsetX: Float, width: Float, color: Int) =
    trace("drawLineNumberBackground") {
      super.drawLineNumberBackground(canvas, offsetX, width, color)
    }

  override fun drawDivider(canvas: Canvas?, offsetX: Float, color: Int) = trace("drawDivider") {
    super.drawDivider(canvas, offsetX, color)
  }

  override fun drawRows(canvas: Canvas?, offset: Float, postDrawLineNumbers: LongArrayList?,
    postDrawCursor: MutableList<DrawCursorTask>?, postDrawCurrentLines: MutableIntList?,
    requiredFirstLn: MutableInt?) = trace("drawRows") {
    super.drawRows(canvas, offset, postDrawLineNumbers, postDrawCursor, postDrawCurrentLines,
      requiredFirstLn)
  }

  override fun drawDiagnosticIndicators(canvas: Canvas?, offset: Float) =
    trace("drawDiagnosticIndicators") {
      super.drawDiagnosticIndicators(canvas, offset)
    }

  override fun drawWhitespaces(canvas: Canvas?, offset: Float, line: Int, row: Int, rowStart: Int,
    rowEnd: Int, min: Int, max: Int) = trace("drawWhitespaces") {
    super.drawWhitespaces(canvas, offset, line, row, rowStart, rowEnd, min, max)
  }

  override fun drawMiniGraph(canvas: Canvas?, offset: Float, row: Int, graph: String?) =
    trace("drawMiniGraph") {
      super.drawMiniGraph(canvas, offset, row, graph)
    }

  override fun getRowTopForBackground(row: Int) = trace("getRowTopForBackground") {
    return@trace super.getRowTopForBackground(row)
  }

  override fun getRowBottomForBackground(row: Int) = trace("getRowBottomForBackground") {
    return@trace super.getRowBottomForBackground(row)
  }

  override fun drawRowRegionBackground(canvas: Canvas?, row: Int, line: Int, highlightStart: Int,
    highlightEnd: Int, rowStart: Int, rowEnd: Int, color: Int) = trace("drawRowRegionBackground") {
    super.drawRowRegionBackground(canvas, row, line, highlightStart, highlightEnd, rowStart, rowEnd,
      color)
  }

  override fun drawRowBackgroundRect(canvas: Canvas?, rect: RectF?) =
    trace("drawRowBackgroundRect") {
      super.drawRowBackgroundRect(canvas, rect)
    }

  override fun drawRegionText(canvas: Canvas?, offsetX: Float, baseline: Float, line: Int,
    startIndex: Int, endIndex: Int, contextStart: Int, contextEnd: Int, isRtl: Boolean,
    columnCount: Int, color: Int) = trace("drawRegionText") {
    super.drawRegionText(canvas, offsetX, baseline, line, startIndex, endIndex, contextStart,
      contextEnd, isRtl, columnCount, color)
  }

  override fun drawRegionTextDirectional(canvas: Canvas?, offsetX: Float, baseline: Float,
    line: Int, startIndex: Int, endIndex: Int, contextStart: Int, contextEnd: Int, columnCount: Int,
    color: Int) = trace("drawRegionTextDirectional") {
    super.drawRegionTextDirectional(canvas, offsetX, baseline, line, startIndex, endIndex,
      contextStart, contextEnd, columnCount, color)
  }

  override fun drawFunctionCharacter(canvas: Canvas?, offsetX: Float, offsetY: Float, width: Float,
    ch: Char) = trace("drawFunctionCharacter") {
    super.drawFunctionCharacter(canvas, offsetX, offsetY, width, ch)
  }

  override fun drawText(canvas: Canvas?, line: ContentLine?, index: Int, count: Int,
    contextStart: Int, contextCount: Int, isRtl: Boolean, offX: Float, offY: Float,
    lineNumber: Int) = trace("drawText") {
    super.drawText(canvas, line, index, count, contextStart, contextCount, isRtl, offX, offY,
      lineNumber)
  }

  override fun drawTextRunDirect(canvas: Canvas?, src: CharArray?, index: Int, count: Int,
    contextStart: Int, contextCount: Int, offX: Float, offY: Float, isRtl: Boolean) =
    trace("drawTextRunDirect") {
      super.drawTextRunDirect(canvas, src, index, count, contextStart, contextCount, offX, offY,
        isRtl)
    }

  override fun drawEdgeEffect(canvas: Canvas?) = trace("drawEdgeEffect") {
    super.drawEdgeEffect(canvas)
  }

  override fun drawBlockLines(canvas: Canvas?, offsetX: Float) = trace("drawBlockLines") {
    super.drawBlockLines(canvas, offsetX)
  }

  override fun drawSideBlockLine(canvas: Canvas?) = trace("drawSideBlockLine") {
    super.drawSideBlockLine(canvas)
  }

  override fun drawScrollBars(canvas: Canvas?) = trace("drawScrollBars") {
    super.drawScrollBars(canvas)
  }

  override fun drawScrollBarTrackVertical(canvas: Canvas?) = trace("drawScrollBarTrackVertical") {
    super.drawScrollBarTrackVertical(canvas)
  }

  override fun drawScrollBarVertical(canvas: Canvas?) = trace("drawScrollBarVertical") {
    super.drawScrollBarVertical(canvas)
  }

  override fun drawLineInfoPanel(canvas: Canvas?, topY: Float, length: Float) =
    trace("drawLineInfoPanel") {
      super.drawLineInfoPanel(canvas, topY, length)
    }

  override fun drawScrollBarTrackHorizontal(canvas: Canvas?) =
    trace("drawScrollBarTrackHorizontal") {
      super.drawScrollBarTrackHorizontal(canvas)
    }

  override fun patchSnippetRegions(canvas: Canvas?, textOffset: Float) =
    trace("patchSnippetRegions") {
      super.patchSnippetRegions(canvas, textOffset)
    }

  override fun patchHighlightedDelimiters(canvas: Canvas?, textOffset: Float) =
    trace("patchHighlightedDelimiters") {
      super.patchHighlightedDelimiters(canvas, textOffset)
    }

  override fun patchTextRegionWithColor(canvas: Canvas?, textOffset: Float, start: Int, end: Int,
    color: Int, backgroundColor: Int, underlineColor: Int) = trace("patchTextRegionWithColor") {
    super.patchTextRegionWithColor(canvas, textOffset, start, end, color, backgroundColor,
      underlineColor)
  }

  override fun patchTextRegions(canvas: Canvas?, textOffset: Float,
    positions: MutableList<TextDisplayPosition>?, patch: PatchDraw) = trace("patchTextRegions") {
    super.patchTextRegions(canvas, textOffset, positions, patch)
  }

  override fun drawSelectionOnAnimation(canvas: Canvas?) = trace("drawSelectionOnAnimation") {
    super.drawSelectionOnAnimation(canvas)
  }

  override fun drawScrollBarHorizontal(canvas: Canvas?) = trace("drawScrollBarHorizontal") {
    super.drawScrollBarHorizontal(canvas)
  }

  override fun buildMeasureCacheForLines(startLine: Int, endLine: Int, timestamp: Long,
    useCachedContent: Boolean) = trace("buildMeasureCacheForLines") {
    super.buildMeasureCacheForLines(startLine, endLine, timestamp, useCachedContent)
  }

  override fun buildMeasureCacheForLines(startLine: Int, endLine: Int) =
    trace("buildMeasureCacheForLines") {
      super.buildMeasureCacheForLines(startLine, endLine)
    }

  override fun measureText(text: ContentLine?, line: Int, index: Int, count: Int) =
    trace("measureText") {
      return@trace super.measureText(text, line, index, count)
    }

  private inline fun <T : Any?> trace(section: String, crossinline action: () -> T): T =
    if (enabled) {
      androidx.tracing.trace(section, action)
    } else {
      action()
    }
}


================================================
File: java/com/itsaky/androidide/editor/utils/ContentReadWrite.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.utils

import io.github.rosemoe.sora.text.CharArrayWrapper
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.text.ContentLockAccessor
import java.io.File
import java.io.IOException
import kotlin.math.floor

/**
 * Utility methods for reading and writing [Content] objects. This class is similar to
 * [ContentIO][io.github.rosemoe.sora.text.ContentIO] but provides ability to track the progress.
 *
 * @author Akash Yadav
 */
object ContentReadWrite {

  /**
   * Write this [Content] to the given [File].
   *
   * @param progressConsumer A function which is invoked to notify about the write progress.
   */
  @JvmStatic
  fun Content.writeTo(file: File, progressConsumer: ((Int) -> Unit)? = null) {
    val consumer = discreteProgressConsumer(progressConsumer = progressConsumer)

    file.writer().buffered(DEFAULT_BUFFER_SIZE * 2).use { writer ->
      val lastLine = lineCount - 1
      val length = length

      ContentLockAccessor.lock(this, false)
      var totalWrote = 0.0
      try {
        for (lineIdx in 0..lastLine) {
          val line = getLine(lineIdx)
          writer.write(line.backingCharArray, 0, line.length)

          val separatorChars = line.lineSeparator.chars
          writer.write(separatorChars)

          totalWrote += line.length + separatorChars.size
          val saveProgress = (totalWrote / length) * 100
          consumer(floor(saveProgress).toInt())
        }
      } catch (err: IOException) {
        throw RuntimeException("Failed to write editor's content to file: ${file.absolutePath}",
          err)
      } finally {
        ContentLockAccessor.unlock(this, false)
        consumer(100)
      }

      writer.flush()
    }
  }

  /**
   * Reads this file's content to a new [Content] object.
   *
   * @param progressConsumer A function to consume the read progress.
   */
  @JvmStatic
  fun File.readContent(progressConsumer: ((Int) -> Unit)? = null): Content {
    val consumer = discreteProgressConsumer(progressConsumer = progressConsumer)
    return Content().apply {
      isUndoEnabled = false
      inputStream().use { input ->
        val total = input.available().let { if (it == 0) 1 else it } // avoid divide by 0
        input.reader().use { reader ->
          val buffer = CharArray(DEFAULT_BUFFER_SIZE * 2)
          val wrapper = CharArrayWrapper(buffer, 0)
          var totalRead = 0.0
          var count: Int
          while (true) {
            count = reader.read(buffer)
            if (count == -1) {
              break
            }
            if (count == 0) {
              continue
            }

            totalRead += count

            val progress = floor((totalRead / total) * 100).toInt()

            if (buffer[count - 1] == '\r') {
              val peek = reader.read()
              if (peek == '\n'.code) {
                wrapper.setDataCount(count - 1)
                var line = lineCount - 1
                insert(line, getColumnCount(line), wrapper)

                line = lineCount - 1
                insert(line, getColumnCount(line), "\r\n")
                consumer(progress)
                continue

              } else if (peek != -1) {
                wrapper.setDataCount(count)
                var line = lineCount - 1
                insert(line, getColumnCount(line), wrapper)

                line = lineCount - 1
                insert(line, getColumnCount(line), peek.toChar().toString())
                consumer(progress)
                continue
              }
            }
            wrapper.setDataCount(count)

            val line = lineCount - 1
            insert(line, getColumnCount(line), wrapper)

            consumer(progress)
          }
        }
        isUndoEnabled = true
      }
    }
  }

  @JvmStatic
  private fun discreteProgressConsumer(
    stepSize: Int = 5,
    progressConsumer: ((Int) -> Unit)?
  ) : (Int) -> Unit {
    var lastProgress = -1
    val consumer = fun (progress: Int) {
      if (lastProgress == -1 || progress >= 100 || progress - lastProgress >= stepSize) {
        progressConsumer?.invoke(progress)
        lastProgress = progress
      }
    }

    return consumer
  }
}


================================================
File: java/com/itsaky/androidide/editor/utils/contentExt.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.itsaky.androidide.editor.utils

import androidx.core.text.trimmedLength
import com.itsaky.androidide.treesitter.TSNode
import com.itsaky.androidide.treesitter.TSTree
import com.itsaky.androidide.treesitter.getNodeAt
import io.github.rosemoe.sora.text.Content
import io.github.rosemoe.sora.text.TextUtils
import io.github.rosemoe.sora.util.IntPair

/**
 * Returns true if the given line is blank.
 */
fun Content.isBlankLine(line: Int) : Boolean {
  return getLine(line).trim { it.isWhitespace() || it == '\r' }.isEmpty()
}

/**
 * Returns true if the given line is not blank.
 */
fun Content.isNonBlankLine(line: Int) : Boolean {
  return !isBlankLine(line)
}

/**
 * Returns the index of the previous non-blank line.
 *
 * @return The index of the previous non-blank line or -1 if not found.
 */
fun Content.previousNonBlankLine(line: Int) : Int {
  for (i in line - 1 downTo 0) {
    if (isNonBlankLine(i)) {
      return i
    }
  }

  return -1
}

/**
 * Returns the index of the next non-blank line.
 *
 * @return The index of the next non-blank line or -1 if not found.
 */
fun Content.nextNonBlankLine(line: Int) : Int {
  for (i in line + 1 until length) {
    if (isNonBlankLine(i)) {
      return i
    }
  }

  return -1
}

/**
 * Returns the first [TSNode] at the given line number. The leading indentation is ignored.
 */
fun Content.getFirstNodeAtLine(tree: TSTree, line: Int, col: Int = Int.MIN_VALUE) : TSNode? {
  return getFirstNodeAtLine(tree.rootNode, line, col)
}

/**
 * Returns the last [TSNode] at the given line number.
 */
fun Content.getLastNodeAtLine(tree: TSTree, line: Int, col: Int = Int.MIN_VALUE) : TSNode? {
  return getLastNodeAtLine(tree.rootNode, line, col)
}

/**
 * Returns the first [TSNode] at the given line number. The leading indentation is ignored.
 */
fun Content.getFirstNodeAtLine(node: TSNode, line: Int, col: Int = Int.MIN_VALUE) : TSNode? {
  if (line < 0 || line >= lineCount) {
    return null
  }

  var column = col
  if (column == Int.MIN_VALUE) {
    val contentLine = getLine(line);
    val (spaces, tabs) = TextUtils.countLeadingSpacesAndTabs(contentLine).let {
      IntPair.getFirst(it) to IntPair.getSecond(it)
    }

    column = (spaces + tabs) shl 1
  }

  // we need the byte offset in the line, so we need to multiply the char offset by 2 (shl 1)
  // also, we need not to expand the tabs to spaces as that would result in incorrect offset
  return node.getNodeAt(line, column)
}

/**
 * Returns the last [TSNode] at the given line number. This function also takes the leading
 * indentation into consideration.
 */
fun Content.getLastNodeAtLine(node: TSNode, line: Int, col: Int = Int.MIN_VALUE) : TSNode? {
  if (line < 0 || line >= lineCount) {
    return null
  }

  val contentLine = getLine(line)

  var column = col
  if (column == Int.MIN_VALUE) {
    column = (contentLine.length - 1) shl 1
  }

  // we need the byte offset in the line, so we need to multiply the char offset by 2 (shl 1)
  return node.getNodeAt(line, column)
}


================================================
File: java/io/github/rosemoe/sora/text/ContentLockAccessor.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package io.github.rosemoe.sora.text

/**
 * Provides access to [Content.lock] and [Content.unlock].
 *
 * @author Akash Yadav
 */
object ContentLockAccessor {

  @JvmStatic
  fun lock(content: Content, write: Boolean) {
    content.lock(write)
  }

  @JvmStatic
  fun unlock(content: Content, write: Boolean) {
    content.unlock(write)
  }
}


================================================
File: java/io/github/rosemoe/sora/widget/IDEEditorSearcher.kt
================================================
/*
 *  This file is part of AndroidIDE.
 *
 *  AndroidIDE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidIDE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
 */

package io.github.rosemoe.sora.widget

import com.itsaky.androidide.editor.ui.IDEEditor

/**
 * Search text in editor. As the constructor of [EditorSearcher] is package private, we cannot
 * extend it in another package. So we put this class in the same package.
 *
 * @author Akash Yadav
 */
open class IDEEditorSearcher(editor: IDEEditor) : EditorSearcher(editor) {

  var isSearching = false
    private set

  protected fun getEditor(): CodeEditor {
    try {
      val field = EditorSearcher::class.java.getDeclaredField("editor")
      field.isAccessible = true
      return field.get(this) as CodeEditor
    } catch (error: Throwable) {
      throw RuntimeException("Unable get instance of editor", error)
    }
  }

  fun updateSearchOptions(searchOptions: SearchOptions) {
    this.searchOptions = searchOptions
  }

  override fun replaceAll(replacement: String, whenFinished: Runnable?) {
    markSearching()
    super.replaceAll(replacement, whenFinished)
  }

  override fun replaceThis(replacement: String) {
    markSearching()
    super.replaceThis(replacement)
  }

  override fun gotoNext(): Boolean {
    markSearching()
    return super.gotoNext()
  }

  override fun gotoPrevious(): Boolean {
    markSearching()
    return super.gotoPrevious()
  }

  override fun stopSearch() {
    isSearching = false
    super.stopSearch()
  }

  fun onClose() {
    isSearching = false
  }

  private fun markSearching() {
    isSearching = true
  }
}



================================================
File: res/layout/layout_code_editor.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical">

  <com.google.android.material.progressindicator.LinearProgressIndicator
    android:id="@+id/rw_progress"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:indeterminate="false"
    android:max="100"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    tools:progress="50" />

  <com.itsaky.androidide.editor.ui.IDEEditor
    android:id="@+id/editor"
    android:layout_width="0dp"
    android:layout_height="0dp"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toBottomOf="@id/rw_progress" />

</androidx.constraintlayout.widget.ConstraintLayout>



================================================
File: res/layout/layout_completion_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:id="@+id/relativeLayout2"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:gravity="center_vertical"
  android:minHeight="40dp"
  tools:ignore="SmallSp">

  <TextView
    android:id="@+id/completion_type"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="2dp"
    android:layout_marginEnd="4dp"
    android:ellipsize="start"
    android:gravity="center_vertical"
    android:singleLine="true"
    android:textColor="?attr/colorSecondaryVariant"
    android:textSize="11sp"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="Class" />

  <TextView
    android:id="@+id/completion_label"
    android:textStyle="bold"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:layout_marginTop="2dp"
    android:layout_marginStart="4dp"
    android:layout_marginEnd="4dp"
    android:ellipsize="end"
    android:gravity="center_vertical"
    android:singleLine="true"
    android:textAppearance="@style/TextAppearance.Material3.BodyMedium"
    android:textColor="?attr/colorOnPrimaryContainer"
    android:textSize="13sp"
    app:layout_constraintEnd_toStartOf="@id/completion_type"
    app:layout_constraintStart_toEndOf="@id/completion_iconText"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="MainActivity" />

  <TextView
    android:id="@+id/completion_detail"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:layout_marginStart="4dp"
    android:ellipsize="end"
    android:gravity="center_vertical"
    android:singleLine="true"
    android:textAppearance="@style/TextAppearance.Material3.BodyMedium"
    android:textColor="?attr/colorSecondaryVariant"
    android:textSize="11sp"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toEndOf="@+id/completion_iconText"
    app:layout_constraintTop_toBottomOf="@id/completion_label"
    tools:text="com.itsaky.androidide.activities.MainActivity" />

  <TextView
    android:id="@+id/completion_api_info"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:layout_marginBottom="2dp"
    android:layout_marginStart="4dp"
    android:layout_marginEnd="4dp"
    android:ellipsize="end"
    android:gravity="center_vertical"
    android:singleLine="true"
    android:textAppearance="@style/TextAppearance.Material3.BodySmall"
    android:textColor="?attr/colorSecondaryVariant"
    android:textSize="11sp"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toEndOf="@id/completion_iconText"
    app:layout_constraintTop_toBottomOf="@id/completion_detail"
    tools:text="Added in API 1" />

  <TextView
    android:id="@+id/completion_iconText"
    android:layout_width="30dp"
    android:layout_height="0dp"
    android:layout_marginEnd="8dp"
    android:backgroundTint="?attr/colorPrimaryContainer"
    android:gravity="center"
    android:textAppearance="@style/TextAppearance.Material3.TitleLarge"
    android:textColor="?attr/colorOnPrimaryContainer"
    android:textSize="14sp"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="F" />

</androidx.constraintlayout.widget.ConstraintLayout>




================================================
File: res/layout/layout_editor_find_replace.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:paddingTop="8dp"
  android:paddingBottom="8dp">

  <com.google.android.material.textfield.TextInputLayout
    android:id="@+id/replacement_input"
    style="@style/Widget.Material3.TextInputEditText.OutlinedBox.Dense"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:hint="@string/msg_replacement"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    app:startIconDrawable="@drawable/ic_search_replace">

    <com.google.android.material.textfield.TextInputEditText
      android:layout_width="match_parent"
      android:layout_height="match_parent" />

  </com.google.android.material.textfield.TextInputLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


================================================
File: res/layout/layout_find_in_file.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:background="?attr/colorSurface">

  <View
    android:id="@+id/top_border"
    android:layout_width="0dp"
    android:layout_height="0.5dp"
    android:background="?attr/colorOutline"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent" />

  <EditText
    android:id="@+id/search_input"
    android:layout_width="0dp"
    android:layout_height="40dp"
    android:layout_marginStart="8dp"
    android:layout_marginTop="8dp"
    android:layout_marginEnd="8dp"
    android:hint="@string/text_to_search"
    android:imeOptions="actionNext"
    android:importantForAutofill="no"
    android:inputType="text"
    android:maxLines="1"
    app:layout_constraintEnd_toStartOf="@id/more_options"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toBottomOf="@id/top_border"
    tools:text="AndroidIDE" />

  <androidx.appcompat.widget.AppCompatImageButton
    android:id="@+id/more_options"
    android:layout_width="wrap_content"
    android:layout_height="0dp"
    android:layout_marginEnd="8dp"
    android:background="@android:color/transparent"
    android:src="@drawable/ic_more_vert_black_20dp"
    android:tint="?attr/colorPrimary"
    app:layout_constraintBottom_toBottomOf="@id/search_input"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toEndOf="@id/search_input"
    app:layout_constraintTop_toTopOf="@id/search_input" />


  <com.google.android.material.button.MaterialButton
    android:id="@+id/prev"
    style="@style/Widget.Material3.Button.TextButton"
    android:layout_width="0dp"
    android:layout_height="40dp"
    android:text="@string/previous"
    android:textAllCaps="true"
    app:layout_constraintEnd_toStartOf="@+id/next"
    app:layout_constraintHorizontal_weight="0.25"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toBottomOf="@+id/search_input" />


  <com.google.android.material.button.MaterialButton
    android:id="@+id/next"
    style="@style/Widget.Material3.Button.TextButton"
    android:layout_width="0dp"
    android:layout_height="40dp"
    android:text="@string/next"
    android:textAllCaps="true"
    app:layout_constraintEnd_toStartOf="@+id/replace"
    app:layout_constraintHorizontal_bias="0.5"
    app:layout_constraintHorizontal_weight="0.25"
    app:layout_constraintStart_toEndOf="@+id/prev"
    app:layout_constraintTop_toBottomOf="@+id/search_input" />

  <com.google.android.material.button.MaterialButton
    android:id="@+id/replace"
    style="@style/Widget.Material3.Button.TextButton"
    android:layout_width="0dp"
    android:layout_height="40dp"
    android:text="@string/replace"
    android:textAllCaps="true"
    app:layout_constraintEnd_toStartOf="@+id/close"
    app:layout_constraintHorizontal_bias="0.5"
    app:layout_constraintHorizontal_weight="0.25"
    app:layout_constraintStart_toEndOf="@+id/next"
    app:layout_constraintTop_toBottomOf="@+id/search_input" />

  <com.google.android.material.button.MaterialButton
    android:id="@+id/close"
    style="@style/Widget.Material3.Button.TextButton"
    android:layout_width="0dp"
    android:layout_height="40dp"
    android:text="@string/btn_close"
    android:textAllCaps="true"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintHorizontal_bias="0.5"
    app:layout_constraintHorizontal_weight="0.25"
    app:layout_constraintStart_toEndOf="@+id/replace"
    app:layout_constraintTop_toBottomOf="@+id/search_input" />

</androidx.constraintlayout.widget.ConstraintLayout>


================================================
File: res/layout/layout_popup_menu_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->
<com.google.android.material.button.MaterialButton xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  style="@style/Widget.Material3.Button.TextButton.Icon"
  android:layout_width="40dp"
  android:layout_height="40dp"
  android:clickable="true"
  android:drawablePadding="16dp"
  android:drawableTint="?attr/colorPrimary"
  android:focusable="true"
  android:gravity="start|center_vertical"
  android:paddingTop="4dp"
  android:paddingBottom="4dp"
  android:textAllCaps="false"
  app:iconPadding="0dp"
  app:iconTint="?attr/colorPrimary"
  tools:icon="@drawable/ic_code" />


================================================
File: res/values/dimens.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
  ~  This file is part of AndroidIDE.
  ~
  ~  AndroidIDE is free software: you can redistribute it and/or modify
  ~  it under the terms of the GNU General Public License as published by
  ~  the Free Software Foundation, either version 3 of the License, or
  ~  (at your option) any later version.
  ~
  ~  AndroidIDE is distributed in the hope that it will be useful,
  ~  but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~  GNU General Public License for more details.
  ~
  ~  You should have received a copy of the GNU General Public License
  ~   along with AndroidIDE.  If not, see <https://www.gnu.org/licenses/>.
  -->

<resources>
  <dimen name="completion_window_corner_radius">8dp</dimen>
  <dimen name="completion_window_stroke_width">1dp</dimen>
</resources>

