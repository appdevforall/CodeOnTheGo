name: Build and deploy to firebase app distribution

permissions:
  contents: read
  actions: write

on:
  pull_request:
    branches: [ "stage" ]
    types: [ opened, synchronize, reopened, closed ]
    paths-ignore:
      - '**/*.md'
      - 'fastlane/**'
  workflow_dispatch: { }

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  IDE_SIGNING_ALIAS: ${{ secrets.IDE_SIGNING_ALIAS }}
  IDE_SIGNING_AUTH_PASS: ${{ secrets.IDE_SIGNING_AUTH_PASS }}
  IDE_SIGNING_AUTH_USER: ${{ secrets.IDE_SIGNING_AUTH_USER }}
  IDE_SIGNING_KEY_PASS: ${{ secrets.IDE_SIGNING_KEY_PASS }}
  IDE_SIGNING_STORE_PASS: ${{ secrets.IDE_SIGNING_STORE_PASS }}
  IDE_SIGNING_URL: ${{ secrets.IDE_SIGNING_URL }}
  IDE_SIGNING_KEY_BIN: ${{ secrets.IDE_SIGNING_KEY_BIN }}
  ORG_GRADLE_PROJECT_mavenCentralUsername: ${{ secrets.MVN_USERNAME }}
  ORG_GRADLE_PROJECT_mavenCentralPassword: ${{ secrets.MVN_PASSWORD }}
  ORG_GRADLE_PROJECT_signingInMemoryKey: ${{ secrets.MVN_SIGNING_KEY }}
  ORG_GRADLE_PROJECT_signingInMemoryKeyId: ${{ secrets.MVN_SIGNING_KEY_ID }}
  ORG_GRADLE_PROJECT_signingInMemoryKeyPassword: ${{ secrets.MVN_SIGNING_KEY_PASSWORD }}
  FIREBASE_CONSOLE_URL: ${{ secrets.FIREBASE_CONSOLE_URL }}

jobs:
  build_apk:
    name: Build Universal APK
    runs-on: self-hosted
    timeout-minutes: 60
    outputs:
      has_latest_stage: ${{ steps.check_stage_sync.outputs.has_latest_stage }}

    steps:
      - name: Cancel previous runs
        uses: styfle/cancel-workflow-action@0.12.1
        with:
          access_token: ${{ github.token }}

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Install and Configure Git LFS
        run: |
          sudo apt-get update
          sudo apt-get install -y git-lfs
          git lfs install
          git lfs pull

      - name: Initialize submodules
        run: |
          git submodule init
          git submodule update --remote

      - name: Fetch stage branch
        run: git fetch origin stage:stage

      - name: Check if branch is up to date with stage
        id: check_stage_sync
        run: |
          if [ "${{ github.event.pull_request.merged }}" = "true" ]; then
            # Post‑merge: has my branch tip landed in stage?
            if git merge-base --is-ancestor HEAD stage; then
              echo "has_latest_stage=true" >> $GITHUB_OUTPUT
            else
              echo "has_latest_stage=false" >> $GITHUB_OUTPUT
            fi
          else
            # Pre‑merge: have I pulled in everything from stage?
            if git merge-base --is-ancestor stage HEAD; then
              echo "has_latest_stage=true" >> $GITHUB_OUTPUT
            else
              echo "has_latest_stage=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Check if Nix is installed
        id: check_nix
        run: |
          if command -v nix >/dev/null 2>&1; then
            echo "nix_installed=true" >> $GITHUB_ENV
          else
            echo "nix_installed=false" >> $GITHUB_ENV
          fi

      - name: Install Flox (if needed)
        if: env.nix_installed == 'false'
        uses: flox/install-flox-action@v2

      - name: Assemble Universal APK
        run: flox activate -d flox/base -- ./gradlew :app:assembleV8Debug --no-daemon

      - name: Find APK file
        id: find_apk
        run: |
          apk_path=$(find app/build/outputs/apk/ -path "*v8*/debug/*.apk" | head -n 1)
          echo "APK_PATH=$apk_path" >> $GITHUB_OUTPUT

      - name: Set branch name
        run: echo "BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_ENV

      - name: Get PR and Commit Information
        id: pr_info
        run: |
          if [[ "$GITHUB_EVENT_NAME" == "pull_request" && ( "${{ github.event.action }}" == "opened" || "${{ github.event.action }}" == "synchronize" ) ]]; then
            # Extract info from GitHub event file for PR creation or updates
            EVENT_PATH="${GITHUB_EVENT_PATH}"
            COMMIT_MSG=$(jq -r '.pull_request.title' "$EVENT_PATH")
            PR_AUTHOR=$(jq -r '.pull_request.user.login' "$EVENT_PATH")
            PR_URL=$(jq -r '.pull_request.html_url' "$EVENT_PATH")
            echo "PR_NUMBER=$(jq -r '.pull_request.number' "$EVENT_PATH")" >> $GITHUB_OUTPUT
            echo "COMMIT_MSG=$COMMIT_MSG" >> $GITHUB_OUTPUT
            echo "PR_AUTHOR=$PR_AUTHOR" >> $GITHUB_OUTPUT
            echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
          else
            # Fallback to git log for non-PR builds
            COMMIT_MSG=$(git log -1 --pretty=%B)
            COMMIT_AUTHOR=$(git log -1 --pretty=%an)
            echo "COMMIT_MSG=$COMMIT_MSG" >> $GITHUB_OUTPUT
            echo "PR_AUTHOR=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
          fi

      - name: Extract Jira Ticket
        id: extract_jira
        run: |
          # Use regex to extract JIRA ticket in format ADFA-XXX
          JIRA_TICKET=$(echo "$BRANCH_NAME" | grep -o 'ADFA-[0-9]\+' | head -1)
          
          # If JIRA ticket was found, set the URL, otherwise set as N/A
          if [ -n "$JIRA_TICKET" ]; then
            JIRA_URL="https://appdevforall.atlassian.net/browse/${JIRA_TICKET}"
          else
            JIRA_TICKET="N/A"
            JIRA_URL="https://github.com/${{ github.repository }}/commit/${{ github.sha }} (Ref: ${{ github.ref }})"
          fi
          
          echo "JIRA_TICKET=$JIRA_TICKET" >> $GITHUB_OUTPUT
          echo "JIRA_URL=$JIRA_URL" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Upload to Firebase App Distribution and Extract URL
        id: firebase_upload
        run: |
          # Install firebase-tools
          npm install -g firebase-tools@13.10.1
          
          # Set up service account
          echo '${{ secrets.COGO_BUILD_SERVICE_ACCOUNT }}' > service-account.json
          export GOOGLE_APPLICATION_CREDENTIALS=service-account.json
          
          # Run Firebase distribution and capture output
          firebase appdistribution:distribute "${{ steps.find_apk.outputs.APK_PATH }}" \
            --app "${{ secrets.FIREBASE_APP_ID }}" \
            --groups "testers" \
            --release-notes "Stage Sync: ${{ steps.check_stage_sync.outputs.has_latest_stage == 'true' && '✅ Up to date with stage' || '⚠️ Branch is not up to date with stage' }}
          Ticket: ${{ steps.extract_jira.outputs.JIRA_URL }}" > firebase_output.txt 2>&1
          
          # Display the output for debugging
          cat firebase_output.txt
          
          # Extract Firebase console URL from output
          FIREBASE_URL=$(cat firebase_output.txt | grep -oE 'https://console\.firebase\.google\.com/project/[^/]+/appdistribution/app/[^/]+/releases/[^?]+(\?[^"]*)?') || FIREBASE_URL=""
          
          if [ -z "$FIREBASE_URL" ]; then
            echo "Firebase URL not found in output, using fallback URL"
            FIREBASE_URL="${{ env.FIREBASE_CONSOLE_URL }}"
          else
            echo "Successfully extracted Firebase URL: $FIREBASE_URL"
          fi
          
          echo "FIREBASE_CONSOLE_URL=$FIREBASE_URL" >> $GITHUB_OUTPUT
          
          # Clean up
          rm -f service-account.json firebase_output.txt

      - name: Send Rich Slack Notification
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          SYNC_FLAG="${{ steps.check_stage_sync.outputs.has_latest_stage }}"
          if [ "$SYNC_FLAG" = "true" ]; then
            SYNC_MSG="✅ Up to date with stage"
          else
            SYNC_MSG="⚠️ Branch is not up to date with stage"
          fi

          JIRA_TICKET="${{ steps.extract_jira.outputs.JIRA_TICKET }}"
          JIRA_URL="${{ steps.extract_jira.outputs.JIRA_URL }}"
          FIREBASE_CONSOLE_URL="${{ steps.firebase_upload.outputs.FIREBASE_CONSOLE_URL }}"
          PR_AUTHOR="${{ steps.pr_info.outputs.PR_AUTHOR }}"
          BRANCH_NAME="${{ env.BRANCH_NAME }}"
          COMMIT_MSG="${{ steps.pr_info.outputs.COMMIT_MSG }}"

          # Escape special characters in variables to prevent JSON issues
          COMMIT_MSG_ESCAPED=$(echo "$COMMIT_MSG" | sed 's/"/\\"/g' | sed "s/'/\\'/g")
          PR_AUTHOR_ESCAPED=$(echo "$PR_AUTHOR" | sed 's/"/\\"/g')
          BRANCH_NAME_ESCAPED=$(echo "$BRANCH_NAME" | sed 's/"/\\"/g')

          # Create JSON payload
          cat > payload.json << EOF
          {
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": ":rocket: New Build Available",
                  "emoji": true
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "@here Please review and test this build."
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Stage Sync:* $SYNC_MSG"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Jira Ticket:* <$JIRA_URL|$JIRA_TICKET>"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Commit:* $COMMIT_MSG_ESCAPED"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Author:* $PR_AUTHOR_ESCAPED"
                }
              },
              {
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "View on Firebase",
                      "emoji": true
                    },
                    "url": "$FIREBASE_CONSOLE_URL",
                    "action_id": "firebase-console"
                  },
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "View Ticket",
                      "emoji": true
                    },
                    "url": "$JIRA_URL",
                    "action_id": "jira-ticket"
                  }
                ]
              },
              {
                "type": "divider"
              },{
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": "Deployed from branch \`$BRANCH_NAME_ESCAPED\`"
                  }
                ]
              }
            ]
          }
          EOF

          # Debug: Print the payload to logs (optional)
          echo "Slack payload:"
          cat payload.json

          # Send to Slack
          curl -X POST -H "Content-Type: application/json" --data @payload.json "$SLACK_WEBHOOK"